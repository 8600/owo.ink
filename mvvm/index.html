<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  
    <meta name="description" content="一、几种实现双向绑定的做法
目前几种主流的 mvc(vm) 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（ input 、 textare 等）添加了 change(input) 事件，来动态修改 model和 view ，并没有多高深。所以无需太过介怀是" />
  
  
  
  
  
  
  <title>实现数据的双向绑定mvvm-剖析Vue的原理 | owo.ink</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、几种实现双向绑定的做法 目前几种主流的 mvc(vm) 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（ input 、 textare 等）添加了 change(input) 事件，来动态修改 model和 view ，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。 发布者-订阅者模式（ backbone.js ）脏值检查（ angular.">
<meta property="og:type" content="article">
<meta property="og:title" content="实现数据的双向绑定mvvm-剖析Vue的原理">
<meta property="og:url" content="https://owo.ink/mvvm/index.html">
<meta property="og:site_name" content="owo.ink">
<meta property="og:description" content="一、几种实现双向绑定的做法 目前几种主流的 mvc(vm) 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（ input 、 textare 等）添加了 change(input) 事件，来动态修改 model和 view ，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。 发布者-订阅者模式（ backbone.js ）脏值检查（ angular.">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://ouqjus79v.bkt.clouddn.com//b636BjI.png!web">
<meta property="og:image" content="http://ouqjus79v.bkt.clouddn.com//yAjMnqV.png!web">
<meta property="og:updated_time" content="2018-02-28T09:35:42.541Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现数据的双向绑定mvvm-剖析Vue的原理">
<meta name="twitter:description" content="一、几种实现双向绑定的做法 目前几种主流的 mvc(vm) 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（ input 、 textare 等）添加了 change(input) 事件，来动态修改 model和 view ，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。 发布者-订阅者模式（ backbone.js ）脏值检查（ angular.">
<meta name="twitter:image" content="http://ouqjus79v.bkt.clouddn.com//b636BjI.png!web">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
  <hgroup>
    <h1 class="site-title">
      <a href="/" title="owo.ink" rel="home">owo.ink</a>
    </h1>
    
  </hgroup>

  <nav id="site-navigation" class="main-navigation" role="navigation">
    <button class="menu-toggle">菜单</button>
    <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
    <div class="menu-main-container">
      <ul id="menu-main" class="nav-menu">
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">主页</a></li>
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">归档</a></li>
      
      </ul>
    </div>
  </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-mvvm" class="post-mvvm post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      实现数据的双向绑定mvvm-剖析Vue的原理
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>一、几种实现双向绑定的做法</p>
<p>目前几种主流的 <code>mvc(vm)</code> 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（ <code>input</code> 、 <code>textare</code> 等）添加了 <code>change(input)</code> 事件，来动态修改 <code>model</code>和 <code>view</code> ，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。</p>
<p>发布者-订阅者模式（ <code>backbone.js</code> ）<br>脏值检查（ <code>angular.js</code> ）<br>数据劫持（ <code>vue.js</code> ）</p>
<p>1.1 发布者-订阅者模式</p>
<ul>
<li>一般通过 <code>sub</code> , <code>pub</code> 的方式实现数据和视图的绑定监听，更新数据方式通常做法是 <code>vm.set(&#39;property&#39;, value)</code> ， <a href="http://www.html-js.com/article/Study-of-twoway-data-binding-JavaScript-talk-about-JavaScript-every-day" target="_blank" rel="external">这里有篇文章讲的比较详细
</a></li>
<li>这种方式现在毕竟太low了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式</li>
</ul>
<p>1.2 脏值检查</p>
<p><code>angular.js</code> 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 <code>setInterval()</code> 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：</p>
<ul>
<li>DOM 事件，譬如用户输入文本，点击按钮等。( <code>ng-click</code> )</li>
<li>XHR 响应事件 ( <code>$http</code> )</li>
<li>浏览器 <code>Location</code> 变更事件 ( <code>$location</code> )</li>
<li>Timer 事件( <code>$timeout</code> , <code>$interval</code> )</li>
<li>执行 <code>$digest()</code> 或 <code>$apply()</code></li>
</ul>
<p>1.3 数据劫持<br><code>vue.js</code> 则是采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 <code>setter</code> ， <code>getter</code> ，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>二、实现思路<br>已经了解到 <code>vue</code> 是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过 <code>Object.defineProperty()</code> 来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉 <code>defineProperty</code> ，猛戳 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">这里</a></p>
<p>要实现<code>mvvm</code>的双向绑定，就必须要实现以下几点</p>
<ul>
<li>实现一个数据监听器 <code>Observer</code> ，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li>
<li>实现一个指令解析器 <code>Compile</code> ，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li>
<li>实现一个 <code>Watcher</code> ，作为连接 <code>Observer</code> 和 <code>Compile</code> 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li>
<li><code>mvvm</code> 入口函数，整合以上三者</li>
</ul>
<p>上述流程如图所示：<br><img src="http://ouqjus79v.bkt.clouddn.com//b636BjI.png!web" alt="b636BjI.png!web"></p>
<p>2.1 实现Observer</p>
<ul>
<li><p>我们知道可以利用 <code>Obeject.defineProperty()</code> 来监听属性变动</p>
</li>
<li><p>那么将需要 <code>observe</code> 的数据对象进行递归遍历，包括子属性对象的属性，都加上 <code>setter</code> 和 <code>getter</code></p>
</li>
<li><p>这样的话，给这个对象的某个值赋值，就会触发 <code>setter</code> ，那么就能监听到了数据变化。相关代码可以是这样</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var data = &#123;name: &apos;kindeng&apos;&#125;;</div><div class="line">observe(data);</div><div class="line">data.name = &apos;dmq&apos;; // 哈哈哈，监听到值变化了 kindeng --&gt; dmq</div><div class="line"></div><div class="line">function observe(data) &#123;</div><div class="line">    if (!data || typeof data !== &apos;object&apos;) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 取出所有属性遍历</div><div class="line">    Object.keys(data).forEach(function(key) &#123;</div><div class="line">	    defineReactive(data, key, data[key]);</div><div class="line">	&#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function defineReactive(data, key, val) &#123;</div><div class="line">    observe(val); // 监听子属性</div><div class="line">    Object.defineProperty(data, key, &#123;</div><div class="line">        enumerable: true, // 可枚举</div><div class="line">        configurable: false, // 不能再define</div><div class="line">        get: function() &#123;</div><div class="line">            return val;</div><div class="line">        &#125;,</div><div class="line">        set: function(newVal) &#123;</div><div class="line">            console.log(&apos;哈哈哈，监听到值变化了 &apos;, val, &apos; --&gt; &apos;, newVal);</div><div class="line">            val = newVal;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码 h<a href="ttps://github.com/poetries/mvvm/blob/master/observer.js" target="_blank" rel="external">ttps://github.com/poetries/mvvm/blob/master/observer.js</a></p>
<p>这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发 <code>notify</code> ，再调用订阅者的 <code>update</code> 方法，代码改善之后是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// ... 省略</div><div class="line">function defineReactive(data, key, val) &#123;</div><div class="line">	var dep = new Dep();</div><div class="line">    observe(val); // 监听子属性</div><div class="line"></div><div class="line">    Object.defineProperty(data, key, &#123;</div><div class="line">        // ... 省略</div><div class="line">        set: function(newVal) &#123;</div><div class="line">        	if (val === newVal) return;</div><div class="line">            console.log(&apos;哈哈哈，监听到值变化了 &apos;, val, &apos; --&gt; &apos;, newVal);</div><div class="line">            val = newVal;</div><div class="line">            dep.notify(); // 通知所有订阅者</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Dep() &#123;</div><div class="line">    this.subs = [];</div><div class="line">&#125;</div><div class="line">Dep.prototype = &#123;</div><div class="line">    addSub: function(sub) &#123;</div><div class="line">        this.subs.push(sub);</div><div class="line">    &#125;,</div><div class="line">    notify: function() &#123;</div><div class="line">        this.subs.forEach(function(sub) &#123;</div><div class="line">            sub.update();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>那么问题来了，谁是订阅者，怎么往订阅器添加订阅者？</p>
</li>
<li><p>没错，上面的思路整理中我们已经明确订阅者应该是 Watcher , 而且 var dep = new Dep(); 是在 defineReactive 方法内部定义的，所以想通过 dep 添加订阅者，就必须要在闭包内操作，所以我们可以在 getter 里面动手脚：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// Observer.js</div><div class="line">// ...省略</div><div class="line">Object.defineProperty(data, key, &#123;</div><div class="line">	get: function() &#123;</div><div class="line">		// 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除</div><div class="line">		Dep.target &amp;&amp; dep.addDep(Dep.target);</div><div class="line">		return val;</div><div class="line">	&#125;</div><div class="line">    // ... 省略</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// Watcher.js</div><div class="line">Watcher.prototype = &#123;</div><div class="line">	get: function(key) &#123;</div><div class="line">		Dep.target = this;</div><div class="line">		this.value = data[key];	// 这里会触发属性的getter，从而添加订阅者</div><div class="line">		Dep.target = null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这里已经实现了一个 Observer 了，已经具备了监听数据和数据变化通知订阅者的功能。那么接下来就是实现 Compile 了</li>
</ul>
<p>2.2 实现 Compile</p>
<ul>
<li>compile 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图</li>
<li><p>并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示<br><img src="http://ouqjus79v.bkt.clouddn.com//yAjMnqV.png!web" alt="yAjMnqV.png!web"></p>
</li>
<li><p>因为遍历解析的过程有多次操作 dom 节点，为提高性能和效率，会先将跟节点 el 转换成文档碎片 fragment 进行解析编译操作</p>
</li>
<li>解析完成，再将 fragment 添加回原来的真实 dom 节点中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Compile(el) &#123;</div><div class="line">    this.$el = this.isElementNode(el) ? el : document.querySelector(el);</div><div class="line">    if (this.$el) &#123;</div><div class="line">        this.$fragment = this.node2Fragment(this.$el);</div><div class="line">        this.init();</div><div class="line">        this.$el.appendChild(this.$fragment);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Compile.prototype = &#123;</div><div class="line">	init: function() &#123; this.compileElement(this.$fragment); &#125;,</div><div class="line">    node2Fragment: function(el) &#123;</div><div class="line">        var fragment = document.createDocumentFragment(), child;</div><div class="line">        // 将原生节点拷贝到fragment</div><div class="line">        while (child = el.firstChild) &#123;</div><div class="line">            fragment.appendChild(child);</div><div class="line">        &#125;</div><div class="line">        return fragment;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>compileElement 方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">Compile.prototype = &#123;</div><div class="line">	// ... 省略</div><div class="line">	compileElement: function(el) &#123;</div><div class="line">        var childNodes = el.childNodes, me = this;</div><div class="line">        [].slice.call(childNodes).forEach(function(node) &#123;</div><div class="line">            var text = node.textContent;</div><div class="line">            var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;	// 表达式文本</div><div class="line">            // 按元素节点方式编译</div><div class="line">            if (me.isElementNode(node)) &#123;</div><div class="line">                me.compile(node);</div><div class="line">            &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</div><div class="line">                me.compileText(node, RegExp.$1);</div><div class="line">            &#125;</div><div class="line">            // 遍历编译子节点</div><div class="line">            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</div><div class="line">                me.compileElement(node);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    compile: function(node) &#123;</div><div class="line">        var nodeAttrs = node.attributes, me = this;</div><div class="line">        [].slice.call(nodeAttrs).forEach(function(attr) &#123;</div><div class="line">            // 规定：指令以 v-xxx 命名</div><div class="line">            // 如 &lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt; 中指令为 v-text</div><div class="line">            var attrName = attr.name;	// v-text</div><div class="line">            if (me.isDirective(attrName)) &#123;</div><div class="line">                var exp = attr.value; // content</div><div class="line">                var dir = attrName.substring(2);	// text</div><div class="line">                if (me.isEventDirective(dir)) &#123;</div><div class="line">                	// 事件指令, 如 v-on:click</div><div class="line">                    compileUtil.eventHandler(node, me.$vm, exp, dir);</div><div class="line">                &#125; else &#123;</div><div class="line">                	// 普通指令</div><div class="line">                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 指令处理集合</div><div class="line">var compileUtil = &#123;</div><div class="line">    text: function(node, vm, exp) &#123;</div><div class="line">        this.bind(node, vm, exp, &apos;text&apos;);</div><div class="line">    &#125;,</div><div class="line">    // ...省略</div><div class="line">    bind: function(node, vm, exp, dir) &#123;</div><div class="line">        var updaterFn = updater[dir + &apos;Updater&apos;];</div><div class="line">        // 第一次初始化视图</div><div class="line">        updaterFn &amp;&amp; updaterFn(node, vm[exp]);</div><div class="line">        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher</div><div class="line">        new Watcher(vm, exp, function(value, oldValue) &#123;</div><div class="line">        	// 一旦属性值有变化，会收到通知执行此更新函数，更新视图</div><div class="line">            updaterFn &amp;&amp; updaterFn(node, value, oldValue);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 更新函数</div><div class="line">var updater = &#123;</div><div class="line">    textUpdater: function(node, value) &#123;</div><div class="line">        node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value;</div><div class="line">    &#125;</div><div class="line">    // ...省略</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>2.3 实现Watcher</p>
<p>Watcher 订阅者作为 Observer 和 Compile 之间通信的桥梁，主要做的事情是</p>
<ul>
<li>在自身实例化时往属性订阅器 dep 里面添加自己</li>
<li>自身必须有一个 update() 方法</li>
<li>待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">function Watcher(vm, exp, cb) &#123;</div><div class="line">    this.cb = cb;</div><div class="line">    this.vm = vm;</div><div class="line">    this.exp = exp;</div><div class="line">    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解</div><div class="line">    this.value = this.get(); </div><div class="line">&#125;</div><div class="line">Watcher.prototype = &#123;</div><div class="line">    update: function() &#123;</div><div class="line">        this.run();	// 属性值变化收到通知</div><div class="line">    &#125;,</div><div class="line">    run: function() &#123;</div><div class="line">        var value = this.get(); // 取到最新值</div><div class="line">        var oldVal = this.value;</div><div class="line">        if (value !== oldVal) &#123;</div><div class="line">            this.value = value;</div><div class="line">            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    get: function() &#123;</div><div class="line">        Dep.target = this;	// 将当前订阅者指向自己</div><div class="line">        var value = this.vm[exp];	// 触发getter，添加自己到属性订阅器中</div><div class="line">        Dep.target = null;	// 添加完毕，重置</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// 这里再次列出Observer和Dep，方便理解</div><div class="line">Object.defineProperty(data, key, &#123;</div><div class="line">	get: function() &#123;</div><div class="line">		// 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除</div><div class="line">		Dep.target &amp;&amp; dep.addDep(Dep.target);</div><div class="line">		return val;</div><div class="line">	&#125;</div><div class="line">    // ... 省略</div><div class="line">&#125;);</div><div class="line">Dep.prototype = &#123;</div><div class="line">    notify: function() &#123;</div><div class="line">        this.subs.forEach(function(sub) &#123;</div><div class="line">            sub.update(); // 调用订阅者的update方法，通知变化</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>完整代码 <a href="https://github.com/poetries/mvvm/blob/master/watcher.js" target="_blank" rel="external">https://github.com/poetries/mvvm/blob/master/watcher.js</a></p>
<ul>
<li>实例化 Watcher 的时候，调用 get() 方法，通过 Dep.target = watcherInstance 标记订阅者是当前 watcher 实例，强行触发属性定义的 getter 方法， getter 方法执行的时候，就会在属性的订阅器 dep 添加当前 watcher 实例，从而在属性值有变化的时候， watcherInstance 就能收到更新通知。</li>
<li>基本上 vue 中数据绑定相关比较核心的几个模块也是这几个，猛戳 这里 , 在 src 目录可找到 vue 源码。<br>最后来讲讲 MVVM 入口文件的相关逻辑和实现吧，相对就比较简单了</li>
</ul>
<p>三、实现MVVM<br>MVVM 作为数据绑定的入口，整合 <code>Observer</code> 、 <code>Compile</code> 和 <code>Watcher</code> 三者，通过 <code>Observer</code> 来监听自己的 <code>model</code> 数据变化，通过 <code>Compile</code> 来解析编译模板指令，最终利用 Watcher 搭起 <code>Observer</code> 和 <code>Compile</code> 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化( input ) -&gt; 数据 <code>model</code> 变更的双向绑定效果。</p>
<ul>
<li>一个简单的 MVVM 构造器是这样子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function MVVM(options) &#123;</div><div class="line">    this.$options = options;</div><div class="line">    var data = this._data = this.$options.data;</div><div class="line">    observe(data, this);</div><div class="line">    this.$compile = new Compile(options.el || document.body, this)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>但是这里有个问题，从代码中可看出监听的数据对象是 options.data ，每次需要更新视图，则必须通过 <code>var vm = new MVVM({data:{name: &#39;kindeng&#39;}}); vm._data.name = &#39;dmq&#39;;</code> 这样的方式来改变数据。</li>
<li>显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：<br><code>var vm = new MVVM({data: {name: &#39;kindeng&#39;}}); vm.name = &#39;dmq&#39;;</code>* 所以这里需要给 <code>MVVM</code> 实例添加一个属性代理的方法，使访问 vm 的属性代理为访问 <code>vm._data</code> 的属性，改造后的代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function MVVM(options) &#123;</div><div class="line">    this.$options = options;</div><div class="line">    var data = this._data = this.$options.data, me = this;</div><div class="line">    // 属性代理，实现 vm.xxx -&gt; vm._data.xxx</div><div class="line">    Object.keys(data).forEach(function(key) &#123;</div><div class="line">        me._proxy(key);</div><div class="line">    &#125;);</div><div class="line">    observe(data, this);</div><div class="line">    this.$compile = new Compile(options.el || document.body, this)</div><div class="line">&#125;</div><div class="line"></div><div class="line">MVVM.prototype = &#123;</div><div class="line">	_proxy: function(key) &#123;</div><div class="line">		var me = this;</div><div class="line">        Object.defineProperty(me, key, &#123;</div><div class="line">            configurable: false,</div><div class="line">            enumerable: true,</div><div class="line">            get: function proxyGetter() &#123;</div><div class="line">                return me._data[key];</div><div class="line">            &#125;,</div><div class="line">            set: function proxySetter(newVal) &#123;</div><div class="line">                me._data[key] = newVal;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码 <a href="https://github.com/poetries/mvvm/blob/master/mvvm.js" target="_blank" rel="external">https://github.com/poetries/mvvm/blob/master/mvvm.js</a></p>
<p>这里主要还是利用了 <code>Object.defineProperty()</code> 这个方法来劫持了 vm 实例对象的属性的读写权，使读写 vm 实例的属性转成读写了 <code>vm._data</code> 的属性值，达到鱼目混珠的效果</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/mvvm/">
    <time datetime="2018-02-28T09:34:59.357Z" class="entry-date">
        2018-02-28
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
    
        <span class="nav-next"><a href="/array-operation-advice/" rel="next">给初学者：JavaScript 中数组操作注意点 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/mvvm/">实现数据的双向绑定mvvm-剖析Vue的原理</a>
          </li>
        
          <li>
            <a href="/array-operation-advice/">给初学者：JavaScript 中数组操作注意点</a>
          </li>
        
          <li>
            <a href="/generators/">ES6 Generators详解</a>
          </li>
        
          <li>
            <a href="/saveFile/">js保存文件</a>
          </li>
        
          <li>
            <a href="/string/">JavaScript 字符串实用常操纪要</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2018 PUGE
    All rights reserved.</p>
    <p>Powered by <a href="https://owo.ink/" target="_blank">PUGE</a></p>
</footer>
    <div id="bg"></div>

  </div>
</body>
</html>