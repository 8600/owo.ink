{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/transparent/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/transparent/source/css/images/body.gif","path":"css/images/body.gif","modified":0,"renderable":1},{"_id":"themes/transparent/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":0,"renderable":1}],"Cache":[{"_id":"themes/transparent/package.json","hash":"0e0b80bc8fabfcf44e363fac08d0d34d4ac983b8","modified":1455499185000},{"_id":"themes/transparent/_config.yml","hash":"edb8e6cce7fa177c1f637c321ac29fb3d093e297","modified":1500622757850},{"_id":"source/_posts/electron.md","hash":"e613f8b35cb870a2b067886deebd51136ce9bab6","modified":1500624774047},{"_id":"themes/transparent/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1455499185000},{"_id":"source/_posts/array.md","hash":"ca40d1d031015b8de5f2496072a8adc490f99705","modified":1500625003702},{"_id":"source/_posts/flexbox.md","hash":"5562a0375fbc6aa74444f4c53713bc5ef886ba1d","modified":1502877283419},{"_id":"source/_posts/dns-prefetch.md","hash":"6a9b04b5619fcf197ffc49cc49aeb7496ffcbbf6","modified":1501636484242},{"_id":"source/_posts/faster-css.md","hash":"a339d12bc675f9489e1883652cf63fa949e3ac0d","modified":1500625170563},{"_id":"source/_posts/hello-world.md","hash":"f6459074bc4ff7aac9fceac67963cb0e4c225f9a","modified":1500622531780},{"_id":"source/_posts/meteor.md","hash":"57f1cb5adb5f36bad3e805bbb98e4b4cebe04810","modified":1500625253912},{"_id":"source/_posts/mobile-phone-system.md","hash":"daf15a10b726b6d4288040f333a604dd7b95f3fb","modified":1500625583522},{"_id":"source/_posts/nodejs-email.md","hash":"a1a16985a3753a1a6f0cc20de5d74fefde8d979c","modified":1502877411592},{"_id":"source/_posts/html5.md","hash":"d4e084d20aa7c57a29b94192597bd5371f2c082f","modified":1502100152476},{"_id":"source/_posts/npm.md","hash":"0c06d320fd5bf9bacb7fd21f9b9ea6be1f72c06a","modified":1500625077795},{"_id":"source/_posts/json.md","hash":"27b9819034bd3619126c51195cc7458da02ce6c7","modified":1500624851223},{"_id":"source/_posts/text.md","hash":"648282df2d6a4e9f8ff2ac90581e6da6f6e2ed4b","modified":1500625434557},{"_id":"themes/transparent/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1455499185000},{"_id":"themes/transparent/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1455499185000},{"_id":"themes/transparent/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1455499185000},{"_id":"themes/transparent/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1455499185000},{"_id":"themes/transparent/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1455499185000},{"_id":"themes/transparent/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1455499185000},{"_id":"source/_posts/order.md","hash":"f85a9bc7df304f5d50a070bcc342fd18bb7a51c8","modified":1500624651454},{"_id":"source/_posts/promise.md","hash":"3184b9ad1c67b9fcc545e5b47f68e899bfe1277a","modified":1501659322299},{"_id":"themes/transparent/layout/_partial/archive-post.ejs","hash":"663b7c316355ef91634a9bbf7470dcbc14b83f65","modified":1455499185000},{"_id":"themes/transparent/layout/layout.ejs","hash":"c6ba9dd8928c46f83e6cb35162505e46de9e1682","modified":1500621028418},{"_id":"themes/transparent/layout/_partial/after-footer.ejs","hash":"c86b3a6e389b9f8dbd39b070746cd5f882ff7c09","modified":1500621055887},{"_id":"themes/transparent/layout/_partial/article.ejs","hash":"75234946c2a525101174d445f700e3391966478b","modified":1500622685029},{"_id":"themes/transparent/layout/_partial/comment.ejs","hash":"9c00634e41d531df23d1b0df2bff2321e34b9ec5","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/archive.ejs","hash":"bb0b0b0a729478b0d428fd7d54f37e93d74004ee","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/footer.ejs","hash":"d410793383e373cd096a940bf65006652708afc8","modified":1500621560678},{"_id":"themes/transparent/layout/_partial/header.ejs","hash":"bfcbb80de068bf9c8b46ba9ca44b2928dc2b56d1","modified":1500620676452},{"_id":"themes/transparent/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/sidebar.ejs","hash":"b9295e2d892df9dffec829859b02281667f85cc1","modified":1455499185000},{"_id":"themes/transparent/layout/_widget/category.ejs","hash":"55377d96929eba1d6ece9cc06b07a34323909092","modified":1455499185000},{"_id":"themes/transparent/layout/_widget/archive.ejs","hash":"3cb67a156855435ddf50fa6082b34d8e21f7c52b","modified":1455499185000},{"_id":"themes/transparent/layout/_widget/music.ejs","hash":"4a87ab9604e5eb9698c1d7e64c5b542f7d927ce5","modified":1455499185000},{"_id":"themes/transparent/layout/_widget/search.ejs","hash":"b5376aed197fcd989e4a413151aba29af845073e","modified":1455499185000},{"_id":"themes/transparent/layout/_widget/recent_posts.ejs","hash":"ac5682bb66c8fc07e1d1011c93f29c617eab9d34","modified":1455499185000},{"_id":"themes/transparent/source/css/style.css","hash":"3e0fcd77ec3dea6aaaff6d0b074ed2719c769563","modified":1502848234683},{"_id":"themes/transparent/layout/_widget/tagcloud.ejs","hash":"ebe3b3d32fce2e9154d333e859f26ed64748327f","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/head.ejs","hash":"8bb02b2d728d161fd5d2ca89e13e98717b7ef3bb","modified":1500545503043},{"_id":"themes/transparent/layout/_partial/post/date.ejs","hash":"69785676b6f09a028c75170f3f2d1cb143af9be6","modified":1455499185000},{"_id":"themes/transparent/layout/_widget/tag.ejs","hash":"a62e83cb0214016d2ca2a6e21455e601c8a201eb","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/post/category.ejs","hash":"8e086ae9864d487d6183ac6e16b92fb35a68639b","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/post/nav.ejs","hash":"2a7cfa6b3ab280d93ae0b4ba8ae3da9b04c80682","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/post/title.ejs","hash":"97d01c3ff12453d76edf5af31dfed9859b3efc5b","modified":1455499185000},{"_id":"themes/transparent/layout/_partial/post/tag.ejs","hash":"ae103b5970c77299547f269b54d046bcc8f38251","modified":1455499185000},{"_id":"themes/transparent/source/css/images/body.gif","hash":"fbfea7993c52e86e8ded6907c3bbaf9518f47a38","modified":1501641511646},{"_id":"themes/transparent/source/css/images/favicon.ico","hash":"ef192eb9080ab13f6168c8d450658f4b1ace70ed","modified":1501642365391},{"_id":"public/mobile-phone-system/index.html","hash":"07b6e4ffe82ab7e2f8133e0e04707678e8121c8c","modified":1502877465501},{"_id":"public/text/index.html","hash":"01f07d434cfa84d1463a340caf905742ca7f2d2b","modified":1502877465501},{"_id":"public/meteor/index.html","hash":"d87d444bc8b62729dd1ef9de8e53399fc75113a2","modified":1502877465501},{"_id":"public/faster-css/index.html","hash":"8d95c3959ae120b809219525a8ce7f81293102ff","modified":1502877465501},{"_id":"public/npm/index.html","hash":"8758d4efc2fd1c9a834910a579a678afc580347d","modified":1502877465501},{"_id":"public/json/index.html","hash":"c5f07b3c5352709991d5cf9d73c7bfbd48ab3e05","modified":1502877465501},{"_id":"public/electron/index.html","hash":"057363c2412368eccb39158d26e2c87bc53f712d","modified":1502877465501},{"_id":"public/order/index.html","hash":"fc97d694df3ef8810dcc5d04e474fedcf4ba455a","modified":1502877465501},{"_id":"public/dns-prefetch/index.html","hash":"23cd49807e06c6360519e56ba1603d5de16dd26f","modified":1502877465501},{"_id":"public/flexbox/index.html","hash":"8d2b1ebe09a1e9fd3ad8fbbda752275e97316ed9","modified":1502877465501},{"_id":"public/hello-world/index.html","hash":"7d4ee2d40631f0c68d670ef0556c9e65ded1f01c","modified":1502877465501},{"_id":"public/archives/index.html","hash":"3ab86bbdd91a74728cf778922f10834fb06434a4","modified":1502877465501},{"_id":"public/archives/page/2/index.html","hash":"19bd318cdffd7d8d9392d804acdfc4c5268b1dfe","modified":1502877465501},{"_id":"public/archives/2017/index.html","hash":"12e222a0c5e46a5b8c9f9695632660ae568927ca","modified":1502877465501},{"_id":"public/archives/2017/page/2/index.html","hash":"fb25c50d0104e82ac7a730676c761c6547ff394a","modified":1502877465501},{"_id":"public/archives/2017/07/index.html","hash":"1d2ffbca1af301cd85df2a3b8e8b0af3a5df2032","modified":1502877465501},{"_id":"public/archives/2017/07/page/2/index.html","hash":"a706ce525a0f28efb458d5e0f677862df4d1233d","modified":1502877465501},{"_id":"public/archives/2017/08/index.html","hash":"12af02c7608fbf0fba7faafee457a25334542686","modified":1502877465501},{"_id":"public/html5/index.html","hash":"78b5e48b28b0100dd401379c2ef74f303497150c","modified":1502877465501},{"_id":"public/promise/index.html","hash":"1b3407970ec962bd42f2c754aaeb59155529fcea","modified":1502877465501},{"_id":"public/nodejs-email/index.html","hash":"1300de0a6f5bfa5f0f9bb9b8dbd0ccfdb5f4b985","modified":1502877465501},{"_id":"public/array/index.html","hash":"60a4831196676acec43d2f161916035c211cf289","modified":1502877465501},{"_id":"public/index.html","hash":"4636460ee57dd52ec5848c6cd6787069bc083533","modified":1502877465501},{"_id":"public/page/2/index.html","hash":"534416ec0101988950b763ed52a561d27faf1922","modified":1502877465501},{"_id":"public/css/images/body.gif","hash":"fbfea7993c52e86e8ded6907c3bbaf9518f47a38","modified":1502877465501},{"_id":"public/css/images/favicon.ico","hash":"ef192eb9080ab13f6168c8d450658f4b1ace70ed","modified":1502877465501},{"_id":"public/css/style.css","hash":"bc6fa6fd1fed458ff1073bf31f2e1567ab1fb56d","modified":1502877465517},{"_id":"source/_posts/es2017.md","hash":"5695f90f0fc06b760e1343e6350e300c03ac1328","modified":1503381804226}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"electron","_content":"替换国内下载源:\n\n`npm config set ELECTRON_MIRROR=\"https://npm.taobao.org/mirrors/electron/\"`","source":"_posts/electron.md","raw":"---\ntitle: electron\n---\n替换国内下载源:\n\n`npm config set ELECTRON_MIRROR=\"https://npm.taobao.org/mirrors/electron/\"`","slug":"electron","published":1,"date":"2017-07-21T08:12:35.453Z","updated":"2017-07-21T08:12:54.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsux000038tzqoo3pvw4","content":"<p>替换国内下载源:</p>\n<p><code>npm config set ELECTRON_MIRROR=&quot;https://npm.taobao.org/mirrors/electron/&quot;</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>替换国内下载源:</p>\n<p><code>npm config set ELECTRON_MIRROR=&quot;https://npm.taobao.org/mirrors/electron/&quot;</code></p>\n"},{"title":"JavaScript 数组方法对比","_content":"JavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。\n\n注意：区分以下两个方法的不同点：\n\n* array.splice() 影响原来的数组\n* array.slice() 不影响原来的数组\n\n##### I. 新增：影响原数组\n\n使用 array.push() 和 array.ushift() 新增元素会影响原来的数组。\n```\nlet mutatingAdd = ['a', 'b', 'c', 'd', 'e']; \nmutatingAdd.push('f'); // ['a', 'b', 'c', 'd', 'e', 'f']\nmutatingAdd.unshift('z'); // ['z', 'b', 'c', 'd', 'e' 'f']\n```\n##### II. 新增：不影响原数组\n\n两种方式新增元素不会影响原数组，第一种是 array.concat() 。\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e'];\nconst arr2 = arr1.concat('f'); // ['a', 'b', 'c', 'd', 'e', 'f']  （注：原文有误，我做了修改 “.” ---> “,”）\nconsole.log(arr1); // ['a', 'b', 'c', 'd', 'e']\n```\n第二种方法是使用 JavaScript 的展开（spread）操作符，展开操作符是三个点（…）\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e'];\nconst arr2 = [...arr1, 'f']; // ['a', 'b', 'c', 'd', 'e', 'f']  \nconst arr3 = ['z', ...arr1]; // ['z', 'a', 'b', 'c', 'd', 'e']\n```\n展开操作符会复制原来的数组，从原数组取出所有元素，然后存入新的环境。\n\n##### III. 移除：影响原数组\n\n使用 array.pop() 和 array.shift() 移除数组元素时，会影响原来的数组。\n```\nlet mutatingRemove = ['a', 'b', 'c', 'd', 'e'];  \nmutatingRemove.pop(); // ['a', 'b', 'c', 'd']  \nmutatingRemove.shift(); // ['b', 'c', 'd']\n```\narray.pop() 和 array.shift() 返回被移除的元素，你可以通过一个变量获取被移除的元素。\n```\nlet mutatingRemove = ['a', 'b', 'c', 'd', 'e'];\nconst returnedValue1 = mutatingRemove.pop();  \nconsole.log(mutatingRemove); // ['a', 'b', 'c', 'd']  \nconsole.log(returnedValue1); // 'e'\nconst returnedValue2 = mutatingRemove.shift();  \nconsole.log(mutatingRemove); // ['b', 'c', 'd']  \nconsole.log(returnedValue2); // 'a'\n```\narray.splice() 也可以删除数组的元素。\n```\nlet mutatingRemove = ['a', 'b', 'c', 'd', 'e'];  \nmutatingRemove.splice(0, 2); // ['c', 'd', 'e']\n```\n像 array.pop() 和 array.shift() 一样，array.splice() 同样返回移除的元素。\n```\nlet mutatingRemove = ['a', 'b', 'c', 'd', 'e'];  \nlet returnedItems = mutatingRemove.splice(0, 2);  \nconsole.log(mutatingRemove); // ['c', 'd', 'e']  \nconsole.log(returnedItems) // ['a', 'b']\n```\n##### IV. 移除：不影响原数组\nJavaScript 的 array.filter() 方法基于原数组创建一个新数组，新数组仅包含匹配特定条件的元素。\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e'];\nconst arr2 = arr1.filter(a => a !== 'e'); // ['a', 'b', 'c', 'd']（注：原文有误，我做了修改）  \n// 或者\nconst arr2 = arr1.filter(a => {  \n  return a !== 'e';\n}); // ['a', 'b', 'c', 'd']（注：原文有误，我做了修改）\n```\n以上代码的条件是“不等于 ‘e’ ”，因此新数组（arr2）里面没有包含 ‘e’。\n\n箭头函数的独特性：\n\n单行箭头函数，’return’ 关键字是默认自带的，不需要手动书写。\n\n可是，多行箭头函数就需要明确地返回一个值。\n\n另一种不影响原数组的方式是 array.slice()（不要与 array.splice() 混淆）。\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e'];  \nconst arr2 = arr1.slice(1, 5) // ['b', 'c', 'd', 'e']  \nconst arr3 = arr1.slice(2) // ['c', 'd', 'e']\n```\n##### V. 替换：影响原数组\n\n如果知道替换哪一个元素，可以使用 array.splice() 。\n\n```\nlet mutatingReplace = ['a', 'b', 'c', 'd', 'e'];  \nmutatingReplace.splice(2, 1, 30); // ['a', 'b', 30, 'd', 'e']  \n// 或者\nmutatingReplace.splice(2, 1, 30, 31); // ['a', 'b', 30, 31, 'd', 'e']\n```\n##### VI. 替换：不影响原数组\n\n可以使用 array.map() 创建一个新数组，并且可以检查每一个元素，根据特定的条件替换它们。\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e']  \nconst arr2 = arr1.map(item => {  \n  if(item === 'c') {\n    item = 'CAT';\n  }\n  return item;\n}); // ['a', 'b', 'CAT', 'd', 'e']\n```\n使用 array.map() 转换数据\n\narray.map() 是个强力方法，可以用于转换数据，而不污染原先的数据源。\n```\nconst origArr = ['a', 'b', 'c', 'd', 'e'];  \nconst transformedArr = origArr.map(n => n + 'Hi!'); // ['aHi!', 'bHi!', 'cHi!', 'dHi!', 'eHi!']  \nconsole.log(origArr); // ['a', 'b', 'c', 'd', 'e']; // 原数组毫发无损\n```","source":"_posts/array.md","raw":"---\ntitle: JavaScript 数组方法对比\n---\nJavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。\n\n注意：区分以下两个方法的不同点：\n\n* array.splice() 影响原来的数组\n* array.slice() 不影响原来的数组\n\n##### I. 新增：影响原数组\n\n使用 array.push() 和 array.ushift() 新增元素会影响原来的数组。\n```\nlet mutatingAdd = ['a', 'b', 'c', 'd', 'e']; \nmutatingAdd.push('f'); // ['a', 'b', 'c', 'd', 'e', 'f']\nmutatingAdd.unshift('z'); // ['z', 'b', 'c', 'd', 'e' 'f']\n```\n##### II. 新增：不影响原数组\n\n两种方式新增元素不会影响原数组，第一种是 array.concat() 。\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e'];\nconst arr2 = arr1.concat('f'); // ['a', 'b', 'c', 'd', 'e', 'f']  （注：原文有误，我做了修改 “.” ---> “,”）\nconsole.log(arr1); // ['a', 'b', 'c', 'd', 'e']\n```\n第二种方法是使用 JavaScript 的展开（spread）操作符，展开操作符是三个点（…）\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e'];\nconst arr2 = [...arr1, 'f']; // ['a', 'b', 'c', 'd', 'e', 'f']  \nconst arr3 = ['z', ...arr1]; // ['z', 'a', 'b', 'c', 'd', 'e']\n```\n展开操作符会复制原来的数组，从原数组取出所有元素，然后存入新的环境。\n\n##### III. 移除：影响原数组\n\n使用 array.pop() 和 array.shift() 移除数组元素时，会影响原来的数组。\n```\nlet mutatingRemove = ['a', 'b', 'c', 'd', 'e'];  \nmutatingRemove.pop(); // ['a', 'b', 'c', 'd']  \nmutatingRemove.shift(); // ['b', 'c', 'd']\n```\narray.pop() 和 array.shift() 返回被移除的元素，你可以通过一个变量获取被移除的元素。\n```\nlet mutatingRemove = ['a', 'b', 'c', 'd', 'e'];\nconst returnedValue1 = mutatingRemove.pop();  \nconsole.log(mutatingRemove); // ['a', 'b', 'c', 'd']  \nconsole.log(returnedValue1); // 'e'\nconst returnedValue2 = mutatingRemove.shift();  \nconsole.log(mutatingRemove); // ['b', 'c', 'd']  \nconsole.log(returnedValue2); // 'a'\n```\narray.splice() 也可以删除数组的元素。\n```\nlet mutatingRemove = ['a', 'b', 'c', 'd', 'e'];  \nmutatingRemove.splice(0, 2); // ['c', 'd', 'e']\n```\n像 array.pop() 和 array.shift() 一样，array.splice() 同样返回移除的元素。\n```\nlet mutatingRemove = ['a', 'b', 'c', 'd', 'e'];  \nlet returnedItems = mutatingRemove.splice(0, 2);  \nconsole.log(mutatingRemove); // ['c', 'd', 'e']  \nconsole.log(returnedItems) // ['a', 'b']\n```\n##### IV. 移除：不影响原数组\nJavaScript 的 array.filter() 方法基于原数组创建一个新数组，新数组仅包含匹配特定条件的元素。\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e'];\nconst arr2 = arr1.filter(a => a !== 'e'); // ['a', 'b', 'c', 'd']（注：原文有误，我做了修改）  \n// 或者\nconst arr2 = arr1.filter(a => {  \n  return a !== 'e';\n}); // ['a', 'b', 'c', 'd']（注：原文有误，我做了修改）\n```\n以上代码的条件是“不等于 ‘e’ ”，因此新数组（arr2）里面没有包含 ‘e’。\n\n箭头函数的独特性：\n\n单行箭头函数，’return’ 关键字是默认自带的，不需要手动书写。\n\n可是，多行箭头函数就需要明确地返回一个值。\n\n另一种不影响原数组的方式是 array.slice()（不要与 array.splice() 混淆）。\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e'];  \nconst arr2 = arr1.slice(1, 5) // ['b', 'c', 'd', 'e']  \nconst arr3 = arr1.slice(2) // ['c', 'd', 'e']\n```\n##### V. 替换：影响原数组\n\n如果知道替换哪一个元素，可以使用 array.splice() 。\n\n```\nlet mutatingReplace = ['a', 'b', 'c', 'd', 'e'];  \nmutatingReplace.splice(2, 1, 30); // ['a', 'b', 30, 'd', 'e']  \n// 或者\nmutatingReplace.splice(2, 1, 30, 31); // ['a', 'b', 30, 31, 'd', 'e']\n```\n##### VI. 替换：不影响原数组\n\n可以使用 array.map() 创建一个新数组，并且可以检查每一个元素，根据特定的条件替换它们。\n```\nconst arr1 = ['a', 'b', 'c', 'd', 'e']  \nconst arr2 = arr1.map(item => {  \n  if(item === 'c') {\n    item = 'CAT';\n  }\n  return item;\n}); // ['a', 'b', 'CAT', 'd', 'e']\n```\n使用 array.map() 转换数据\n\narray.map() 是个强力方法，可以用于转换数据，而不污染原先的数据源。\n```\nconst origArr = ['a', 'b', 'c', 'd', 'e'];  \nconst transformedArr = origArr.map(n => n + 'Hi!'); // ['aHi!', 'bHi!', 'cHi!', 'dHi!', 'eHi!']  \nconsole.log(origArr); // ['a', 'b', 'c', 'd', 'e']; // 原数组毫发无损\n```","slug":"array","published":1,"date":"2017-07-21T08:15:11.690Z","updated":"2017-07-21T08:16:43.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000138tzyuyzkx92","content":"<p>JavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。</p>\n<p>注意：区分以下两个方法的不同点：</p>\n<ul>\n<li>array.splice() 影响原来的数组</li>\n<li>array.slice() 不影响原来的数组</li>\n</ul>\n<h5 id=\"I-新增：影响原数组\"><a href=\"#I-新增：影响原数组\" class=\"headerlink\" title=\"I. 新增：影响原数组\"></a>I. 新增：影响原数组</h5><p>使用 array.push() 和 array.ushift() 新增元素会影响原来的数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingAdd = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; </div><div class=\"line\">mutatingAdd.push(&apos;f&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]</div><div class=\"line\">mutatingAdd.unshift(&apos;z&apos;); // [&apos;z&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; &apos;f&apos;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"II-新增：不影响原数组\"><a href=\"#II-新增：不影响原数组\" class=\"headerlink\" title=\"II. 新增：不影响原数组\"></a>II. 新增：不影响原数组</h5><p>两种方式新增元素不会影响原数组，第一种是 array.concat() 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</div><div class=\"line\">const arr2 = arr1.concat(&apos;f&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]  （注：原文有误，我做了修改 “.” ---&gt; “,”）</div><div class=\"line\">console.log(arr1); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<p>第二种方法是使用 JavaScript 的展开（spread）操作符，展开操作符是三个点（…）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</div><div class=\"line\">const arr2 = [...arr1, &apos;f&apos;]; // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]  </div><div class=\"line\">const arr3 = [&apos;z&apos;, ...arr1]; // [&apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<p>展开操作符会复制原来的数组，从原数组取出所有元素，然后存入新的环境。</p>\n<h5 id=\"III-移除：影响原数组\"><a href=\"#III-移除：影响原数组\" class=\"headerlink\" title=\"III. 移除：影响原数组\"></a>III. 移除：影响原数组</h5><p>使用 array.pop() 和 array.shift() 移除数组元素时，会影响原来的数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">mutatingRemove.pop(); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  </div><div class=\"line\">mutatingRemove.shift(); // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</div></pre></td></tr></table></figure></p>\n<p>array.pop() 和 array.shift() 返回被移除的元素，你可以通过一个变量获取被移除的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</div><div class=\"line\">const returnedValue1 = mutatingRemove.pop();  </div><div class=\"line\">console.log(mutatingRemove); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  </div><div class=\"line\">console.log(returnedValue1); // &apos;e&apos;</div><div class=\"line\">const returnedValue2 = mutatingRemove.shift();  </div><div class=\"line\">console.log(mutatingRemove); // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  </div><div class=\"line\">console.log(returnedValue2); // &apos;a&apos;</div></pre></td></tr></table></figure></p>\n<p>array.splice() 也可以删除数组的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">mutatingRemove.splice(0, 2); // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<p>像 array.pop() 和 array.shift() 一样，array.splice() 同样返回移除的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">let returnedItems = mutatingRemove.splice(0, 2);  </div><div class=\"line\">console.log(mutatingRemove); // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]  </div><div class=\"line\">console.log(returnedItems) // [&apos;a&apos;, &apos;b&apos;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"IV-移除：不影响原数组\"><a href=\"#IV-移除：不影响原数组\" class=\"headerlink\" title=\"IV. 移除：不影响原数组\"></a>IV. 移除：不影响原数组</h5><p>JavaScript 的 array.filter() 方法基于原数组创建一个新数组，新数组仅包含匹配特定条件的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</div><div class=\"line\">const arr2 = arr1.filter(a =&gt; a !== &apos;e&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]（注：原文有误，我做了修改）  </div><div class=\"line\">// 或者</div><div class=\"line\">const arr2 = arr1.filter(a =&gt; &#123;  </div><div class=\"line\">  return a !== &apos;e&apos;;</div><div class=\"line\">&#125;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]（注：原文有误，我做了修改）</div></pre></td></tr></table></figure></p>\n<p>以上代码的条件是“不等于 ‘e’ ”，因此新数组（arr2）里面没有包含 ‘e’。</p>\n<p>箭头函数的独特性：</p>\n<p>单行箭头函数，’return’ 关键字是默认自带的，不需要手动书写。</p>\n<p>可是，多行箭头函数就需要明确地返回一个值。</p>\n<p>另一种不影响原数组的方式是 array.slice()（不要与 array.splice() 混淆）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">const arr2 = arr1.slice(1, 5) // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]  </div><div class=\"line\">const arr3 = arr1.slice(2) // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"V-替换：影响原数组\"><a href=\"#V-替换：影响原数组\" class=\"headerlink\" title=\"V. 替换：影响原数组\"></a>V. 替换：影响原数组</h5><p>如果知道替换哪一个元素，可以使用 array.splice() 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingReplace = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">mutatingReplace.splice(2, 1, 30); // [&apos;a&apos;, &apos;b&apos;, 30, &apos;d&apos;, &apos;e&apos;]  </div><div class=\"line\">// 或者</div><div class=\"line\">mutatingReplace.splice(2, 1, 30, 31); // [&apos;a&apos;, &apos;b&apos;, 30, 31, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure>\n<h5 id=\"VI-替换：不影响原数组\"><a href=\"#VI-替换：不影响原数组\" class=\"headerlink\" title=\"VI. 替换：不影响原数组\"></a>VI. 替换：不影响原数组</h5><p>可以使用 array.map() 创建一个新数组，并且可以检查每一个元素，根据特定的条件替换它们。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]  </div><div class=\"line\">const arr2 = arr1.map(item =&gt; &#123;  </div><div class=\"line\">  if(item === &apos;c&apos;) &#123;</div><div class=\"line\">    item = &apos;CAT&apos;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return item;</div><div class=\"line\">&#125;); // [&apos;a&apos;, &apos;b&apos;, &apos;CAT&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<p>使用 array.map() 转换数据</p>\n<p>array.map() 是个强力方法，可以用于转换数据，而不污染原先的数据源。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const origArr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">const transformedArr = origArr.map(n =&gt; n + &apos;Hi!&apos;); // [&apos;aHi!&apos;, &apos;bHi!&apos;, &apos;cHi!&apos;, &apos;dHi!&apos;, &apos;eHi!&apos;]  </div><div class=\"line\">console.log(origArr); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; // 原数组毫发无损</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。</p>\n<p>注意：区分以下两个方法的不同点：</p>\n<ul>\n<li>array.splice() 影响原来的数组</li>\n<li>array.slice() 不影响原来的数组</li>\n</ul>\n<h5 id=\"I-新增：影响原数组\"><a href=\"#I-新增：影响原数组\" class=\"headerlink\" title=\"I. 新增：影响原数组\"></a>I. 新增：影响原数组</h5><p>使用 array.push() 和 array.ushift() 新增元素会影响原来的数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingAdd = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; </div><div class=\"line\">mutatingAdd.push(&apos;f&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]</div><div class=\"line\">mutatingAdd.unshift(&apos;z&apos;); // [&apos;z&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; &apos;f&apos;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"II-新增：不影响原数组\"><a href=\"#II-新增：不影响原数组\" class=\"headerlink\" title=\"II. 新增：不影响原数组\"></a>II. 新增：不影响原数组</h5><p>两种方式新增元素不会影响原数组，第一种是 array.concat() 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</div><div class=\"line\">const arr2 = arr1.concat(&apos;f&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]  （注：原文有误，我做了修改 “.” ---&gt; “,”）</div><div class=\"line\">console.log(arr1); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<p>第二种方法是使用 JavaScript 的展开（spread）操作符，展开操作符是三个点（…）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</div><div class=\"line\">const arr2 = [...arr1, &apos;f&apos;]; // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]  </div><div class=\"line\">const arr3 = [&apos;z&apos;, ...arr1]; // [&apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<p>展开操作符会复制原来的数组，从原数组取出所有元素，然后存入新的环境。</p>\n<h5 id=\"III-移除：影响原数组\"><a href=\"#III-移除：影响原数组\" class=\"headerlink\" title=\"III. 移除：影响原数组\"></a>III. 移除：影响原数组</h5><p>使用 array.pop() 和 array.shift() 移除数组元素时，会影响原来的数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">mutatingRemove.pop(); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  </div><div class=\"line\">mutatingRemove.shift(); // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</div></pre></td></tr></table></figure></p>\n<p>array.pop() 和 array.shift() 返回被移除的元素，你可以通过一个变量获取被移除的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</div><div class=\"line\">const returnedValue1 = mutatingRemove.pop();  </div><div class=\"line\">console.log(mutatingRemove); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  </div><div class=\"line\">console.log(returnedValue1); // &apos;e&apos;</div><div class=\"line\">const returnedValue2 = mutatingRemove.shift();  </div><div class=\"line\">console.log(mutatingRemove); // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  </div><div class=\"line\">console.log(returnedValue2); // &apos;a&apos;</div></pre></td></tr></table></figure></p>\n<p>array.splice() 也可以删除数组的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">mutatingRemove.splice(0, 2); // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<p>像 array.pop() 和 array.shift() 一样，array.splice() 同样返回移除的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">let returnedItems = mutatingRemove.splice(0, 2);  </div><div class=\"line\">console.log(mutatingRemove); // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]  </div><div class=\"line\">console.log(returnedItems) // [&apos;a&apos;, &apos;b&apos;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"IV-移除：不影响原数组\"><a href=\"#IV-移除：不影响原数组\" class=\"headerlink\" title=\"IV. 移除：不影响原数组\"></a>IV. 移除：不影响原数组</h5><p>JavaScript 的 array.filter() 方法基于原数组创建一个新数组，新数组仅包含匹配特定条件的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</div><div class=\"line\">const arr2 = arr1.filter(a =&gt; a !== &apos;e&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]（注：原文有误，我做了修改）  </div><div class=\"line\">// 或者</div><div class=\"line\">const arr2 = arr1.filter(a =&gt; &#123;  </div><div class=\"line\">  return a !== &apos;e&apos;;</div><div class=\"line\">&#125;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]（注：原文有误，我做了修改）</div></pre></td></tr></table></figure></p>\n<p>以上代码的条件是“不等于 ‘e’ ”，因此新数组（arr2）里面没有包含 ‘e’。</p>\n<p>箭头函数的独特性：</p>\n<p>单行箭头函数，’return’ 关键字是默认自带的，不需要手动书写。</p>\n<p>可是，多行箭头函数就需要明确地返回一个值。</p>\n<p>另一种不影响原数组的方式是 array.slice()（不要与 array.splice() 混淆）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">const arr2 = arr1.slice(1, 5) // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]  </div><div class=\"line\">const arr3 = arr1.slice(2) // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"V-替换：影响原数组\"><a href=\"#V-替换：影响原数组\" class=\"headerlink\" title=\"V. 替换：影响原数组\"></a>V. 替换：影响原数组</h5><p>如果知道替换哪一个元素，可以使用 array.splice() 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let mutatingReplace = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">mutatingReplace.splice(2, 1, 30); // [&apos;a&apos;, &apos;b&apos;, 30, &apos;d&apos;, &apos;e&apos;]  </div><div class=\"line\">// 或者</div><div class=\"line\">mutatingReplace.splice(2, 1, 30, 31); // [&apos;a&apos;, &apos;b&apos;, 30, 31, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure>\n<h5 id=\"VI-替换：不影响原数组\"><a href=\"#VI-替换：不影响原数组\" class=\"headerlink\" title=\"VI. 替换：不影响原数组\"></a>VI. 替换：不影响原数组</h5><p>可以使用 array.map() 创建一个新数组，并且可以检查每一个元素，根据特定的条件替换它们。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]  </div><div class=\"line\">const arr2 = arr1.map(item =&gt; &#123;  </div><div class=\"line\">  if(item === &apos;c&apos;) &#123;</div><div class=\"line\">    item = &apos;CAT&apos;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return item;</div><div class=\"line\">&#125;); // [&apos;a&apos;, &apos;b&apos;, &apos;CAT&apos;, &apos;d&apos;, &apos;e&apos;]</div></pre></td></tr></table></figure></p>\n<p>使用 array.map() 转换数据</p>\n<p>array.map() 是个强力方法，可以用于转换数据，而不污染原先的数据源。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const origArr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </div><div class=\"line\">const transformedArr = origArr.map(n =&gt; n + &apos;Hi!&apos;); // [&apos;aHi!&apos;, &apos;bHi!&apos;, &apos;cHi!&apos;, &apos;dHi!&apos;, &apos;eHi!&apos;]  </div><div class=\"line\">console.log(origArr); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; // 原数组毫发无损</div></pre></td></tr></table></figure></p>\n"},{"title":"DNS预获取dns-prefetch提升页面载入速度","_content":"DNS Prefetch，即DNS预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 一个是减少DNS的请求次数，另一个就是进行DNS预获取 。\n\nDNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。\n\n默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS Prefetch 了。\n\n目前大多数浏览器已经支持此属性，支持版本如下：\n```\n– Safari: 5+\n– Chrome: All\n– Firefox: 3.5+\n– Opera: Unknown\n– IE: 9+ (called “Pre-resolution” on blogs.msdn.com)\n```\n\n其中 Chrome 和 Firefox 3.5+ 内置了 DNS Prefetching 技术并对DNS预解析做了相应优化设置。所以 即使不设置此属性，Chrome 和 Firefox 3.5+ 也能自动在后台进行预解析 。\nDNS Prefetch 应该尽量的放在网页的前面，推荐放在 `<meta charset=\"UTF-8\">` 后面。具体使用方法如下：\n```\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n<link rel=\"dns-prefetch\" href=\"//www.itechzero.com\">\n<link rel=\"dns-prefetch\" href=\"//api.share.baidu.com\">\n<link rel=\"dns-prefetch\" href=\"//bdimg.share.baidu.com\">\n```\n需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 [禁用DNS 预读取能节省每月100亿的DNS查询](https://www.pinkbike.com/news/DNS-Prefetching-implications.html) 。\n\n如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：\n\n`<meta http-equiv=\"x-dns-prefetch-control\" content=\"off\">`","source":"_posts/dns-prefetch.md","raw":"---\ntitle: DNS预获取dns-prefetch提升页面载入速度\n---\nDNS Prefetch，即DNS预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 一个是减少DNS的请求次数，另一个就是进行DNS预获取 。\n\nDNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。\n\n默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS Prefetch 了。\n\n目前大多数浏览器已经支持此属性，支持版本如下：\n```\n– Safari: 5+\n– Chrome: All\n– Firefox: 3.5+\n– Opera: Unknown\n– IE: 9+ (called “Pre-resolution” on blogs.msdn.com)\n```\n\n其中 Chrome 和 Firefox 3.5+ 内置了 DNS Prefetching 技术并对DNS预解析做了相应优化设置。所以 即使不设置此属性，Chrome 和 Firefox 3.5+ 也能自动在后台进行预解析 。\nDNS Prefetch 应该尽量的放在网页的前面，推荐放在 `<meta charset=\"UTF-8\">` 后面。具体使用方法如下：\n```\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n<link rel=\"dns-prefetch\" href=\"//www.itechzero.com\">\n<link rel=\"dns-prefetch\" href=\"//api.share.baidu.com\">\n<link rel=\"dns-prefetch\" href=\"//bdimg.share.baidu.com\">\n```\n需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 [禁用DNS 预读取能节省每月100亿的DNS查询](https://www.pinkbike.com/news/DNS-Prefetching-implications.html) 。\n\n如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：\n\n`<meta http-equiv=\"x-dns-prefetch-control\" content=\"off\">`","slug":"dns-prefetch","published":1,"date":"2017-07-21T08:01:16.633Z","updated":"2017-08-02T01:14:44.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000238tzqgq4a8rp","content":"<p>DNS Prefetch，即DNS预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 一个是减少DNS的请求次数，另一个就是进行DNS预获取 。</p>\n<p>DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。</p>\n<p>默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS Prefetch 了。</p>\n<p>目前大多数浏览器已经支持此属性，支持版本如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">– Safari: 5+</div><div class=\"line\">– Chrome: All</div><div class=\"line\">– Firefox: 3.5+</div><div class=\"line\">– Opera: Unknown</div><div class=\"line\">– IE: 9+ (called “Pre-resolution” on blogs.msdn.com)</div></pre></td></tr></table></figure></p>\n<p>其中 Chrome 和 Firefox 3.5+ 内置了 DNS Prefetching 技术并对DNS预解析做了相应优化设置。所以 即使不设置此属性，Chrome 和 Firefox 3.5+ 也能自动在后台进行预解析 。<br>DNS Prefetch 应该尽量的放在网页的前面，推荐放在 <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code> 后面。具体使用方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</div><div class=\"line\">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.itechzero.com&quot;&gt;</div><div class=\"line\">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.share.baidu.com&quot;&gt;</div><div class=\"line\">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//bdimg.share.baidu.com&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 <a href=\"https://www.pinkbike.com/news/DNS-Prefetching-implications.html\" target=\"_blank\" rel=\"external\">禁用DNS 预读取能节省每月100亿的DNS查询</a> 。</p>\n<p>如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：</p>\n<p><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>DNS Prefetch，即DNS预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 一个是减少DNS的请求次数，另一个就是进行DNS预获取 。</p>\n<p>DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。</p>\n<p>默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS Prefetch 了。</p>\n<p>目前大多数浏览器已经支持此属性，支持版本如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">– Safari: 5+</div><div class=\"line\">– Chrome: All</div><div class=\"line\">– Firefox: 3.5+</div><div class=\"line\">– Opera: Unknown</div><div class=\"line\">– IE: 9+ (called “Pre-resolution” on blogs.msdn.com)</div></pre></td></tr></table></figure></p>\n<p>其中 Chrome 和 Firefox 3.5+ 内置了 DNS Prefetching 技术并对DNS预解析做了相应优化设置。所以 即使不设置此属性，Chrome 和 Firefox 3.5+ 也能自动在后台进行预解析 。<br>DNS Prefetch 应该尽量的放在网页的前面，推荐放在 <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code> 后面。具体使用方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</div><div class=\"line\">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.itechzero.com&quot;&gt;</div><div class=\"line\">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.share.baidu.com&quot;&gt;</div><div class=\"line\">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//bdimg.share.baidu.com&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 <a href=\"https://www.pinkbike.com/news/DNS-Prefetching-implications.html\" target=\"_blank\" rel=\"external\">禁用DNS 预读取能节省每月100亿的DNS查询</a> 。</p>\n<p>如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：</p>\n<p><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;</code></p>\n"},{"title":"10条影响CSS渲染速度的写法与建议","_content":"###### 1、*{} #zishu *{} 尽量避开\n\n   由于不同浏览器对HTML标签的解释有差异，所以最终的网页效果在不同的浏览器中可能是不一样的，为了消除这方面的风险，设计者通常会在CSS的一个始就把所有标签的默认属性全部去除，以达到所有签标属性值都统一的效果。所以就有了*通配符。*会遍历所有的标签；\n\n*{margin:0; padding:0}\n   建议的的解决办法：\n\n   不要去使用生僻的标签，因为这些标签往往在不同浏览器中解释出来的效果不一样；所以你要尽可能的去使用那些常用的标签；\n\n   不要使用*；而是把你常用到的这些标签进行处理；例如：body,li,p,h1{margin:0; padding:0}\n\n###### 2、滤镜的一些东西不要去用\n\n   IE的一些滤镜在FIREFOX中不支持，往往写一些效果时你还是使用CSS HACK；而滤镜是一个非常毫资源的东西；特别是一些羽化、阴影和一个前透明的效果；\n\n   建议的解决办法：\n\n   能不使用就不要使用，一方面兼容问题；很多效果只能在IE中使用；\n\n   就本例而言，如果非要这样在的效果，建议用图片作背景；(只说优化速度，实际应用还是可以小部分用，有人可能会说，用图片还多一个HTTP请求呢，呵呵……)\n\n   一个非常好的例子，就是在今年512大地震时，很多网站一夜之间全部变成了灰色，他们只用了一行CSS代码：\n\nbody{filter: gray;}\n   但，你会看会看到这些网页非常的慢，打开后你的CPU也会飙升，不夸张的说，如果你的电脑配置差，干死你也不为过。\n\n###### 3、一个页面上少用绝对定位\n\n   绝对定位(position:absolute )是网页布局中很常用到的，特别是作一些浮动效果时，也会让页面看起来非常的酷。但网页中如果使用过多的绝对定位，会让你的网页变得非常的慢，这一点上边FIREFOX表现要比IE还要差。\n\n   建议的解决办法：\n\n   尽可能少用，这个少用的值是多少，也没有一个非常好的值来说明；还要看绝定定位这个标签里边的内容的多少；在这里我只能说，这样写会有性能问题，少用。\n\n   如果能用变通实现同样的效果，就用变通的办法。\n\n###### 4、background 背景图片的平铺\n\n   有些网页的背景或页面中某块的背景通常要用到图片的平铺，平铺后就会有平铺次数的问题，如果是单次还好，如果是多次，就废了。\n\n   建议的作法：\n\n   色彩少的图片要作成gif图片；\n\n   平铺的图片尽可能大一些，如果是色彩少的GIF图片，图片大一些，实际大小也不会大多少；上边的两个例子就很好的证明，第一个图片非常少，第二个图大较大一些；但速度是非常不一样的；\n\n###### 5、让属性尽可能多的去继承\n\n   尽可能让一些属性子可以继承父，而不是覆盖父；\n\n###### 6、CSS的路径别太深；\n\n`#zishu #info #tool #sidebar h2{ font-size:12px;}`\n\n###### 7、能简写的一些就简写；\n\n   这个对渲染速度没有影响；只是少几个字符；\n\n###### 8、别放空的的class或没有的class在HTML代码中；\n\n###### 9、float 的应用\n\n   这个东西我的感觉是如果使用不当，百分百有性能问题，而且还非常的大，但实在不知道怎么样能弄一个例子出来；这里只能建议大家如果不是很明白float是怎么工作的，还是少使用为妙。\n\n   曾经因为这个把IE干死过，我写过一个例子，虽说和这个没有什么太大的关系：IE之死__原来与CSS有关\n\n###### 10、合理的布局\n\n   为什么这么说呢，合理的布局，可以改变CSS的写法以及渲染过程。","source":"_posts/faster-css.md","raw":"---\ntitle: 10条影响CSS渲染速度的写法与建议\n---\n###### 1、*{} #zishu *{} 尽量避开\n\n   由于不同浏览器对HTML标签的解释有差异，所以最终的网页效果在不同的浏览器中可能是不一样的，为了消除这方面的风险，设计者通常会在CSS的一个始就把所有标签的默认属性全部去除，以达到所有签标属性值都统一的效果。所以就有了*通配符。*会遍历所有的标签；\n\n*{margin:0; padding:0}\n   建议的的解决办法：\n\n   不要去使用生僻的标签，因为这些标签往往在不同浏览器中解释出来的效果不一样；所以你要尽可能的去使用那些常用的标签；\n\n   不要使用*；而是把你常用到的这些标签进行处理；例如：body,li,p,h1{margin:0; padding:0}\n\n###### 2、滤镜的一些东西不要去用\n\n   IE的一些滤镜在FIREFOX中不支持，往往写一些效果时你还是使用CSS HACK；而滤镜是一个非常毫资源的东西；特别是一些羽化、阴影和一个前透明的效果；\n\n   建议的解决办法：\n\n   能不使用就不要使用，一方面兼容问题；很多效果只能在IE中使用；\n\n   就本例而言，如果非要这样在的效果，建议用图片作背景；(只说优化速度，实际应用还是可以小部分用，有人可能会说，用图片还多一个HTTP请求呢，呵呵……)\n\n   一个非常好的例子，就是在今年512大地震时，很多网站一夜之间全部变成了灰色，他们只用了一行CSS代码：\n\nbody{filter: gray;}\n   但，你会看会看到这些网页非常的慢，打开后你的CPU也会飙升，不夸张的说，如果你的电脑配置差，干死你也不为过。\n\n###### 3、一个页面上少用绝对定位\n\n   绝对定位(position:absolute )是网页布局中很常用到的，特别是作一些浮动效果时，也会让页面看起来非常的酷。但网页中如果使用过多的绝对定位，会让你的网页变得非常的慢，这一点上边FIREFOX表现要比IE还要差。\n\n   建议的解决办法：\n\n   尽可能少用，这个少用的值是多少，也没有一个非常好的值来说明；还要看绝定定位这个标签里边的内容的多少；在这里我只能说，这样写会有性能问题，少用。\n\n   如果能用变通实现同样的效果，就用变通的办法。\n\n###### 4、background 背景图片的平铺\n\n   有些网页的背景或页面中某块的背景通常要用到图片的平铺，平铺后就会有平铺次数的问题，如果是单次还好，如果是多次，就废了。\n\n   建议的作法：\n\n   色彩少的图片要作成gif图片；\n\n   平铺的图片尽可能大一些，如果是色彩少的GIF图片，图片大一些，实际大小也不会大多少；上边的两个例子就很好的证明，第一个图片非常少，第二个图大较大一些；但速度是非常不一样的；\n\n###### 5、让属性尽可能多的去继承\n\n   尽可能让一些属性子可以继承父，而不是覆盖父；\n\n###### 6、CSS的路径别太深；\n\n`#zishu #info #tool #sidebar h2{ font-size:12px;}`\n\n###### 7、能简写的一些就简写；\n\n   这个对渲染速度没有影响；只是少几个字符；\n\n###### 8、别放空的的class或没有的class在HTML代码中；\n\n###### 9、float 的应用\n\n   这个东西我的感觉是如果使用不当，百分百有性能问题，而且还非常的大，但实在不知道怎么样能弄一个例子出来；这里只能建议大家如果不是很明白float是怎么工作的，还是少使用为妙。\n\n   曾经因为这个把IE干死过，我写过一个例子，虽说和这个没有什么太大的关系：IE之死__原来与CSS有关\n\n###### 10、合理的布局\n\n   为什么这么说呢，合理的布局，可以改变CSS的写法以及渲染过程。","slug":"faster-css","published":1,"date":"2017-07-21T08:17:35.446Z","updated":"2017-07-21T08:19:30.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000338tzmc6rr8jd","content":"<h6 id=\"1、-zishu-尽量避开\"><a href=\"#1、-zishu-尽量避开\" class=\"headerlink\" title=\"1、{} #zishu {} 尽量避开\"></a>1、<em>{} #zishu </em>{} 尽量避开</h6><p>   由于不同浏览器对HTML标签的解释有差异，所以最终的网页效果在不同的浏览器中可能是不一样的，为了消除这方面的风险，设计者通常会在CSS的一个始就把所有标签的默认属性全部去除，以达到所有签标属性值都统一的效果。所以就有了<em>通配符。</em>会遍历所有的标签；</p>\n<p>*{margin:0; padding:0}<br>   建议的的解决办法：</p>\n<p>   不要去使用生僻的标签，因为这些标签往往在不同浏览器中解释出来的效果不一样；所以你要尽可能的去使用那些常用的标签；</p>\n<p>   不要使用*；而是把你常用到的这些标签进行处理；例如：body,li,p,h1{margin:0; padding:0}</p>\n<h6 id=\"2、滤镜的一些东西不要去用\"><a href=\"#2、滤镜的一些东西不要去用\" class=\"headerlink\" title=\"2、滤镜的一些东西不要去用\"></a>2、滤镜的一些东西不要去用</h6><p>   IE的一些滤镜在FIREFOX中不支持，往往写一些效果时你还是使用CSS HACK；而滤镜是一个非常毫资源的东西；特别是一些羽化、阴影和一个前透明的效果；</p>\n<p>   建议的解决办法：</p>\n<p>   能不使用就不要使用，一方面兼容问题；很多效果只能在IE中使用；</p>\n<p>   就本例而言，如果非要这样在的效果，建议用图片作背景；(只说优化速度，实际应用还是可以小部分用，有人可能会说，用图片还多一个HTTP请求呢，呵呵……)</p>\n<p>   一个非常好的例子，就是在今年512大地震时，很多网站一夜之间全部变成了灰色，他们只用了一行CSS代码：</p>\n<p>body{filter: gray;}<br>   但，你会看会看到这些网页非常的慢，打开后你的CPU也会飙升，不夸张的说，如果你的电脑配置差，干死你也不为过。</p>\n<h6 id=\"3、一个页面上少用绝对定位\"><a href=\"#3、一个页面上少用绝对定位\" class=\"headerlink\" title=\"3、一个页面上少用绝对定位\"></a>3、一个页面上少用绝对定位</h6><p>   绝对定位(position:absolute )是网页布局中很常用到的，特别是作一些浮动效果时，也会让页面看起来非常的酷。但网页中如果使用过多的绝对定位，会让你的网页变得非常的慢，这一点上边FIREFOX表现要比IE还要差。</p>\n<p>   建议的解决办法：</p>\n<p>   尽可能少用，这个少用的值是多少，也没有一个非常好的值来说明；还要看绝定定位这个标签里边的内容的多少；在这里我只能说，这样写会有性能问题，少用。</p>\n<p>   如果能用变通实现同样的效果，就用变通的办法。</p>\n<h6 id=\"4、background-背景图片的平铺\"><a href=\"#4、background-背景图片的平铺\" class=\"headerlink\" title=\"4、background 背景图片的平铺\"></a>4、background 背景图片的平铺</h6><p>   有些网页的背景或页面中某块的背景通常要用到图片的平铺，平铺后就会有平铺次数的问题，如果是单次还好，如果是多次，就废了。</p>\n<p>   建议的作法：</p>\n<p>   色彩少的图片要作成gif图片；</p>\n<p>   平铺的图片尽可能大一些，如果是色彩少的GIF图片，图片大一些，实际大小也不会大多少；上边的两个例子就很好的证明，第一个图片非常少，第二个图大较大一些；但速度是非常不一样的；</p>\n<h6 id=\"5、让属性尽可能多的去继承\"><a href=\"#5、让属性尽可能多的去继承\" class=\"headerlink\" title=\"5、让属性尽可能多的去继承\"></a>5、让属性尽可能多的去继承</h6><p>   尽可能让一些属性子可以继承父，而不是覆盖父；</p>\n<h6 id=\"6、CSS的路径别太深；\"><a href=\"#6、CSS的路径别太深；\" class=\"headerlink\" title=\"6、CSS的路径别太深；\"></a>6、CSS的路径别太深；</h6><p><code>#zishu #info #tool #sidebar h2{ font-size:12px;}</code></p>\n<h6 id=\"7、能简写的一些就简写；\"><a href=\"#7、能简写的一些就简写；\" class=\"headerlink\" title=\"7、能简写的一些就简写；\"></a>7、能简写的一些就简写；</h6><p>   这个对渲染速度没有影响；只是少几个字符；</p>\n<h6 id=\"8、别放空的的class或没有的class在HTML代码中；\"><a href=\"#8、别放空的的class或没有的class在HTML代码中；\" class=\"headerlink\" title=\"8、别放空的的class或没有的class在HTML代码中；\"></a>8、别放空的的class或没有的class在HTML代码中；</h6><h6 id=\"9、float-的应用\"><a href=\"#9、float-的应用\" class=\"headerlink\" title=\"9、float 的应用\"></a>9、float 的应用</h6><p>   这个东西我的感觉是如果使用不当，百分百有性能问题，而且还非常的大，但实在不知道怎么样能弄一个例子出来；这里只能建议大家如果不是很明白float是怎么工作的，还是少使用为妙。</p>\n<p>   曾经因为这个把IE干死过，我写过一个例子，虽说和这个没有什么太大的关系：IE之死__原来与CSS有关</p>\n<h6 id=\"10、合理的布局\"><a href=\"#10、合理的布局\" class=\"headerlink\" title=\"10、合理的布局\"></a>10、合理的布局</h6><p>   为什么这么说呢，合理的布局，可以改变CSS的写法以及渲染过程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"1、-zishu-尽量避开\"><a href=\"#1、-zishu-尽量避开\" class=\"headerlink\" title=\"1、{} #zishu {} 尽量避开\"></a>1、<em>{} #zishu </em>{} 尽量避开</h6><p>   由于不同浏览器对HTML标签的解释有差异，所以最终的网页效果在不同的浏览器中可能是不一样的，为了消除这方面的风险，设计者通常会在CSS的一个始就把所有标签的默认属性全部去除，以达到所有签标属性值都统一的效果。所以就有了<em>通配符。</em>会遍历所有的标签；</p>\n<p>*{margin:0; padding:0}<br>   建议的的解决办法：</p>\n<p>   不要去使用生僻的标签，因为这些标签往往在不同浏览器中解释出来的效果不一样；所以你要尽可能的去使用那些常用的标签；</p>\n<p>   不要使用*；而是把你常用到的这些标签进行处理；例如：body,li,p,h1{margin:0; padding:0}</p>\n<h6 id=\"2、滤镜的一些东西不要去用\"><a href=\"#2、滤镜的一些东西不要去用\" class=\"headerlink\" title=\"2、滤镜的一些东西不要去用\"></a>2、滤镜的一些东西不要去用</h6><p>   IE的一些滤镜在FIREFOX中不支持，往往写一些效果时你还是使用CSS HACK；而滤镜是一个非常毫资源的东西；特别是一些羽化、阴影和一个前透明的效果；</p>\n<p>   建议的解决办法：</p>\n<p>   能不使用就不要使用，一方面兼容问题；很多效果只能在IE中使用；</p>\n<p>   就本例而言，如果非要这样在的效果，建议用图片作背景；(只说优化速度，实际应用还是可以小部分用，有人可能会说，用图片还多一个HTTP请求呢，呵呵……)</p>\n<p>   一个非常好的例子，就是在今年512大地震时，很多网站一夜之间全部变成了灰色，他们只用了一行CSS代码：</p>\n<p>body{filter: gray;}<br>   但，你会看会看到这些网页非常的慢，打开后你的CPU也会飙升，不夸张的说，如果你的电脑配置差，干死你也不为过。</p>\n<h6 id=\"3、一个页面上少用绝对定位\"><a href=\"#3、一个页面上少用绝对定位\" class=\"headerlink\" title=\"3、一个页面上少用绝对定位\"></a>3、一个页面上少用绝对定位</h6><p>   绝对定位(position:absolute )是网页布局中很常用到的，特别是作一些浮动效果时，也会让页面看起来非常的酷。但网页中如果使用过多的绝对定位，会让你的网页变得非常的慢，这一点上边FIREFOX表现要比IE还要差。</p>\n<p>   建议的解决办法：</p>\n<p>   尽可能少用，这个少用的值是多少，也没有一个非常好的值来说明；还要看绝定定位这个标签里边的内容的多少；在这里我只能说，这样写会有性能问题，少用。</p>\n<p>   如果能用变通实现同样的效果，就用变通的办法。</p>\n<h6 id=\"4、background-背景图片的平铺\"><a href=\"#4、background-背景图片的平铺\" class=\"headerlink\" title=\"4、background 背景图片的平铺\"></a>4、background 背景图片的平铺</h6><p>   有些网页的背景或页面中某块的背景通常要用到图片的平铺，平铺后就会有平铺次数的问题，如果是单次还好，如果是多次，就废了。</p>\n<p>   建议的作法：</p>\n<p>   色彩少的图片要作成gif图片；</p>\n<p>   平铺的图片尽可能大一些，如果是色彩少的GIF图片，图片大一些，实际大小也不会大多少；上边的两个例子就很好的证明，第一个图片非常少，第二个图大较大一些；但速度是非常不一样的；</p>\n<h6 id=\"5、让属性尽可能多的去继承\"><a href=\"#5、让属性尽可能多的去继承\" class=\"headerlink\" title=\"5、让属性尽可能多的去继承\"></a>5、让属性尽可能多的去继承</h6><p>   尽可能让一些属性子可以继承父，而不是覆盖父；</p>\n<h6 id=\"6、CSS的路径别太深；\"><a href=\"#6、CSS的路径别太深；\" class=\"headerlink\" title=\"6、CSS的路径别太深；\"></a>6、CSS的路径别太深；</h6><p><code>#zishu #info #tool #sidebar h2{ font-size:12px;}</code></p>\n<h6 id=\"7、能简写的一些就简写；\"><a href=\"#7、能简写的一些就简写；\" class=\"headerlink\" title=\"7、能简写的一些就简写；\"></a>7、能简写的一些就简写；</h6><p>   这个对渲染速度没有影响；只是少几个字符；</p>\n<h6 id=\"8、别放空的的class或没有的class在HTML代码中；\"><a href=\"#8、别放空的的class或没有的class在HTML代码中；\" class=\"headerlink\" title=\"8、别放空的的class或没有的class在HTML代码中；\"></a>8、别放空的的class或没有的class在HTML代码中；</h6><h6 id=\"9、float-的应用\"><a href=\"#9、float-的应用\" class=\"headerlink\" title=\"9、float 的应用\"></a>9、float 的应用</h6><p>   这个东西我的感觉是如果使用不当，百分百有性能问题，而且还非常的大，但实在不知道怎么样能弄一个例子出来；这里只能建议大家如果不是很明白float是怎么工作的，还是少使用为妙。</p>\n<p>   曾经因为这个把IE干死过，我写过一个例子，虽说和这个没有什么太大的关系：IE之死__原来与CSS有关</p>\n<h6 id=\"10、合理的布局\"><a href=\"#10、合理的布局\" class=\"headerlink\" title=\"10、合理的布局\"></a>10、合理的布局</h6><p>   为什么这么说呢，合理的布局，可以改变CSS的写法以及渲染过程。</p>\n"},{"title":"新的博客","_content":"今天起正式使用新的博客系统！\n","source":"_posts/hello-world.md","raw":"---\ntitle: 新的博客\n---\n今天起正式使用新的博客系统！\n","slug":"hello-world","published":1,"date":"2017-07-20T01:10:40.803Z","updated":"2017-07-21T07:35:31.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000438tzw6zukiip","content":"<p>今天起正式使用新的博客系统！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天起正式使用新的博客系统！</p>\n"},{"title":"Meteor","_content":"1.启动方式 `meteor -p 80`\n\n2.使用nohup后台运行meteor\n* nohup meteor -p 80 &\n* jobs\n* exit\n\n3.meteor数据库启动失败试试\n`rm -rf .meteor/local/db/mongod.lock .meteor/local/db/journal/`\n\n4.docker下MongoDB无法启动\n[帮助信息](https://github.com/meteor/meteor/issues/4019)\n\n`apt-get install language-pack-en -y`\n\n5.docker下出现`You are attempting to run Meteor as the 'root' superuser`\n```\nexport METEOR_NO_RELEASE_CHECK=true\ncurl https://install.meteor.com/?release=1.4.1.3 | sh\n```","source":"_posts/meteor.md","raw":"---\ntitle: Meteor\n---\n1.启动方式 `meteor -p 80`\n\n2.使用nohup后台运行meteor\n* nohup meteor -p 80 &\n* jobs\n* exit\n\n3.meteor数据库启动失败试试\n`rm -rf .meteor/local/db/mongod.lock .meteor/local/db/journal/`\n\n4.docker下MongoDB无法启动\n[帮助信息](https://github.com/meteor/meteor/issues/4019)\n\n`apt-get install language-pack-en -y`\n\n5.docker下出现`You are attempting to run Meteor as the 'root' superuser`\n```\nexport METEOR_NO_RELEASE_CHECK=true\ncurl https://install.meteor.com/?release=1.4.1.3 | sh\n```","slug":"meteor","published":1,"date":"2017-07-21T08:20:08.513Z","updated":"2017-07-21T08:20:53.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000538tzj68cd49j","content":"<p>1.启动方式 <code>meteor -p 80</code></p>\n<p>2.使用nohup后台运行meteor</p>\n<ul>\n<li>nohup meteor -p 80 &amp;</li>\n<li>jobs</li>\n<li>exit</li>\n</ul>\n<p>3.meteor数据库启动失败试试<br><code>rm -rf .meteor/local/db/mongod.lock .meteor/local/db/journal/</code></p>\n<p>4.docker下MongoDB无法启动<br><a href=\"https://github.com/meteor/meteor/issues/4019\" target=\"_blank\" rel=\"external\">帮助信息</a></p>\n<p><code>apt-get install language-pack-en -y</code></p>\n<p>5.docker下出现<code>You are attempting to run Meteor as the &#39;root&#39; superuser</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export METEOR_NO_RELEASE_CHECK=true</div><div class=\"line\">curl https://install.meteor.com/?release=1.4.1.3 | sh</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.启动方式 <code>meteor -p 80</code></p>\n<p>2.使用nohup后台运行meteor</p>\n<ul>\n<li>nohup meteor -p 80 &amp;</li>\n<li>jobs</li>\n<li>exit</li>\n</ul>\n<p>3.meteor数据库启动失败试试<br><code>rm -rf .meteor/local/db/mongod.lock .meteor/local/db/journal/</code></p>\n<p>4.docker下MongoDB无法启动<br><a href=\"https://github.com/meteor/meteor/issues/4019\" target=\"_blank\" rel=\"external\">帮助信息</a></p>\n<p><code>apt-get install language-pack-en -y</code></p>\n<p>5.docker下出现<code>You are attempting to run Meteor as the &#39;root&#39; superuser</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export METEOR_NO_RELEASE_CHECK=true</div><div class=\"line\">curl https://install.meteor.com/?release=1.4.1.3 | sh</div></pre></td></tr></table></figure></p>\n"},{"title":"判断iOS或Android手机","_content":"通过判断浏览器的userAgent，用正则来判断手机是否是ios和android客户端。<span>代码</span>如下：\n<pre>&lt;script type=\"text/javascript\"&gt;\nvar u = navigator.userAgent;\nvar isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1; //android终端\nvar isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端\nalert('是否是Android：'+isAndroid);\nalert('是否是iOS：'+isiOS);\n&lt;/script&gt;</pre>\n下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端、ipad、iphone、微信、QQ等。\n<pre>&lt;script type=\"text/javascript\"&gt;\n//判断访问终端\nvar browser={\n    versions:function(){\n        var u = navigator.userAgent, app = navigator.appVersion;\n        return {\n            trident: u.indexOf('Trident') &gt; -1, //IE内核\n            presto: u.indexOf('Presto') &gt; -1, //opera内核\n            webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核\n            gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1,//火狐内核\n            mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端\n            ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端\n            android: u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1, //android终端\n            iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器\n            iPad: u.indexOf('iPad') &gt; -1, //是否iPad\n            webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部\n            weixin: u.indexOf('MicroMessenger') &gt; -1, //是否微信 （2015-01-22新增）\n            qq: u.match(/\\sQQ/i) == \" qq\" //是否QQ\n        };\n    }(),\n    language:(navigator.browserLanguage || navigator.language).toLowerCase()\n}\n&lt;/script&gt;\n</pre>\n<strong>使用方法：</strong>\n<pre class=\"lang:js decode:true \">//判断是否IE内核\nif(browser.versions.trident){ alert(\"is IE\"); }\n//判断是否webKit内核\nif(browser.versions.webKit){ alert(\"is webKit\"); }\n//判断是否移动端\nif(browser.versions.mobile||browser.versions.android||browser.versions.ios){ alert(\"移动端\"); }</pre>\n<strong>检测浏览器语言</strong>：\n<pre class=\"lang:js decode:true \">currentLang = navigator.language;   //判断除IE外其他浏览器使用语言\nif(!currentLang){//判断IE浏览器使用语言\n    currentLang = navigator.browserLanguage;\n}\nalert(currentLang);</pre>\n第二种：\n<pre class=\"lang:default decode:true \">if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {\n    //alert(navigator.userAgent);  \n    window.location.href =\"iPhone.html\";\n} else if (/(Android)/i.test(navigator.userAgent)) {\n    //alert(navigator.userAgent); \n    window.location.href =\"Android.html\";\n} else {\n    window.location.href =\"pc.html\";\n};</pre>\n&nbsp;","source":"_posts/mobile-phone-system.md","raw":"---\ntitle: 判断iOS或Android手机\n---\n通过判断浏览器的userAgent，用正则来判断手机是否是ios和android客户端。<span>代码</span>如下：\n<pre>&lt;script type=\"text/javascript\"&gt;\nvar u = navigator.userAgent;\nvar isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1; //android终端\nvar isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端\nalert('是否是Android：'+isAndroid);\nalert('是否是iOS：'+isiOS);\n&lt;/script&gt;</pre>\n下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端、ipad、iphone、微信、QQ等。\n<pre>&lt;script type=\"text/javascript\"&gt;\n//判断访问终端\nvar browser={\n    versions:function(){\n        var u = navigator.userAgent, app = navigator.appVersion;\n        return {\n            trident: u.indexOf('Trident') &gt; -1, //IE内核\n            presto: u.indexOf('Presto') &gt; -1, //opera内核\n            webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核\n            gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1,//火狐内核\n            mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端\n            ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端\n            android: u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1, //android终端\n            iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器\n            iPad: u.indexOf('iPad') &gt; -1, //是否iPad\n            webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部\n            weixin: u.indexOf('MicroMessenger') &gt; -1, //是否微信 （2015-01-22新增）\n            qq: u.match(/\\sQQ/i) == \" qq\" //是否QQ\n        };\n    }(),\n    language:(navigator.browserLanguage || navigator.language).toLowerCase()\n}\n&lt;/script&gt;\n</pre>\n<strong>使用方法：</strong>\n<pre class=\"lang:js decode:true \">//判断是否IE内核\nif(browser.versions.trident){ alert(\"is IE\"); }\n//判断是否webKit内核\nif(browser.versions.webKit){ alert(\"is webKit\"); }\n//判断是否移动端\nif(browser.versions.mobile||browser.versions.android||browser.versions.ios){ alert(\"移动端\"); }</pre>\n<strong>检测浏览器语言</strong>：\n<pre class=\"lang:js decode:true \">currentLang = navigator.language;   //判断除IE外其他浏览器使用语言\nif(!currentLang){//判断IE浏览器使用语言\n    currentLang = navigator.browserLanguage;\n}\nalert(currentLang);</pre>\n第二种：\n<pre class=\"lang:default decode:true \">if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {\n    //alert(navigator.userAgent);  \n    window.location.href =\"iPhone.html\";\n} else if (/(Android)/i.test(navigator.userAgent)) {\n    //alert(navigator.userAgent); \n    window.location.href =\"Android.html\";\n} else {\n    window.location.href =\"pc.html\";\n};</pre>\n&nbsp;","slug":"mobile-phone-system","published":1,"date":"2017-07-21T08:24:27.021Z","updated":"2017-07-21T08:26:23.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000638tz05j8bjbt","content":"<p>通过判断浏览器的userAgent，用正则来判断手机是否是ios和android客户端。<span>代码</span>如下：</p>\n<p><pre>&lt;script type=”text/javascript”&gt;<br>var u = navigator.userAgent;<br>var isAndroid = u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Adr’) &gt; -1; //android终端<br>var isiOS = !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端<br>alert(‘是否是Android：’+isAndroid);<br>alert(‘是否是iOS：’+isiOS);<br>&lt;/script&gt;</pre><br>下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端、ipad、iphone、微信、QQ等。</p>\n<p><pre>&lt;script type=”text/javascript”&gt;<br>//判断访问终端<br>var browser={<br>    versions:function(){<br>        var u = navigator.userAgent, app = navigator.appVersion;<br>        return {<br>            trident: u.indexOf(‘Trident’) &gt; -1, //IE内核<br>            presto: u.indexOf(‘Presto’) &gt; -1, //opera内核<br>            webKit: u.indexOf(‘AppleWebKit’) &gt; -1, //苹果、谷歌内核<br>            gecko: u.indexOf(‘Gecko’) &gt; -1 &amp;&amp; u.indexOf(‘KHTML’) == -1,//火狐内核<br>            mobile: !!u.match(/AppleWebKit.<em>Mobile.</em>/), //是否为移动终端<br>            ios: !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端<br>            android: u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Adr’) &gt; -1, //android终端<br>            iPhone: u.indexOf(‘iPhone’) &gt; -1 , //是否为iPhone或者QQHD浏览器<br>            iPad: u.indexOf(‘iPad’) &gt; -1, //是否iPad<br>            webApp: u.indexOf(‘Safari’) == -1, //是否web应该程序，没有头部与底部<br>            weixin: u.indexOf(‘MicroMessenger’) &gt; -1, //是否微信 （2015-01-22新增）<br>            qq: u.match(/\\sQQ/i) == “ qq” //是否QQ<br>        };<br>    }(),<br>    language:(navigator.browserLanguage || navigator.language).toLowerCase()<br>}<br>&lt;/script&gt;<br></pre><br><strong>使用方法：</strong></p>\n<p><pre class=\"lang:js decode:true \">//判断是否IE内核<br>if(browser.versions.trident){ alert(“is IE”); }<br>//判断是否webKit内核<br>if(browser.versions.webKit){ alert(“is webKit”); }<br>//判断是否移动端<br>if(browser.versions.mobile||browser.versions.android||browser.versions.ios){ alert(“移动端”); }</pre><br><strong>检测浏览器语言</strong>：</p>\n<p><pre class=\"lang:js decode:true \">currentLang = navigator.language;   //判断除IE外其他浏览器使用语言<br>if(!currentLang){//判断IE浏览器使用语言<br>    currentLang = navigator.browserLanguage;<br>}<br>alert(currentLang);</pre><br>第二种：</p>\n<p><pre class=\"lang:default decode:true \">if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {<br>    //alert(navigator.userAgent);<br>    window.location.href =”iPhone.html”;<br>} else if (/(Android)/i.test(navigator.userAgent)) {<br>    //alert(navigator.userAgent);<br>    window.location.href =”Android.html”;<br>} else {<br>    window.location.href =”pc.html”;<br>};</pre><br>&nbsp;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>通过判断浏览器的userAgent，用正则来判断手机是否是ios和android客户端。<span>代码</span>如下：</p>\n<p><pre>&lt;script type=”text/javascript”&gt;<br>var u = navigator.userAgent;<br>var isAndroid = u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Adr’) &gt; -1; //android终端<br>var isiOS = !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端<br>alert(‘是否是Android：’+isAndroid);<br>alert(‘是否是iOS：’+isiOS);<br>&lt;/script&gt;</pre><br>下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端、ipad、iphone、微信、QQ等。</p>\n<p><pre>&lt;script type=”text/javascript”&gt;<br>//判断访问终端<br>var browser={<br>    versions:function(){<br>        var u = navigator.userAgent, app = navigator.appVersion;<br>        return {<br>            trident: u.indexOf(‘Trident’) &gt; -1, //IE内核<br>            presto: u.indexOf(‘Presto’) &gt; -1, //opera内核<br>            webKit: u.indexOf(‘AppleWebKit’) &gt; -1, //苹果、谷歌内核<br>            gecko: u.indexOf(‘Gecko’) &gt; -1 &amp;&amp; u.indexOf(‘KHTML’) == -1,//火狐内核<br>            mobile: !!u.match(/AppleWebKit.<em>Mobile.</em>/), //是否为移动终端<br>            ios: !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端<br>            android: u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Adr’) &gt; -1, //android终端<br>            iPhone: u.indexOf(‘iPhone’) &gt; -1 , //是否为iPhone或者QQHD浏览器<br>            iPad: u.indexOf(‘iPad’) &gt; -1, //是否iPad<br>            webApp: u.indexOf(‘Safari’) == -1, //是否web应该程序，没有头部与底部<br>            weixin: u.indexOf(‘MicroMessenger’) &gt; -1, //是否微信 （2015-01-22新增）<br>            qq: u.match(/\\sQQ/i) == “ qq” //是否QQ<br>        };<br>    }(),<br>    language:(navigator.browserLanguage || navigator.language).toLowerCase()<br>}<br>&lt;/script&gt;<br></pre><br><strong>使用方法：</strong></p>\n<p><pre class=\"lang:js decode:true \">//判断是否IE内核<br>if(browser.versions.trident){ alert(“is IE”); }<br>//判断是否webKit内核<br>if(browser.versions.webKit){ alert(“is webKit”); }<br>//判断是否移动端<br>if(browser.versions.mobile||browser.versions.android||browser.versions.ios){ alert(“移动端”); }</pre><br><strong>检测浏览器语言</strong>：</p>\n<p><pre class=\"lang:js decode:true \">currentLang = navigator.language;   //判断除IE外其他浏览器使用语言<br>if(!currentLang){//判断IE浏览器使用语言<br>    currentLang = navigator.browserLanguage;<br>}<br>alert(currentLang);</pre><br>第二种：</p>\n<p><pre class=\"lang:default decode:true \">if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {<br>    //alert(navigator.userAgent);<br>    window.location.href =”iPhone.html”;<br>} else if (/(Android)/i.test(navigator.userAgent)) {<br>    //alert(navigator.userAgent);<br>    window.location.href =”Android.html”;<br>} else {<br>    window.location.href =”pc.html”;<br>};</pre><br>&nbsp;</p>\n"},{"title":"Node.js获取Email","_content":"POP3POP3全称为Post Office Protocol version3，是TCP/IP协议族的一员，由RFC 1939定义。其主要提供离线处理邮件，这种离线访问的模式是一种存储转发服务，将邮件从邮件服务器传送到客户端，本地的一些移动、标记操作并不影响服务器端。POP3的客户端首先与服务器建立TCP连接(默认端口是110)，随后向服务器发送命令并等待响应。服务器接收客户端的命令并返回响应。这种你来我往的交互方式维持着两者之间的通信并持续到连接终止。\n\n\n客户端的命令由一个命令和一些参数组成并以空格隔开，以CRLF(Carriage Return-Line Feed:\\r\\n)对结束。其中命令采用ASCII码，但不区分大小写，区分大小写的是其随后的参数。POP3服务器响应由一个状态码和一个可能跟有附加信息的命令组成，所有响应也是由CRLF对结束。状态码的值分为\"positive\"(\"+OK\")和\"negetive\"(\"-ERR\")。当信息发送完毕时，最后一行以结束符(.)加CRLF对。\n\n在整个生命周期中，POP3会话存在的状态有如下几种。当服务器响应命令请求发送授权响应，这一过程为授权(AUTHORIZATION)状态。客户端向服务器发出身份认证并经过服务器确认后就进入了事务（TRANSACTION）状态。这一状态下，服务器获取客户的相关邮件资源，并接收客户端的如下命令：STAT、LIST、RETR、DELE、NOOP、RSET、QUIT 。当客户端发出QUIT命令后，会话会进入更新(UPDATE)状态。在这状态中，服务器会释放上一状态中取得的资源，并终止连接。\n<img title=\"\" src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/nodejs-email/1f86d20ff453fb2a49c457b5f96e5.png\" /></a>\n\n接下来使用node的poplib包来实现POP3客户端的功能。这里我以qq邮件举例，我们先需要把qq邮件服务器的POP3的功能打开，具体可查看相关官方文档。qq邮件的host为'pop.qq.com'，port为995。\n<pre class=\"lang:default decode:true \">var POP3Client = require('poplib');\n//首先建立连接\nvar client = new POP3Client(port, host, {\n      tlserrs: false, //是否忽略tls errors\n      enabletls: true, //传输层安全协议ssl\n      debug: true //是否在console输出命令和响应信息\n});</pre>\n当然我们需要捕获异常来响应服务器发出的错误码，比如111就是服务器拒绝链接。以及一些程序运行过程的控制。通过这些预警措施能有效控制程序的状态。\n<pre>//network error handler\nclient.on('error', function(err){\n      if(err.errno === 111){\n            console.log('Unable to connect to server.');\n      }else{\n            console.log('Server error occurred.');\n      }\n      //console错误\n      console.log(err);\n});\n//state invalid handler 处理状态与命令不一致的情况\nclient.on('invalid-state', function(cmd){\n      console.log('Invalid state. You tried calling ', cmd);\n});\n//locked handler 处理多命令同时进行的问题\nclient.on('locked', function(cmd){\n      console.log('Current conmand has not finished yet. You tried calling ', cmd);\n});</pre>\n按照开始所述的POP3服务流程，我们需要先建立与服务器的连接，并进行身份认证才能进行邮件的获取操作。首先获取邮件列表，再获取第一封邮件的内容。这些操作都成功后就发出QUIT命令来退出服务。\n<pre>//connect to the remote server\nclient.on('connect', function(){\n      console.log('CONNECT success');\n  //成功建立连接后进入AUTHORIZATION状态，进行身份认证\n      client.login(username, password);\n});\n/**\n * Successfully login\n */\n//login handler status Boolean\nclient.on('login', function(status, rawdata){\n      if(status){\n            console.log('LOGIN/PASS success.');\n            //获取邮件列表\n            client.list();\n      }else{\n            console.log('ERR: LOGIN/PASS failed');\n            client.quit();\n      }\n});\n//LIST handler\nclient.on('list', function(status, msgcount, msgnumber, data, rawdata){\n      if(status === false){\n            console.log('LIST failed');\n            //获取失败，退出服务\n            client.quit();\n      }else{\n            console.log('LIST success with', msgcount, ' element(s).');\n            if(msgcount &gt; 0){\n      //获取第一封邮件\n                  client.retr(1);\n            }\n      }\n});\n//RETR handler\nclient.on('retr', function(status, msgnumber, data, rawdata){\n      if(status === true){\n            console.log('RETR success', msgnumber);\n    //获得后，输出data数据\n    console.log('data is ', data);\n            client.quit();\n      }else{\n            console.log('ERR: RETR failed for msgnumber', msgnumber);\n      }\n});\n//QUIT handler\nclient.on('quit', function(status, rawdata){\n      if(status === true){\n            console.log('QUIT success');\n            process.exit(0);\n      }else{\n    console.log('ERR: QUIT failed.');\n            process.exit(0);\n      }\n});</pre>\n这个lib的使用非常简单，但对于结果解析的支持基本没有。不能很好满足我们的需求。所以需要替换为另一个比较复杂但功能更多的邮件协议——IMAP。\n \t<li>IMAPIMAP全称为Internet Message Access Protocol，和POP3一样是邮件访问的协议。现在的版本为IMAP4rev1，和POP3相比主要有以下不同。\n \t<li>支持在线和离线操作。IMAP客户端可以一直连接在服务器上，获得更快的响应时间。</li>\n \t<li>支持多客户端。提供一种机制让客户能够感知其他当前连接到这个邮箱的用户所做的操作。</li>\n \t<li>支持访问消息中的MIME部分。</li>\n \t<li>支持在服务器保留消息状态信息。服务器可以跟踪消息状态提供，多个客户在不同时间访问一个邮箱可以感知其他用户所做的操作。</li>\n \t<li>支持在服务器上访问多个邮箱。</li>\n \t<li>支持服务器端搜索。</li>\n \t<li>支持一个定义良好的扩展机制。</li>\n\nIMAP服务包括了一系列操作：邮箱的建立、删除及重命名、检查新邮件、永久删除邮件、设置和清除标志、基于服务器和 MIME 的分析和搜索、有效并有选择的取回邮件属性、文本和部分内容。兼顾这么多功能的IMAP的命令就比POP3多多了。命令的格式也有所不同，客户端的命令带标签前缀，通过客户端定义，node-imap包的前缀为A加数字(数字通过每次操作累加)。而服务器响应用\"+\"作为前缀，响应的类型分为\"OK\"成功、\"NO\"失败、\"BAD\"错误。\n<a href=\"http://owo-10017157.cossh.myqcloud.com/nodejs-email/c9c3956ac4ce3d6e72da0ba0cb0c6.jpg\" alt=\"IMAP协议的状态\" /></a></p>\nIMAP协议的状态类型有4种，通过状态之间转化来理解IMAP的工作流程。如图，建立连接后，连接会进入认证或者未认证状态。如果是预认证的连接状态会进入认证状态，否则处于未认证的状态。认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、SELECT、EXAMINE、CREATE、DELETE、RENAME、SUBSCRIBE、UNSUBSCRIBE、LIST、LSUB、STATUS和APPEND。，未认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、STARTTLS、AUTHENTICATE、LOGIN。如果出现不适当的命令引发协议错误，则进入注销状态。进入认证状态后，可以发出SELECT命令来选择邮件，这时连接就进入了选中状态。选择状态相比认证状态也接收CHECK、CLOSE、EXPUNGE、SEARCH、FETCH、STORE、COPY及UID命令。当进行退出命令时，进入注销状态。当服务器发出LOGOUT的响应后，双方断开连接。这些命令可以参考<a href=\"https://blog.sina.com.cn/s/blog_604124c10100db11.html\">IMAP命令详解</a>。\n\n我写的例程在node-imap的例子基础上使用mailparser包来解析邮件正文，然后存储到本地磁盘。\n\nnode-imap首先需要创建客户端的实例，通过将认证信息和服务器配置传递给它构造函数。这个实例需要监听ready消息，这个消息是在连接状态属于认证状态时才被触发。触发后，我们选择要打开INBOX邮件文件夹，回调中获得到的信息为这个文件夹中的相关消息，比如messages数和文件夹中可使用的flags等。我们接着在这个文件夹中进行搜索命令，当然可以直接就使用搜索命令对这个邮箱进行邮件搜索。我们搜索的条件为未阅邮件以及时间限制，这个方法返回的是匹配的邮件编号。通过邮件编号，我们能获得这个邮件的内容，获取的命令为FETCH。其imap.fetch()来执行，第一个参数是邮件编号数组，第二个参数是指定返回的邮件的部分内容，node-imap也会自动添加来一些信息字段，比如UID、FLAGS、INTERNALDATE。然后我们在等待fetch到的数据传递回来。这一阶段的代码如下。\n<pre>function openInbox(cb){\n  imap.openBox('INBOX', true, cb);\n};\n//等待触发ready\nimap.once('ready', function(){\n  openInbox(function(err, box){\n    if(err){\n      //抛出异常 imap处理\n      throw err;\n    }else{\n      console.log('Info: You have %d messages in your INBOX', box.messages.total);\n      imap.search(['UNSEEN', [ 'SINCE' , '2015-06-14' ]], function(err, results){\n        console.log('Debug: search results is ' + results);\n        if(err){\n          throw err;\n        }else{\n          var f = imap.fetch(results, { bodies: '', struct: true });\n          //接下来对得到的数据处理\n          //...\n        }\n      }\n    }\n  }\n});</pre>\n监听到'message'消息后，通过Mailparset包来解析邮件内容。为了节省内存消耗，通过steam的方式将数据传递给解析器。解析器再将邮件数据存储起来。\n<pre>f.on('message', function(msg, seqno){\n  var mailparser = new MailParser();            \n  console.log('Info: Message #%d', seqno);\n  var prefix = '(#' + seqno + ')';\n  //正文内容的处理\n  msg.on('body', function(stream, info){\n    console.log('Debug: info.which: ' + info.which);\n    if(info.which === 'TEXT'){\n      console.log(prefix + 'Body [%s] found, %d total bytes', inspect(info.which), info.size);\n    }\n    //pipe到mailparse解析器\n    stream.pipe(mailparser);\n    var buffer = '',\n        count = 0;\n    stream.on('data', function(chunk){\n      count += chunk.length;\n      buffer += chunk.toString('utf8');\n    });\n    //stream结束，向console发出消息\n    stream.once('end', function(){\n      if(info.which !== 'TEXT'){\n        console.log(prefix + 'Parsed header: %s', inspect(Imap.parseHeader(buffer)));\n      }else{\n        console.log(prefix + 'Body[%s] Finished', inspect(info.which));\n      }\n    });\n    //解析器将获得的数据存储到磁盘。\n    mailparser.on(\"end\", function(mail){\n      fs.writeFile('msg- ' + seqno + '-body.html', mail.html, function(err){\n        if(err){\n          throw err;\n        }\n        console.log('Info: #%d saved!', seqno);\n      });\n      //如果有附件，则存储起来。\n      if(mail.attachments){\n        mail.attachments.forEach(function(attachment){\n            console.log(attachment.fileName);\n            fs.writeFile('msg-' + seqno + '-' + attachment.generatedFileName, attachment.content, function(err){\n              if(err){\n                throw err;\n              }\n              console.log('Info: #%d attachment saved!', seqno);\n            });\n        });                    \n      }\n  });\n});</pre>\n接下来还需要做的事是将邮件数据聚合，以一封完整的格式存储到MongoDB数据库中。\n","source":"_posts/nodejs-email.md","raw":"---\ntitle: Node.js获取Email\n---\nPOP3POP3全称为Post Office Protocol version3，是TCP/IP协议族的一员，由RFC 1939定义。其主要提供离线处理邮件，这种离线访问的模式是一种存储转发服务，将邮件从邮件服务器传送到客户端，本地的一些移动、标记操作并不影响服务器端。POP3的客户端首先与服务器建立TCP连接(默认端口是110)，随后向服务器发送命令并等待响应。服务器接收客户端的命令并返回响应。这种你来我往的交互方式维持着两者之间的通信并持续到连接终止。\n\n\n客户端的命令由一个命令和一些参数组成并以空格隔开，以CRLF(Carriage Return-Line Feed:\\r\\n)对结束。其中命令采用ASCII码，但不区分大小写，区分大小写的是其随后的参数。POP3服务器响应由一个状态码和一个可能跟有附加信息的命令组成，所有响应也是由CRLF对结束。状态码的值分为\"positive\"(\"+OK\")和\"negetive\"(\"-ERR\")。当信息发送完毕时，最后一行以结束符(.)加CRLF对。\n\n在整个生命周期中，POP3会话存在的状态有如下几种。当服务器响应命令请求发送授权响应，这一过程为授权(AUTHORIZATION)状态。客户端向服务器发出身份认证并经过服务器确认后就进入了事务（TRANSACTION）状态。这一状态下，服务器获取客户的相关邮件资源，并接收客户端的如下命令：STAT、LIST、RETR、DELE、NOOP、RSET、QUIT 。当客户端发出QUIT命令后，会话会进入更新(UPDATE)状态。在这状态中，服务器会释放上一状态中取得的资源，并终止连接。\n<img title=\"\" src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/nodejs-email/1f86d20ff453fb2a49c457b5f96e5.png\" /></a>\n\n接下来使用node的poplib包来实现POP3客户端的功能。这里我以qq邮件举例，我们先需要把qq邮件服务器的POP3的功能打开，具体可查看相关官方文档。qq邮件的host为'pop.qq.com'，port为995。\n<pre class=\"lang:default decode:true \">var POP3Client = require('poplib');\n//首先建立连接\nvar client = new POP3Client(port, host, {\n      tlserrs: false, //是否忽略tls errors\n      enabletls: true, //传输层安全协议ssl\n      debug: true //是否在console输出命令和响应信息\n});</pre>\n当然我们需要捕获异常来响应服务器发出的错误码，比如111就是服务器拒绝链接。以及一些程序运行过程的控制。通过这些预警措施能有效控制程序的状态。\n<pre>//network error handler\nclient.on('error', function(err){\n      if(err.errno === 111){\n            console.log('Unable to connect to server.');\n      }else{\n            console.log('Server error occurred.');\n      }\n      //console错误\n      console.log(err);\n});\n//state invalid handler 处理状态与命令不一致的情况\nclient.on('invalid-state', function(cmd){\n      console.log('Invalid state. You tried calling ', cmd);\n});\n//locked handler 处理多命令同时进行的问题\nclient.on('locked', function(cmd){\n      console.log('Current conmand has not finished yet. You tried calling ', cmd);\n});</pre>\n按照开始所述的POP3服务流程，我们需要先建立与服务器的连接，并进行身份认证才能进行邮件的获取操作。首先获取邮件列表，再获取第一封邮件的内容。这些操作都成功后就发出QUIT命令来退出服务。\n<pre>//connect to the remote server\nclient.on('connect', function(){\n      console.log('CONNECT success');\n  //成功建立连接后进入AUTHORIZATION状态，进行身份认证\n      client.login(username, password);\n});\n/**\n * Successfully login\n */\n//login handler status Boolean\nclient.on('login', function(status, rawdata){\n      if(status){\n            console.log('LOGIN/PASS success.');\n            //获取邮件列表\n            client.list();\n      }else{\n            console.log('ERR: LOGIN/PASS failed');\n            client.quit();\n      }\n});\n//LIST handler\nclient.on('list', function(status, msgcount, msgnumber, data, rawdata){\n      if(status === false){\n            console.log('LIST failed');\n            //获取失败，退出服务\n            client.quit();\n      }else{\n            console.log('LIST success with', msgcount, ' element(s).');\n            if(msgcount &gt; 0){\n      //获取第一封邮件\n                  client.retr(1);\n            }\n      }\n});\n//RETR handler\nclient.on('retr', function(status, msgnumber, data, rawdata){\n      if(status === true){\n            console.log('RETR success', msgnumber);\n    //获得后，输出data数据\n    console.log('data is ', data);\n            client.quit();\n      }else{\n            console.log('ERR: RETR failed for msgnumber', msgnumber);\n      }\n});\n//QUIT handler\nclient.on('quit', function(status, rawdata){\n      if(status === true){\n            console.log('QUIT success');\n            process.exit(0);\n      }else{\n    console.log('ERR: QUIT failed.');\n            process.exit(0);\n      }\n});</pre>\n这个lib的使用非常简单，但对于结果解析的支持基本没有。不能很好满足我们的需求。所以需要替换为另一个比较复杂但功能更多的邮件协议——IMAP。\n \t<li>IMAPIMAP全称为Internet Message Access Protocol，和POP3一样是邮件访问的协议。现在的版本为IMAP4rev1，和POP3相比主要有以下不同。\n \t<li>支持在线和离线操作。IMAP客户端可以一直连接在服务器上，获得更快的响应时间。</li>\n \t<li>支持多客户端。提供一种机制让客户能够感知其他当前连接到这个邮箱的用户所做的操作。</li>\n \t<li>支持访问消息中的MIME部分。</li>\n \t<li>支持在服务器保留消息状态信息。服务器可以跟踪消息状态提供，多个客户在不同时间访问一个邮箱可以感知其他用户所做的操作。</li>\n \t<li>支持在服务器上访问多个邮箱。</li>\n \t<li>支持服务器端搜索。</li>\n \t<li>支持一个定义良好的扩展机制。</li>\n\nIMAP服务包括了一系列操作：邮箱的建立、删除及重命名、检查新邮件、永久删除邮件、设置和清除标志、基于服务器和 MIME 的分析和搜索、有效并有选择的取回邮件属性、文本和部分内容。兼顾这么多功能的IMAP的命令就比POP3多多了。命令的格式也有所不同，客户端的命令带标签前缀，通过客户端定义，node-imap包的前缀为A加数字(数字通过每次操作累加)。而服务器响应用\"+\"作为前缀，响应的类型分为\"OK\"成功、\"NO\"失败、\"BAD\"错误。\n<a href=\"http://owo-10017157.cossh.myqcloud.com/nodejs-email/c9c3956ac4ce3d6e72da0ba0cb0c6.jpg\" alt=\"IMAP协议的状态\" /></a></p>\nIMAP协议的状态类型有4种，通过状态之间转化来理解IMAP的工作流程。如图，建立连接后，连接会进入认证或者未认证状态。如果是预认证的连接状态会进入认证状态，否则处于未认证的状态。认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、SELECT、EXAMINE、CREATE、DELETE、RENAME、SUBSCRIBE、UNSUBSCRIBE、LIST、LSUB、STATUS和APPEND。，未认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、STARTTLS、AUTHENTICATE、LOGIN。如果出现不适当的命令引发协议错误，则进入注销状态。进入认证状态后，可以发出SELECT命令来选择邮件，这时连接就进入了选中状态。选择状态相比认证状态也接收CHECK、CLOSE、EXPUNGE、SEARCH、FETCH、STORE、COPY及UID命令。当进行退出命令时，进入注销状态。当服务器发出LOGOUT的响应后，双方断开连接。这些命令可以参考<a href=\"https://blog.sina.com.cn/s/blog_604124c10100db11.html\">IMAP命令详解</a>。\n\n我写的例程在node-imap的例子基础上使用mailparser包来解析邮件正文，然后存储到本地磁盘。\n\nnode-imap首先需要创建客户端的实例，通过将认证信息和服务器配置传递给它构造函数。这个实例需要监听ready消息，这个消息是在连接状态属于认证状态时才被触发。触发后，我们选择要打开INBOX邮件文件夹，回调中获得到的信息为这个文件夹中的相关消息，比如messages数和文件夹中可使用的flags等。我们接着在这个文件夹中进行搜索命令，当然可以直接就使用搜索命令对这个邮箱进行邮件搜索。我们搜索的条件为未阅邮件以及时间限制，这个方法返回的是匹配的邮件编号。通过邮件编号，我们能获得这个邮件的内容，获取的命令为FETCH。其imap.fetch()来执行，第一个参数是邮件编号数组，第二个参数是指定返回的邮件的部分内容，node-imap也会自动添加来一些信息字段，比如UID、FLAGS、INTERNALDATE。然后我们在等待fetch到的数据传递回来。这一阶段的代码如下。\n<pre>function openInbox(cb){\n  imap.openBox('INBOX', true, cb);\n};\n//等待触发ready\nimap.once('ready', function(){\n  openInbox(function(err, box){\n    if(err){\n      //抛出异常 imap处理\n      throw err;\n    }else{\n      console.log('Info: You have %d messages in your INBOX', box.messages.total);\n      imap.search(['UNSEEN', [ 'SINCE' , '2015-06-14' ]], function(err, results){\n        console.log('Debug: search results is ' + results);\n        if(err){\n          throw err;\n        }else{\n          var f = imap.fetch(results, { bodies: '', struct: true });\n          //接下来对得到的数据处理\n          //...\n        }\n      }\n    }\n  }\n});</pre>\n监听到'message'消息后，通过Mailparset包来解析邮件内容。为了节省内存消耗，通过steam的方式将数据传递给解析器。解析器再将邮件数据存储起来。\n<pre>f.on('message', function(msg, seqno){\n  var mailparser = new MailParser();            \n  console.log('Info: Message #%d', seqno);\n  var prefix = '(#' + seqno + ')';\n  //正文内容的处理\n  msg.on('body', function(stream, info){\n    console.log('Debug: info.which: ' + info.which);\n    if(info.which === 'TEXT'){\n      console.log(prefix + 'Body [%s] found, %d total bytes', inspect(info.which), info.size);\n    }\n    //pipe到mailparse解析器\n    stream.pipe(mailparser);\n    var buffer = '',\n        count = 0;\n    stream.on('data', function(chunk){\n      count += chunk.length;\n      buffer += chunk.toString('utf8');\n    });\n    //stream结束，向console发出消息\n    stream.once('end', function(){\n      if(info.which !== 'TEXT'){\n        console.log(prefix + 'Parsed header: %s', inspect(Imap.parseHeader(buffer)));\n      }else{\n        console.log(prefix + 'Body[%s] Finished', inspect(info.which));\n      }\n    });\n    //解析器将获得的数据存储到磁盘。\n    mailparser.on(\"end\", function(mail){\n      fs.writeFile('msg- ' + seqno + '-body.html', mail.html, function(err){\n        if(err){\n          throw err;\n        }\n        console.log('Info: #%d saved!', seqno);\n      });\n      //如果有附件，则存储起来。\n      if(mail.attachments){\n        mail.attachments.forEach(function(attachment){\n            console.log(attachment.fileName);\n            fs.writeFile('msg-' + seqno + '-' + attachment.generatedFileName, attachment.content, function(err){\n              if(err){\n                throw err;\n              }\n              console.log('Info: #%d attachment saved!', seqno);\n            });\n        });                    \n      }\n  });\n});</pre>\n接下来还需要做的事是将邮件数据聚合，以一封完整的格式存储到MongoDB数据库中。\n","slug":"nodejs-email","published":1,"date":"2017-07-21T08:27:19.028Z","updated":"2017-08-16T09:56:51.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000738tzevh5l459","content":"<p>POP3POP3全称为Post Office Protocol version3，是TCP/IP协议族的一员，由RFC 1939定义。其主要提供离线处理邮件，这种离线访问的模式是一种存储转发服务，将邮件从邮件服务器传送到客户端，本地的一些移动、标记操作并不影响服务器端。POP3的客户端首先与服务器建立TCP连接(默认端口是110)，随后向服务器发送命令并等待响应。服务器接收客户端的命令并返回响应。这种你来我往的交互方式维持着两者之间的通信并持续到连接终止。</p>\n<p>客户端的命令由一个命令和一些参数组成并以空格隔开，以CRLF(Carriage Return-Line Feed:\\r\\n)对结束。其中命令采用ASCII码，但不区分大小写，区分大小写的是其随后的参数。POP3服务器响应由一个状态码和一个可能跟有附加信息的命令组成，所有响应也是由CRLF对结束。状态码的值分为”positive”(“+OK”)和”negetive”(“-ERR”)。当信息发送完毕时，最后一行以结束符(.)加CRLF对。</p>\n<p>在整个生命周期中，POP3会话存在的状态有如下几种。当服务器响应命令请求发送授权响应，这一过程为授权(AUTHORIZATION)状态。客户端向服务器发出身份认证并经过服务器确认后就进入了事务（TRANSACTION）状态。这一状态下，服务器获取客户的相关邮件资源，并接收客户端的如下命令：STAT、LIST、RETR、DELE、NOOP、RSET、QUIT 。当客户端发出QUIT命令后，会话会进入更新(UPDATE)状态。在这状态中，服务器会释放上一状态中取得的资源，并终止连接。<br><img title=\"\" src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/nodejs-email/1f86d20ff453fb2a49c457b5f96e5.png\"></p>\n<p>接下来使用node的poplib包来实现POP3客户端的功能。这里我以qq邮件举例，我们先需要把qq邮件服务器的POP3的功能打开，具体可查看相关官方文档。qq邮件的host为’pop.qq.com’，port为995。</p>\n<p><pre class=\"lang:default decode:true \">var POP3Client = require(‘poplib’);<br>//首先建立连接<br>var client = new POP3Client(port, host, {<br>      tlserrs: false, //是否忽略tls errors<br>      enabletls: true, //传输层安全协议ssl<br>      debug: true //是否在console输出命令和响应信息<br>});</pre><br>当然我们需要捕获异常来响应服务器发出的错误码，比如111就是服务器拒绝链接。以及一些程序运行过程的控制。通过这些预警措施能有效控制程序的状态。</p>\n<p><pre>//network error handler<br>client.on(‘error’, function(err){<br>      if(err.errno === 111){<br>            console.log(‘Unable to connect to server.’);<br>      }else{<br>            console.log(‘Server error occurred.’);<br>      }<br>      //console错误<br>      console.log(err);<br>});<br>//state invalid handler 处理状态与命令不一致的情况<br>client.on(‘invalid-state’, function(cmd){<br>      console.log(‘Invalid state. You tried calling ‘, cmd);<br>});<br>//locked handler 处理多命令同时进行的问题<br>client.on(‘locked’, function(cmd){<br>      console.log(‘Current conmand has not finished yet. You tried calling ‘, cmd);<br>});</pre><br>按照开始所述的POP3服务流程，我们需要先建立与服务器的连接，并进行身份认证才能进行邮件的获取操作。首先获取邮件列表，再获取第一封邮件的内容。这些操作都成功后就发出QUIT命令来退出服务。</p>\n<p><pre>//connect to the remote server<br>client.on(‘connect’, function(){<br>      console.log(‘CONNECT success’);<br>  //成功建立连接后进入AUTHORIZATION状态，进行身份认证<br>      client.login(username, password);<br>});<br>/**</pre></p>\n<ul>\n<li>Successfully login<br>*/<br>//login handler status Boolean<br>client.on(‘login’, function(status, rawdata){<br>   if(status){<pre><code>console.log(&apos;LOGIN/PASS success.&apos;);\n//获取邮件列表\nclient.list();\n</code></pre>   }else{<pre><code>console.log(&apos;ERR: LOGIN/PASS failed&apos;);\nclient.quit();\n</code></pre>   }<br>});<br>//LIST handler<br>client.on(‘list’, function(status, msgcount, msgnumber, data, rawdata){<br>   if(status === false){<pre><code>console.log(&apos;LIST failed&apos;);\n//获取失败，退出服务\nclient.quit();\n</code></pre>   }else{<pre><code>console.log(&apos;LIST success with&apos;, msgcount, &apos; element(s).&apos;);\nif(msgcount &amp;gt; 0){\n</code></pre>   //获取第一封邮件<pre><code>      client.retr(1);\n}\n</code></pre>   }<br>});<br>//RETR handler<br>client.on(‘retr’, function(status, msgnumber, data, rawdata){<br>   if(status === true){<pre><code>console.log(&apos;RETR success&apos;, msgnumber);\n</code></pre> //获得后，输出data数据<br> console.log(‘data is ‘, data);<pre><code>client.quit();\n</code></pre>   }else{<pre><code>console.log(&apos;ERR: RETR failed for msgnumber&apos;, msgnumber);\n</code></pre>   }<br>});<br>//QUIT handler<br>client.on(‘quit’, function(status, rawdata){<br>   if(status === true){<pre><code>console.log(&apos;QUIT success&apos;);\nprocess.exit(0);\n</code></pre>   }else{<br> console.log(‘ERR: QUIT failed.’);<pre><code>process.exit(0);\n</code></pre>   }<br>});<br>这个lib的使用非常简单，但对于结果解析的支持基本没有。不能很好满足我们的需求。所以需要替换为另一个比较复杂但功能更多的邮件协议——IMAP。  </li><li>IMAPIMAP全称为Internet Message Access Protocol，和POP3一样是邮件访问的协议。现在的版本为IMAP4rev1，和POP3相比主要有以下不同。<br>  </li><li>支持在线和离线操作。IMAP客户端可以一直连接在服务器上，获得更快的响应时间。</li><br>  <li>支持多客户端。提供一种机制让客户能够感知其他当前连接到这个邮箱的用户所做的操作。</li><br>  <li>支持访问消息中的MIME部分。</li><br>  <li>支持在服务器保留消息状态信息。服务器可以跟踪消息状态提供，多个客户在不同时间访问一个邮箱可以感知其他用户所做的操作。</li><br>  <li>支持在服务器上访问多个邮箱。</li><br>  <li>支持服务器端搜索。</li><br>  <li>支持一个定义良好的扩展机制。</li>\n\n\n</ul>\n<p>IMAP服务包括了一系列操作：邮箱的建立、删除及重命名、检查新邮件、永久删除邮件、设置和清除标志、基于服务器和 MIME 的分析和搜索、有效并有选择的取回邮件属性、文本和部分内容。兼顾这么多功能的IMAP的命令就比POP3多多了。命令的格式也有所不同，客户端的命令带标签前缀，通过客户端定义，node-imap包的前缀为A加数字(数字通过每次操作累加)。而服务器响应用”+”作为前缀，响应的类型分为”OK”成功、”NO”失败、”BAD”错误。<br><a href=\"http://owo-10017157.cossh.myqcloud.com/nodejs-email/c9c3956ac4ce3d6e72da0ba0cb0c6.jpg\" alt=\"IMAP协议的状态\" target=\"_blank\" rel=\"external\"></a></p><br>IMAP协议的状态类型有4种，通过状态之间转化来理解IMAP的工作流程。如图，建立连接后，连接会进入认证或者未认证状态。如果是预认证的连接状态会进入认证状态，否则处于未认证的状态。认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、SELECT、EXAMINE、CREATE、DELETE、RENAME、SUBSCRIBE、UNSUBSCRIBE、LIST、LSUB、STATUS和APPEND。，未认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、STARTTLS、AUTHENTICATE、LOGIN。如果出现不适当的命令引发协议错误，则进入注销状态。进入认证状态后，可以发出SELECT命令来选择邮件，这时连接就进入了选中状态。选择状态相比认证状态也接收CHECK、CLOSE、EXPUNGE、SEARCH、FETCH、STORE、COPY及UID命令。当进行退出命令时，进入注销状态。当服务器发出LOGOUT的响应后，双方断开连接。这些命令可以参考<a href=\"https://blog.sina.com.cn/s/blog_604124c10100db11.html\" target=\"_blank\" rel=\"external\">IMAP命令详解</a>。<p></p>\n<p>我写的例程在node-imap的例子基础上使用mailparser包来解析邮件正文，然后存储到本地磁盘。</p>\n<p>node-imap首先需要创建客户端的实例，通过将认证信息和服务器配置传递给它构造函数。这个实例需要监听ready消息，这个消息是在连接状态属于认证状态时才被触发。触发后，我们选择要打开INBOX邮件文件夹，回调中获得到的信息为这个文件夹中的相关消息，比如messages数和文件夹中可使用的flags等。我们接着在这个文件夹中进行搜索命令，当然可以直接就使用搜索命令对这个邮箱进行邮件搜索。我们搜索的条件为未阅邮件以及时间限制，这个方法返回的是匹配的邮件编号。通过邮件编号，我们能获得这个邮件的内容，获取的命令为FETCH。其imap.fetch()来执行，第一个参数是邮件编号数组，第二个参数是指定返回的邮件的部分内容，node-imap也会自动添加来一些信息字段，比如UID、FLAGS、INTERNALDATE。然后我们在等待fetch到的数据传递回来。这一阶段的代码如下。</p>\n<p><pre>function openInbox(cb){<br>  imap.openBox(‘INBOX’, true, cb);<br>};<br>//等待触发ready<br>imap.once(‘ready’, function(){<br>  openInbox(function(err, box){<br>    if(err){<br>      //抛出异常 imap处理<br>      throw err;<br>    }else{<br>      console.log(‘Info: You have %d messages in your INBOX’, box.messages.total);<br>      imap.search([‘UNSEEN’, [ ‘SINCE’ , ‘2015-06-14’ ]], function(err, results){<br>        console.log(‘Debug: search results is ‘ + results);<br>        if(err){<br>          throw err;<br>        }else{<br>          var f = imap.fetch(results, { bodies: ‘’, struct: true });<br>          //接下来对得到的数据处理<br>          //…<br>        }<br>      }<br>    }<br>  }<br>});</pre><br>监听到’message’消息后，通过Mailparset包来解析邮件内容。为了节省内存消耗，通过steam的方式将数据传递给解析器。解析器再将邮件数据存储起来。</p>\n<p><pre>f.on(‘message’, function(msg, seqno){<br>  var mailparser = new MailParser();<br>  console.log(‘Info: Message #%d’, seqno);<br>  var prefix = ‘(#’ + seqno + ‘)’;<br>  //正文内容的处理<br>  msg.on(‘body’, function(stream, info){<br>    console.log(‘Debug: info.which: ‘ + info.which);<br>    if(info.which === ‘TEXT’){<br>      console.log(prefix + ‘Body [%s] found, %d total bytes’, inspect(info.which), info.size);<br>    }<br>    //pipe到mailparse解析器<br>    stream.pipe(mailparser);<br>    var buffer = ‘’,<br>        count = 0;<br>    stream.on(‘data’, function(chunk){<br>      count += chunk.length;<br>      buffer += chunk.toString(‘utf8’);<br>    });<br>    //stream结束，向console发出消息<br>    stream.once(‘end’, function(){<br>      if(info.which !== ‘TEXT’){<br>        console.log(prefix + ‘Parsed header: %s’, inspect(Imap.parseHeader(buffer)));<br>      }else{<br>        console.log(prefix + ‘Body[%s] Finished’, inspect(info.which));<br>      }<br>    });<br>    //解析器将获得的数据存储到磁盘。<br>    mailparser.on(“end”, function(mail){<br>      fs.writeFile(‘msg- ‘ + seqno + ‘-body.html’, mail.html, function(err){<br>        if(err){<br>          throw err;<br>        }<br>        console.log(‘Info: #%d saved!’, seqno);<br>      });<br>      //如果有附件，则存储起来。<br>      if(mail.attachments){<br>        mail.attachments.forEach(function(attachment){<br>            console.log(attachment.fileName);<br>            fs.writeFile(‘msg-‘ + seqno + ‘-‘ + attachment.generatedFileName, attachment.content, function(err){<br>              if(err){<br>                throw err;<br>              }<br>              console.log(‘Info: #%d attachment saved!’, seqno);<br>            });<br>        });<br>      }<br>  });<br>});</pre><br>接下来还需要做的事是将邮件数据聚合，以一封完整的格式存储到MongoDB数据库中。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>POP3POP3全称为Post Office Protocol version3，是TCP/IP协议族的一员，由RFC 1939定义。其主要提供离线处理邮件，这种离线访问的模式是一种存储转发服务，将邮件从邮件服务器传送到客户端，本地的一些移动、标记操作并不影响服务器端。POP3的客户端首先与服务器建立TCP连接(默认端口是110)，随后向服务器发送命令并等待响应。服务器接收客户端的命令并返回响应。这种你来我往的交互方式维持着两者之间的通信并持续到连接终止。</p>\n<p>客户端的命令由一个命令和一些参数组成并以空格隔开，以CRLF(Carriage Return-Line Feed:\\r\\n)对结束。其中命令采用ASCII码，但不区分大小写，区分大小写的是其随后的参数。POP3服务器响应由一个状态码和一个可能跟有附加信息的命令组成，所有响应也是由CRLF对结束。状态码的值分为”positive”(“+OK”)和”negetive”(“-ERR”)。当信息发送完毕时，最后一行以结束符(.)加CRLF对。</p>\n<p>在整个生命周期中，POP3会话存在的状态有如下几种。当服务器响应命令请求发送授权响应，这一过程为授权(AUTHORIZATION)状态。客户端向服务器发出身份认证并经过服务器确认后就进入了事务（TRANSACTION）状态。这一状态下，服务器获取客户的相关邮件资源，并接收客户端的如下命令：STAT、LIST、RETR、DELE、NOOP、RSET、QUIT 。当客户端发出QUIT命令后，会话会进入更新(UPDATE)状态。在这状态中，服务器会释放上一状态中取得的资源，并终止连接。<br><img title=\"\" src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/nodejs-email/1f86d20ff453fb2a49c457b5f96e5.png\"></p>\n<p>接下来使用node的poplib包来实现POP3客户端的功能。这里我以qq邮件举例，我们先需要把qq邮件服务器的POP3的功能打开，具体可查看相关官方文档。qq邮件的host为’pop.qq.com’，port为995。</p>\n<p><pre class=\"lang:default decode:true \">var POP3Client = require(‘poplib’);<br>//首先建立连接<br>var client = new POP3Client(port, host, {<br>      tlserrs: false, //是否忽略tls errors<br>      enabletls: true, //传输层安全协议ssl<br>      debug: true //是否在console输出命令和响应信息<br>});</pre><br>当然我们需要捕获异常来响应服务器发出的错误码，比如111就是服务器拒绝链接。以及一些程序运行过程的控制。通过这些预警措施能有效控制程序的状态。</p>\n<p><pre>//network error handler<br>client.on(‘error’, function(err){<br>      if(err.errno === 111){<br>            console.log(‘Unable to connect to server.’);<br>      }else{<br>            console.log(‘Server error occurred.’);<br>      }<br>      //console错误<br>      console.log(err);<br>});<br>//state invalid handler 处理状态与命令不一致的情况<br>client.on(‘invalid-state’, function(cmd){<br>      console.log(‘Invalid state. You tried calling ‘, cmd);<br>});<br>//locked handler 处理多命令同时进行的问题<br>client.on(‘locked’, function(cmd){<br>      console.log(‘Current conmand has not finished yet. You tried calling ‘, cmd);<br>});</pre><br>按照开始所述的POP3服务流程，我们需要先建立与服务器的连接，并进行身份认证才能进行邮件的获取操作。首先获取邮件列表，再获取第一封邮件的内容。这些操作都成功后就发出QUIT命令来退出服务。</p>\n<p><pre>//connect to the remote server<br>client.on(‘connect’, function(){<br>      console.log(‘CONNECT success’);<br>  //成功建立连接后进入AUTHORIZATION状态，进行身份认证<br>      client.login(username, password);<br>});<br>/**</pre></p>\n<ul>\n<li>Successfully login<br>*/<br>//login handler status Boolean<br>client.on(‘login’, function(status, rawdata){<br>   if(status){<pre><code>console.log(&apos;LOGIN/PASS success.&apos;);\n//获取邮件列表\nclient.list();\n</code></pre>   }else{<pre><code>console.log(&apos;ERR: LOGIN/PASS failed&apos;);\nclient.quit();\n</code></pre>   }<br>});<br>//LIST handler<br>client.on(‘list’, function(status, msgcount, msgnumber, data, rawdata){<br>   if(status === false){<pre><code>console.log(&apos;LIST failed&apos;);\n//获取失败，退出服务\nclient.quit();\n</code></pre>   }else{<pre><code>console.log(&apos;LIST success with&apos;, msgcount, &apos; element(s).&apos;);\nif(msgcount &amp;gt; 0){\n</code></pre>   //获取第一封邮件<pre><code>      client.retr(1);\n}\n</code></pre>   }<br>});<br>//RETR handler<br>client.on(‘retr’, function(status, msgnumber, data, rawdata){<br>   if(status === true){<pre><code>console.log(&apos;RETR success&apos;, msgnumber);\n</code></pre> //获得后，输出data数据<br> console.log(‘data is ‘, data);<pre><code>client.quit();\n</code></pre>   }else{<pre><code>console.log(&apos;ERR: RETR failed for msgnumber&apos;, msgnumber);\n</code></pre>   }<br>});<br>//QUIT handler<br>client.on(‘quit’, function(status, rawdata){<br>   if(status === true){<pre><code>console.log(&apos;QUIT success&apos;);\nprocess.exit(0);\n</code></pre>   }else{<br> console.log(‘ERR: QUIT failed.’);<pre><code>process.exit(0);\n</code></pre>   }<br>});<br>这个lib的使用非常简单，但对于结果解析的支持基本没有。不能很好满足我们的需求。所以需要替换为另一个比较复杂但功能更多的邮件协议——IMAP。  </li><li>IMAPIMAP全称为Internet Message Access Protocol，和POP3一样是邮件访问的协议。现在的版本为IMAP4rev1，和POP3相比主要有以下不同。<br>  </li><li>支持在线和离线操作。IMAP客户端可以一直连接在服务器上，获得更快的响应时间。</li><br>  <li>支持多客户端。提供一种机制让客户能够感知其他当前连接到这个邮箱的用户所做的操作。</li><br>  <li>支持访问消息中的MIME部分。</li><br>  <li>支持在服务器保留消息状态信息。服务器可以跟踪消息状态提供，多个客户在不同时间访问一个邮箱可以感知其他用户所做的操作。</li><br>  <li>支持在服务器上访问多个邮箱。</li><br>  <li>支持服务器端搜索。</li><br>  <li>支持一个定义良好的扩展机制。</li>\n\n\n</ul>\n<p>IMAP服务包括了一系列操作：邮箱的建立、删除及重命名、检查新邮件、永久删除邮件、设置和清除标志、基于服务器和 MIME 的分析和搜索、有效并有选择的取回邮件属性、文本和部分内容。兼顾这么多功能的IMAP的命令就比POP3多多了。命令的格式也有所不同，客户端的命令带标签前缀，通过客户端定义，node-imap包的前缀为A加数字(数字通过每次操作累加)。而服务器响应用”+”作为前缀，响应的类型分为”OK”成功、”NO”失败、”BAD”错误。<br><a href=\"http://owo-10017157.cossh.myqcloud.com/nodejs-email/c9c3956ac4ce3d6e72da0ba0cb0c6.jpg\" alt=\"IMAP协议的状态\" target=\"_blank\" rel=\"external\"></a></p><br>IMAP协议的状态类型有4种，通过状态之间转化来理解IMAP的工作流程。如图，建立连接后，连接会进入认证或者未认证状态。如果是预认证的连接状态会进入认证状态，否则处于未认证的状态。认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、SELECT、EXAMINE、CREATE、DELETE、RENAME、SUBSCRIBE、UNSUBSCRIBE、LIST、LSUB、STATUS和APPEND。，未认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、STARTTLS、AUTHENTICATE、LOGIN。如果出现不适当的命令引发协议错误，则进入注销状态。进入认证状态后，可以发出SELECT命令来选择邮件，这时连接就进入了选中状态。选择状态相比认证状态也接收CHECK、CLOSE、EXPUNGE、SEARCH、FETCH、STORE、COPY及UID命令。当进行退出命令时，进入注销状态。当服务器发出LOGOUT的响应后，双方断开连接。这些命令可以参考<a href=\"https://blog.sina.com.cn/s/blog_604124c10100db11.html\" target=\"_blank\" rel=\"external\">IMAP命令详解</a>。<p></p>\n<p>我写的例程在node-imap的例子基础上使用mailparser包来解析邮件正文，然后存储到本地磁盘。</p>\n<p>node-imap首先需要创建客户端的实例，通过将认证信息和服务器配置传递给它构造函数。这个实例需要监听ready消息，这个消息是在连接状态属于认证状态时才被触发。触发后，我们选择要打开INBOX邮件文件夹，回调中获得到的信息为这个文件夹中的相关消息，比如messages数和文件夹中可使用的flags等。我们接着在这个文件夹中进行搜索命令，当然可以直接就使用搜索命令对这个邮箱进行邮件搜索。我们搜索的条件为未阅邮件以及时间限制，这个方法返回的是匹配的邮件编号。通过邮件编号，我们能获得这个邮件的内容，获取的命令为FETCH。其imap.fetch()来执行，第一个参数是邮件编号数组，第二个参数是指定返回的邮件的部分内容，node-imap也会自动添加来一些信息字段，比如UID、FLAGS、INTERNALDATE。然后我们在等待fetch到的数据传递回来。这一阶段的代码如下。</p>\n<p><pre>function openInbox(cb){<br>  imap.openBox(‘INBOX’, true, cb);<br>};<br>//等待触发ready<br>imap.once(‘ready’, function(){<br>  openInbox(function(err, box){<br>    if(err){<br>      //抛出异常 imap处理<br>      throw err;<br>    }else{<br>      console.log(‘Info: You have %d messages in your INBOX’, box.messages.total);<br>      imap.search([‘UNSEEN’, [ ‘SINCE’ , ‘2015-06-14’ ]], function(err, results){<br>        console.log(‘Debug: search results is ‘ + results);<br>        if(err){<br>          throw err;<br>        }else{<br>          var f = imap.fetch(results, { bodies: ‘’, struct: true });<br>          //接下来对得到的数据处理<br>          //…<br>        }<br>      }<br>    }<br>  }<br>});</pre><br>监听到’message’消息后，通过Mailparset包来解析邮件内容。为了节省内存消耗，通过steam的方式将数据传递给解析器。解析器再将邮件数据存储起来。</p>\n<p><pre>f.on(‘message’, function(msg, seqno){<br>  var mailparser = new MailParser();<br>  console.log(‘Info: Message #%d’, seqno);<br>  var prefix = ‘(#’ + seqno + ‘)’;<br>  //正文内容的处理<br>  msg.on(‘body’, function(stream, info){<br>    console.log(‘Debug: info.which: ‘ + info.which);<br>    if(info.which === ‘TEXT’){<br>      console.log(prefix + ‘Body [%s] found, %d total bytes’, inspect(info.which), info.size);<br>    }<br>    //pipe到mailparse解析器<br>    stream.pipe(mailparser);<br>    var buffer = ‘’,<br>        count = 0;<br>    stream.on(‘data’, function(chunk){<br>      count += chunk.length;<br>      buffer += chunk.toString(‘utf8’);<br>    });<br>    //stream结束，向console发出消息<br>    stream.once(‘end’, function(){<br>      if(info.which !== ‘TEXT’){<br>        console.log(prefix + ‘Parsed header: %s’, inspect(Imap.parseHeader(buffer)));<br>      }else{<br>        console.log(prefix + ‘Body[%s] Finished’, inspect(info.which));<br>      }<br>    });<br>    //解析器将获得的数据存储到磁盘。<br>    mailparser.on(“end”, function(mail){<br>      fs.writeFile(‘msg- ‘ + seqno + ‘-body.html’, mail.html, function(err){<br>        if(err){<br>          throw err;<br>        }<br>        console.log(‘Info: #%d saved!’, seqno);<br>      });<br>      //如果有附件，则存储起来。<br>      if(mail.attachments){<br>        mail.attachments.forEach(function(attachment){<br>            console.log(attachment.fileName);<br>            fs.writeFile(‘msg-‘ + seqno + ‘-‘ + attachment.generatedFileName, attachment.content, function(err){<br>              if(err){<br>                throw err;<br>              }<br>              console.log(‘Info: #%d attachment saved!’, seqno);<br>            });<br>        });<br>      }<br>  });<br>});</pre><br>接下来还需要做的事是将邮件数据聚合，以一封完整的格式存储到MongoDB数据库中。</p>\n"},{"title":"npm","_content":"1.更换npm源为淘宝源\n`npm --registry=https://registry.npm.taobao.org`\n\n2.查看npm包安装路径\n`which node`\n\n3.查看npm配置项\n`npm config list`","source":"_posts/npm.md","raw":"---\ntitle: npm\n---\n1.更换npm源为淘宝源\n`npm --registry=https://registry.npm.taobao.org`\n\n2.查看npm包安装路径\n`which node`\n\n3.查看npm配置项\n`npm config list`","slug":"npm","published":1,"date":"2017-07-21T08:17:28.557Z","updated":"2017-07-21T08:17:57.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000838tzwy463rwp","content":"<p>1.更换npm源为淘宝源<br><code>npm --registry=https://registry.npm.taobao.org</code></p>\n<p>2.查看npm包安装路径<br><code>which node</code></p>\n<p>3.查看npm配置项<br><code>npm config list</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.更换npm源为淘宝源<br><code>npm --registry=https://registry.npm.taobao.org</code></p>\n<p>2.查看npm包安装路径<br><code>which node</code></p>\n<p>3.查看npm配置项<br><code>npm config list</code></p>\n"},{"title":"HTML5","_content":"### 语义化标签\n---\n\n> 用最恰当的HTML元素标记的内容。\n\n优点：\n\n* 提升可访问性\n* SEO\n* 结构清晰，利于维护\n\n通用容器:\n\n* div 块级通用容器\n* span 短语内容无语义容器\n\n`<title></title>`：简短、描述性、唯一（提升搜索引擎排名）。\n\n> 搜索引擎会将title作为判断页面主要内容的指标，有效的title应该包含几个与页面内容密切相关的关键字，建议将title核心内容放在前60个字符中。\n\n`<hn></hn>`：h1~h6分级标题，用于创建页面信息的层级关系。\n\n> 对于搜索引擎而言，如果标题与搜索词匹配，这些标题就会被赋予很高的权重，尤其是h1\n\n`<header></header>`：页眉通常包括网站标志、主导航、全站链接以及搜索框。\n\n> 也适合对页面内部一组介绍性或导航性内容进行标记。\n\n`<nav></nav>`：标记导航，仅对文档中重要的链接群使用。\n\n> Html5规范不推荐对辅助性页脚链接使用nav，除非页脚再次显示顶级全局导航、或者包含招聘信息等重要链接。\n<main></main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。\n\n`<article></article>`：表示文档、页面、应用或一个独立的容器。\n\n> article可以嵌套article，只要里面的article与外面的是部分与整体的关系。\n\n`<section></section>`：具有相似主图的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。\n\n> 如果只是为了添加样式，请用div\n\n`<aside></aside>`：指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。\n\n> 如果放在main内，应该与所在内容密切相关。\n\n`<footer></footer>`：页脚，只有当父级是body时，才是整个页面的页脚。\n\n`<small></small>`：指定细则，输入免责声明、注解、署名、版权。\n\n> 只适用于短语，不要用来不标记“使用条款”，“隐私政策”等长的法律声明。不单纯的样式标签（有意义的，对搜索引擎抓取有强调意义 strong > em > cite）\n\n`<strong></strong>`：表示内容重要性。\n\n`<em></em>`：标记内容着重点（大量用于提升段落文本语义）（斜体）\n\n`<cite></cite>`：指明引用或者参考，如图书的标题，歌曲、电影、等的名称，演唱会、音乐会、规范、报纸、或法律文件等。（斜体）\n\n`<mark></mark>`：突出显示文本（黄色背景颜色），提醒读者\n\n`<figure></figure>`：创建图（默认有40px左右margin）\n\n`<figcaption></figcaption>`：figure的标题，必须是figure内嵌的第一个或者最后一个元素。\n\n`<blockquoto></blockquoto>`：引述文本，默认新的一行显示。\n\n`<time></time>`：标记事件。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。（不再相关的时间用s标签）\n\n`<abbr></abbr>`：解释缩写词。使用title属性可提供全称，只在第一次出现时使用就可以了\n\n`<dfn></dfn>`：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。\n\n`<address></address>`：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）表示一个具体的地址，字体为斜体，会自动换行\n\n`<del></del>`：移除的内容。 <ins></ins>：添加的内容。\n\n> 少有的既可以包围块级，又可以包围短语内容的元素。\n\n`<code></code>`：标记代码。包含示例代码或者文件名 （< < > >）\n\n`<pre></pre>`：预格式化文本。保留文本固有的换行和空格。\n\n`<meter></meter>`：表示分数的值或者已知范围的测量结果。如投票结果。\n\n> 例如：`<meter value=\"0.2\" title=”Miles“>20%completed</meter>`\n\n`<progress></progress>`：完成进度。可通过js动态更新value。\n\n### 标签新属性\n---\n#### 细说data dataset(IE11，火狐谷歌)\n\n> 在HTML5中我们可以使用data-前缀设置我们需要的自定义属性，来进行一些数据的存放。通过dataset来获取这些数据。这里的data-前缀就被称为data属性，其可以通过脚本进行定义，也可以应用CSS属性选择器进行样式设置。数量不受限制，在控制和渲染数据的时候提供了非常强大的控制。\n\n#### 一个实例教你如何使用data dataset\n\n```\n例如我们要在一个文字按钮上存放相对应的id\n\n下面是元素应用data属性的一个例子：\n\n<div id=\"food\" data-drink=\"coffee\" data-food=\"sushi\" data-meal=\"lunch\">¥20.12</div>\n// 要想获取某个属性的值，可以像下面这样使用dataset对象：\nvar food = document.getElementById('food'); \nvar typeOfDrink = food.dataset.drink;\nclassList(火狐谷歌最新，IE10以上)\nobj.classList.add() 添加class类\nobj.classList.remove() 移出class类\nobj.classList.contains() 判断是否包含指定class类\nobj.classList.toggle() 切换class类\nobj.classList.length 获取class类的个数\n```\n#### classList(火狐谷歌最新，IE10以上)\n\n* obj.classList.add() 添加class类\n* obj.classList.remove() 移出class类\n* obj.classList.contains() 判断是否包含指定class类\n* obj.classList.toggle() 切换class类\n* obj.classList.length 获取class类的个数\n\n### HTML5新表单\n---\n#### 新的input类型\nemail\n```\nemail 类型用于应该包含 e-mail 地址的输入域。在提交表单时，会自动验证 email 域的值。\n\nE-mail: <input type=\"email\" name=\"user_email\" />\n```\n\nurl\n```\nurl 类型用于应该包含 URL 地址的输入域。在提交表单时，会自动验证 url 域的值。\n\nHomepage: <input type=\"url\" name=\"user_url\" />\n```\n\nnumber\n```\nnumber 类型用于应该包含数值的输入域。您还能够设定对所接受的数字的限定：\n\nPoints: <input type=\"number\" name=\"points\" min=\"1\" max=\"10\" />\n```\n\nrange\n```\nrange 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。您还能够设定对所接受的数字的限定：\n\n<input type=\"range\" name=\"points\" min=\"1\" max=\"10\" />\n```\n\nsearch\n```\nsearch 类型用于搜索域，比如站点搜索或 Google 搜索。search 域显示为常规的文本域。\n```\n\n#### 新的form属性\n\nautocomplete\n\n```\nautocomplete 属性规定 form 或 input 域应该拥有自动完成功能。\n注释：autocomplete 适用于 <form> 标签，以及以下类型的 <input> 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。\n\n<form action=\"demo_form.asp\" method=\"get\" autocomplete=\"on\">\n    E-mail: <input type=\"email\" name=\"email\" autocomplete=\"off\" />\n</form>\n```\n\nnovalidate\n```\nnovalidate 属性规定在提交表单时不应该验证 form 或 input 域。\n注释：novalidate 属性适用于 <form> 以及以下类型的 <input> 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.\n\n<form action=\"demo_form.asp\" method=\"get\" novalidate=\"true\">\n    E-mail: <input type=\"email\" name=\"user_email\" />\n    <input type=\"submit\" />\n</form>\n```\n\n#### 新的input属性\n\nautocomplete\n\n```\nautocomplete 属性规定 form 或 input 域应该拥有自动完成功能。\n注释：autocomplete 适用于 <form> 标签，以及以下类型的 <input> 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。\n\n<form action=\"demo_form.asp\" method=\"get\" autocomplete=\"on\">\n    E-mail: <input type=\"email\" name=\"email\" autocomplete=\"off\" />\n</form>\n```\n\nautofocus\n\n```\nautofocus 属性规定在页面加载时，域自动地获得焦点。\n注释：autofocus 属性适用于所有 <input> 标签的类型。\n\nUser name: <input type=\"text\" name=\"user_name\"  autofocus=\"autofocus\" />\n```\n\nform\n\n```\nform 属性规定输入域所属的一个或多个表单。\n注释：form 属性适用于所有 <input> 标签的类型。\nform 属性必须引用所属表单的 id：\n\n<form action=\"demo_form.asp\" method=\"get\" id=\"user_form\">\n    First name:<input type=\"text\" name=\"fname\" />\n    <input type=\"submit\" />\n</form>\nLast name: <input type=\"text\" name=\"lname\" form=\"user_form\" />\n```\n\nform overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)\n\n```\n表单重写属性（form override attributes）允许您重写 form 元素的某些属性设定。\n- 表单重写属性有：\n    1. formaction - 重写表单的 action 属性\n    2. formenctype - 重写表单的 enctype 属性\n    3. formmethod - 重写表单的 method 属性\n    4. formnovalidate - 重写表单的 novalidate 属性\n    5. formtarget - 重写表单的 target 属性\n注释：表单重写属性适用于以下类型的 <input> 标签：submit 和 image。\n\n<form action=\"demo_form.asp\" method=\"get\" id=\"user_form\">\nE-mail: <input type=\"email\" name=\"userid\" /><br />\n<input type=\"submit\" value=\"Submit\" />\n<br />\n<input type=\"submit\" formaction=\"demo_admin.asp\" value=\"Submit as admin\" />\n<br />\n<input type=\"submit\" formnovalidate=\"true\" value=\"Submit without validation\" />\n<br />\n</form>\n```\n\n#### height 和 width 属性\n\n```\nheight 和 width 属性规定用于 image 类型的 input 标签的图像高度和宽度。\n注释：height 和 width 属性只适用于 image 类型的 <input> 标签。\n\n<input type=\"image\" src=\"img_submit.gif\" width=\"99\" height=\"99\" />\n```\n\n#### list 属性\n```\nlist 属性规定输入域的 datalist。datalist 是输入域的选项列表。\n注释：list 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email, date pickers, number, range 以及 color。\n\nWebpage: <input type=\"url\" list=\"url_list\" name=\"link\" />\n    <datalist id=\"url_list\">\n    <option label=\"W3Schools\" value=\"http://www.w3school.com.cn\" />\n    <option label=\"Google\" value=\"http://www.google.com\" />\n    <option label=\"Microsoft\" value=\"http://www.microsoft.com\" />\n</datalist>\n```\n\n#### min、max 和 step 属性\n\n```\nmin、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。\nmax 属性规定输入域所允许的最大值。\nmin 属性规定输入域所允许的最小值。\nstep 属性为输入域规定合法的数字间隔（如果 step=\"3\"，则合法的数是 -3,0,3,6 等）。\n注释：min、max 和 step 属性适用于以下类型的 <input> 标签：date pickers、number 以及 range。\n下面的例子显示一个数字域，该域接受介于 0 到 10 之间的值，且步进为 3（即合法的值为 0、3、6 和 9）：\n\nPoints: <input type=\"number\" name=\"points\" min=\"0\" max=\"10\" step=\"3\" />\n```\n\n#### multiple 属性\n\n```\nmultiple 属性规定输入域中可选择多个值。\n注释：multiple 属性适用于以下类型的 <input> 标签：email 和 file。\n\nSelect images: <input type=\"file\" name=\"img\" multiple=\"multiple\" />\n```\n\n#### novalidate 属性\n\n```\nnovalidate 属性规定在提交表单时不应该验证 form 或 input 域。\n注释：novalidate 属性适用于 <form> 以及以下类型的 <input> 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.\n\n<form action=\"demo_form.asp\" method=\"get\" novalidate=\"true\">\n    E-mail: <input type=\"email\" name=\"user_email\" />\n    <input type=\"submit\" />\n</form>\n```\n\n#### pattern 属性\n```\npattern 属性规定用于验证 input 域的模式（pattern）。\n注释：pattern 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email 以及 password。\n下面的例子显示了一个只能包含三个字母的文本域（不含数字及特殊字符）：\n\nCountry code: <input type=\"text\" name=\"country_code\"\npattern=\"[A-z]{3}\" title=\"Three letter country code\" />\n```\n\n#### placeholder 属性\n```\nplaceholder 属性提供一种提示（hint），描述输入域所期待的值。\n注释：placeholder 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email 以及 password。\n提示（hint）会在输入域为空时显示出现，会在输入域获得焦点时消失：\n\n<input type=\"search\" name=\"user_search\"  placeholder=\"Search W3School\" />\n```\n\n#### required 属性\n\n```\nrequired 属性规定必须在提交之前填写输入域（不能为空）。\n注释：required 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。\n\nName: <input type=\"text\" name=\"usr_name\" required=\"required\" />\n```\n\n### 音频(audio)和视频(video)\n---\n\n#### 支持的格式和写法\n\n音频元素支持的3种格式：Ogg MP3 Wav\n```\n<audio controls>\n  <source src=\"horse.ogg\" type=\"audio/ogg\">\n  <source src=\"horse.mp3\" type=\"audio/mpeg\">\n  您的浏览器不支持 audio 元素。\n</audio>\n```\n\n视频元素支持三种视频格式：MP4、WebM、Ogg。\n```\n<video width=\"320\" height=\"240\" controls>\n    <source src=\"movie.mp4\" type=\"video/mp4\">\n    <source src=\"movie.ogg\" type=\"video/ogg\">\n    您的浏览器不支持 video 标签。\n</video>\n```\n\n#### 标签属性\n* 音视频：autoplay、controls、loop、muted、preload、src\n* 视频：autoplay、controls、loop、muted、width、height、poster、preload、src\n\n#### 方法\n* load():重新加载音频／视频元素\n* play()：开始播放音频／视频\n* pause()：暂停当前播放的音频／视频\n\n#### 事件\n* durationchange:当音频/视频的时长已更改时\n* ended:当目前的播放列表已结束时\n* pause:当音频/视频已暂停时\n* play:当音频/视频已开始或不再暂停时\n* ratechange:当音频/视频的播放速度已更改时\n* timeupdate:当目前的播放位置已更改时\n* volumechange:当音量已更改时\n\n#### 事件属性\n1.只读属性\n* duration：返回当前的总时长\n* currentSrc：返回当前URL\n* ended：返回是否已结束\n* paused：返回是否已暂停\n2.获取并可修改的属性：\n* autoplay：设置或返回是否自动播放\n* controls：设置或返回是否显示控件（比如播放/暂停等）\n* loop：设置或返回是否是循环播放\n* muted：设置或返回是否静音\n* currentTime：设置或返回当前播放位置（以秒计）\n* volume：设置或返回音量（规定音频/视频的当前音量。必须是介于 0.0 与 1.0 之间的数字。）1.0 是最高音量（默认）；0.5 是一半音量 （50%）； 0.0 是静音；\n* playbackRate：设置或返回播放速度\n","source":"_posts/html5.md","raw":"---\ntitle: HTML5\n---\n### 语义化标签\n---\n\n> 用最恰当的HTML元素标记的内容。\n\n优点：\n\n* 提升可访问性\n* SEO\n* 结构清晰，利于维护\n\n通用容器:\n\n* div 块级通用容器\n* span 短语内容无语义容器\n\n`<title></title>`：简短、描述性、唯一（提升搜索引擎排名）。\n\n> 搜索引擎会将title作为判断页面主要内容的指标，有效的title应该包含几个与页面内容密切相关的关键字，建议将title核心内容放在前60个字符中。\n\n`<hn></hn>`：h1~h6分级标题，用于创建页面信息的层级关系。\n\n> 对于搜索引擎而言，如果标题与搜索词匹配，这些标题就会被赋予很高的权重，尤其是h1\n\n`<header></header>`：页眉通常包括网站标志、主导航、全站链接以及搜索框。\n\n> 也适合对页面内部一组介绍性或导航性内容进行标记。\n\n`<nav></nav>`：标记导航，仅对文档中重要的链接群使用。\n\n> Html5规范不推荐对辅助性页脚链接使用nav，除非页脚再次显示顶级全局导航、或者包含招聘信息等重要链接。\n<main></main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。\n\n`<article></article>`：表示文档、页面、应用或一个独立的容器。\n\n> article可以嵌套article，只要里面的article与外面的是部分与整体的关系。\n\n`<section></section>`：具有相似主图的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。\n\n> 如果只是为了添加样式，请用div\n\n`<aside></aside>`：指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。\n\n> 如果放在main内，应该与所在内容密切相关。\n\n`<footer></footer>`：页脚，只有当父级是body时，才是整个页面的页脚。\n\n`<small></small>`：指定细则，输入免责声明、注解、署名、版权。\n\n> 只适用于短语，不要用来不标记“使用条款”，“隐私政策”等长的法律声明。不单纯的样式标签（有意义的，对搜索引擎抓取有强调意义 strong > em > cite）\n\n`<strong></strong>`：表示内容重要性。\n\n`<em></em>`：标记内容着重点（大量用于提升段落文本语义）（斜体）\n\n`<cite></cite>`：指明引用或者参考，如图书的标题，歌曲、电影、等的名称，演唱会、音乐会、规范、报纸、或法律文件等。（斜体）\n\n`<mark></mark>`：突出显示文本（黄色背景颜色），提醒读者\n\n`<figure></figure>`：创建图（默认有40px左右margin）\n\n`<figcaption></figcaption>`：figure的标题，必须是figure内嵌的第一个或者最后一个元素。\n\n`<blockquoto></blockquoto>`：引述文本，默认新的一行显示。\n\n`<time></time>`：标记事件。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。（不再相关的时间用s标签）\n\n`<abbr></abbr>`：解释缩写词。使用title属性可提供全称，只在第一次出现时使用就可以了\n\n`<dfn></dfn>`：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。\n\n`<address></address>`：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）表示一个具体的地址，字体为斜体，会自动换行\n\n`<del></del>`：移除的内容。 <ins></ins>：添加的内容。\n\n> 少有的既可以包围块级，又可以包围短语内容的元素。\n\n`<code></code>`：标记代码。包含示例代码或者文件名 （< < > >）\n\n`<pre></pre>`：预格式化文本。保留文本固有的换行和空格。\n\n`<meter></meter>`：表示分数的值或者已知范围的测量结果。如投票结果。\n\n> 例如：`<meter value=\"0.2\" title=”Miles“>20%completed</meter>`\n\n`<progress></progress>`：完成进度。可通过js动态更新value。\n\n### 标签新属性\n---\n#### 细说data dataset(IE11，火狐谷歌)\n\n> 在HTML5中我们可以使用data-前缀设置我们需要的自定义属性，来进行一些数据的存放。通过dataset来获取这些数据。这里的data-前缀就被称为data属性，其可以通过脚本进行定义，也可以应用CSS属性选择器进行样式设置。数量不受限制，在控制和渲染数据的时候提供了非常强大的控制。\n\n#### 一个实例教你如何使用data dataset\n\n```\n例如我们要在一个文字按钮上存放相对应的id\n\n下面是元素应用data属性的一个例子：\n\n<div id=\"food\" data-drink=\"coffee\" data-food=\"sushi\" data-meal=\"lunch\">¥20.12</div>\n// 要想获取某个属性的值，可以像下面这样使用dataset对象：\nvar food = document.getElementById('food'); \nvar typeOfDrink = food.dataset.drink;\nclassList(火狐谷歌最新，IE10以上)\nobj.classList.add() 添加class类\nobj.classList.remove() 移出class类\nobj.classList.contains() 判断是否包含指定class类\nobj.classList.toggle() 切换class类\nobj.classList.length 获取class类的个数\n```\n#### classList(火狐谷歌最新，IE10以上)\n\n* obj.classList.add() 添加class类\n* obj.classList.remove() 移出class类\n* obj.classList.contains() 判断是否包含指定class类\n* obj.classList.toggle() 切换class类\n* obj.classList.length 获取class类的个数\n\n### HTML5新表单\n---\n#### 新的input类型\nemail\n```\nemail 类型用于应该包含 e-mail 地址的输入域。在提交表单时，会自动验证 email 域的值。\n\nE-mail: <input type=\"email\" name=\"user_email\" />\n```\n\nurl\n```\nurl 类型用于应该包含 URL 地址的输入域。在提交表单时，会自动验证 url 域的值。\n\nHomepage: <input type=\"url\" name=\"user_url\" />\n```\n\nnumber\n```\nnumber 类型用于应该包含数值的输入域。您还能够设定对所接受的数字的限定：\n\nPoints: <input type=\"number\" name=\"points\" min=\"1\" max=\"10\" />\n```\n\nrange\n```\nrange 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。您还能够设定对所接受的数字的限定：\n\n<input type=\"range\" name=\"points\" min=\"1\" max=\"10\" />\n```\n\nsearch\n```\nsearch 类型用于搜索域，比如站点搜索或 Google 搜索。search 域显示为常规的文本域。\n```\n\n#### 新的form属性\n\nautocomplete\n\n```\nautocomplete 属性规定 form 或 input 域应该拥有自动完成功能。\n注释：autocomplete 适用于 <form> 标签，以及以下类型的 <input> 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。\n\n<form action=\"demo_form.asp\" method=\"get\" autocomplete=\"on\">\n    E-mail: <input type=\"email\" name=\"email\" autocomplete=\"off\" />\n</form>\n```\n\nnovalidate\n```\nnovalidate 属性规定在提交表单时不应该验证 form 或 input 域。\n注释：novalidate 属性适用于 <form> 以及以下类型的 <input> 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.\n\n<form action=\"demo_form.asp\" method=\"get\" novalidate=\"true\">\n    E-mail: <input type=\"email\" name=\"user_email\" />\n    <input type=\"submit\" />\n</form>\n```\n\n#### 新的input属性\n\nautocomplete\n\n```\nautocomplete 属性规定 form 或 input 域应该拥有自动完成功能。\n注释：autocomplete 适用于 <form> 标签，以及以下类型的 <input> 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。\n\n<form action=\"demo_form.asp\" method=\"get\" autocomplete=\"on\">\n    E-mail: <input type=\"email\" name=\"email\" autocomplete=\"off\" />\n</form>\n```\n\nautofocus\n\n```\nautofocus 属性规定在页面加载时，域自动地获得焦点。\n注释：autofocus 属性适用于所有 <input> 标签的类型。\n\nUser name: <input type=\"text\" name=\"user_name\"  autofocus=\"autofocus\" />\n```\n\nform\n\n```\nform 属性规定输入域所属的一个或多个表单。\n注释：form 属性适用于所有 <input> 标签的类型。\nform 属性必须引用所属表单的 id：\n\n<form action=\"demo_form.asp\" method=\"get\" id=\"user_form\">\n    First name:<input type=\"text\" name=\"fname\" />\n    <input type=\"submit\" />\n</form>\nLast name: <input type=\"text\" name=\"lname\" form=\"user_form\" />\n```\n\nform overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)\n\n```\n表单重写属性（form override attributes）允许您重写 form 元素的某些属性设定。\n- 表单重写属性有：\n    1. formaction - 重写表单的 action 属性\n    2. formenctype - 重写表单的 enctype 属性\n    3. formmethod - 重写表单的 method 属性\n    4. formnovalidate - 重写表单的 novalidate 属性\n    5. formtarget - 重写表单的 target 属性\n注释：表单重写属性适用于以下类型的 <input> 标签：submit 和 image。\n\n<form action=\"demo_form.asp\" method=\"get\" id=\"user_form\">\nE-mail: <input type=\"email\" name=\"userid\" /><br />\n<input type=\"submit\" value=\"Submit\" />\n<br />\n<input type=\"submit\" formaction=\"demo_admin.asp\" value=\"Submit as admin\" />\n<br />\n<input type=\"submit\" formnovalidate=\"true\" value=\"Submit without validation\" />\n<br />\n</form>\n```\n\n#### height 和 width 属性\n\n```\nheight 和 width 属性规定用于 image 类型的 input 标签的图像高度和宽度。\n注释：height 和 width 属性只适用于 image 类型的 <input> 标签。\n\n<input type=\"image\" src=\"img_submit.gif\" width=\"99\" height=\"99\" />\n```\n\n#### list 属性\n```\nlist 属性规定输入域的 datalist。datalist 是输入域的选项列表。\n注释：list 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email, date pickers, number, range 以及 color。\n\nWebpage: <input type=\"url\" list=\"url_list\" name=\"link\" />\n    <datalist id=\"url_list\">\n    <option label=\"W3Schools\" value=\"http://www.w3school.com.cn\" />\n    <option label=\"Google\" value=\"http://www.google.com\" />\n    <option label=\"Microsoft\" value=\"http://www.microsoft.com\" />\n</datalist>\n```\n\n#### min、max 和 step 属性\n\n```\nmin、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。\nmax 属性规定输入域所允许的最大值。\nmin 属性规定输入域所允许的最小值。\nstep 属性为输入域规定合法的数字间隔（如果 step=\"3\"，则合法的数是 -3,0,3,6 等）。\n注释：min、max 和 step 属性适用于以下类型的 <input> 标签：date pickers、number 以及 range。\n下面的例子显示一个数字域，该域接受介于 0 到 10 之间的值，且步进为 3（即合法的值为 0、3、6 和 9）：\n\nPoints: <input type=\"number\" name=\"points\" min=\"0\" max=\"10\" step=\"3\" />\n```\n\n#### multiple 属性\n\n```\nmultiple 属性规定输入域中可选择多个值。\n注释：multiple 属性适用于以下类型的 <input> 标签：email 和 file。\n\nSelect images: <input type=\"file\" name=\"img\" multiple=\"multiple\" />\n```\n\n#### novalidate 属性\n\n```\nnovalidate 属性规定在提交表单时不应该验证 form 或 input 域。\n注释：novalidate 属性适用于 <form> 以及以下类型的 <input> 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.\n\n<form action=\"demo_form.asp\" method=\"get\" novalidate=\"true\">\n    E-mail: <input type=\"email\" name=\"user_email\" />\n    <input type=\"submit\" />\n</form>\n```\n\n#### pattern 属性\n```\npattern 属性规定用于验证 input 域的模式（pattern）。\n注释：pattern 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email 以及 password。\n下面的例子显示了一个只能包含三个字母的文本域（不含数字及特殊字符）：\n\nCountry code: <input type=\"text\" name=\"country_code\"\npattern=\"[A-z]{3}\" title=\"Three letter country code\" />\n```\n\n#### placeholder 属性\n```\nplaceholder 属性提供一种提示（hint），描述输入域所期待的值。\n注释：placeholder 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email 以及 password。\n提示（hint）会在输入域为空时显示出现，会在输入域获得焦点时消失：\n\n<input type=\"search\" name=\"user_search\"  placeholder=\"Search W3School\" />\n```\n\n#### required 属性\n\n```\nrequired 属性规定必须在提交之前填写输入域（不能为空）。\n注释：required 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。\n\nName: <input type=\"text\" name=\"usr_name\" required=\"required\" />\n```\n\n### 音频(audio)和视频(video)\n---\n\n#### 支持的格式和写法\n\n音频元素支持的3种格式：Ogg MP3 Wav\n```\n<audio controls>\n  <source src=\"horse.ogg\" type=\"audio/ogg\">\n  <source src=\"horse.mp3\" type=\"audio/mpeg\">\n  您的浏览器不支持 audio 元素。\n</audio>\n```\n\n视频元素支持三种视频格式：MP4、WebM、Ogg。\n```\n<video width=\"320\" height=\"240\" controls>\n    <source src=\"movie.mp4\" type=\"video/mp4\">\n    <source src=\"movie.ogg\" type=\"video/ogg\">\n    您的浏览器不支持 video 标签。\n</video>\n```\n\n#### 标签属性\n* 音视频：autoplay、controls、loop、muted、preload、src\n* 视频：autoplay、controls、loop、muted、width、height、poster、preload、src\n\n#### 方法\n* load():重新加载音频／视频元素\n* play()：开始播放音频／视频\n* pause()：暂停当前播放的音频／视频\n\n#### 事件\n* durationchange:当音频/视频的时长已更改时\n* ended:当目前的播放列表已结束时\n* pause:当音频/视频已暂停时\n* play:当音频/视频已开始或不再暂停时\n* ratechange:当音频/视频的播放速度已更改时\n* timeupdate:当目前的播放位置已更改时\n* volumechange:当音量已更改时\n\n#### 事件属性\n1.只读属性\n* duration：返回当前的总时长\n* currentSrc：返回当前URL\n* ended：返回是否已结束\n* paused：返回是否已暂停\n2.获取并可修改的属性：\n* autoplay：设置或返回是否自动播放\n* controls：设置或返回是否显示控件（比如播放/暂停等）\n* loop：设置或返回是否是循环播放\n* muted：设置或返回是否静音\n* currentTime：设置或返回当前播放位置（以秒计）\n* volume：设置或返回音量（规定音频/视频的当前音量。必须是介于 0.0 与 1.0 之间的数字。）1.0 是最高音量（默认）；0.5 是一半音量 （50%）； 0.0 是静音；\n* playbackRate：设置或返回播放速度\n","slug":"html5","published":1,"date":"2017-08-07T09:24:23.777Z","updated":"2017-08-07T10:02:32.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsuz000938tzpb609bew","content":"<h3 id=\"语义化标签\"><a href=\"#语义化标签\" class=\"headerlink\" title=\"语义化标签\"></a>语义化标签</h3><hr>\n<blockquote>\n<p>用最恰当的HTML元素标记的内容。</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li>提升可访问性</li>\n<li>SEO</li>\n<li>结构清晰，利于维护</li>\n</ul>\n<p>通用容器:</p>\n<ul>\n<li>div 块级通用容器</li>\n<li>span 短语内容无语义容器</li>\n</ul>\n<p><code>&lt;title&gt;&lt;/title&gt;</code>：简短、描述性、唯一（提升搜索引擎排名）。</p>\n<blockquote>\n<p>搜索引擎会将title作为判断页面主要内容的指标，有效的title应该包含几个与页面内容密切相关的关键字，建议将title核心内容放在前60个字符中。</p>\n</blockquote>\n<p><code>&lt;hn&gt;&lt;/hn&gt;</code>：h1~h6分级标题，用于创建页面信息的层级关系。</p>\n<blockquote>\n<p>对于搜索引擎而言，如果标题与搜索词匹配，这些标题就会被赋予很高的权重，尤其是h1</p>\n</blockquote>\n<p><code>&lt;header&gt;&lt;/header&gt;</code>：页眉通常包括网站标志、主导航、全站链接以及搜索框。</p>\n<blockquote>\n<p>也适合对页面内部一组介绍性或导航性内容进行标记。</p>\n</blockquote>\n<p><code>&lt;nav&gt;&lt;/nav&gt;</code>：标记导航，仅对文档中重要的链接群使用。</p>\n<blockquote>\n<p>Html5规范不推荐对辅助性页脚链接使用nav，除非页脚再次显示顶级全局导航、或者包含招聘信息等重要链接。</p>\n<p><main></main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。</p>\n</blockquote>\n<p><code>&lt;article&gt;&lt;/article&gt;</code>：表示文档、页面、应用或一个独立的容器。</p>\n<blockquote>\n<p>article可以嵌套article，只要里面的article与外面的是部分与整体的关系。</p>\n</blockquote>\n<p><code>&lt;section&gt;&lt;/section&gt;</code>：具有相似主图的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。</p>\n<blockquote>\n<p>如果只是为了添加样式，请用div</p>\n</blockquote>\n<p><code>&lt;aside&gt;&lt;/aside&gt;</code>：指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。</p>\n<blockquote>\n<p>如果放在main内，应该与所在内容密切相关。</p>\n</blockquote>\n<p><code>&lt;footer&gt;&lt;/footer&gt;</code>：页脚，只有当父级是body时，才是整个页面的页脚。</p>\n<p><code>&lt;small&gt;&lt;/small&gt;</code>：指定细则，输入免责声明、注解、署名、版权。</p>\n<blockquote>\n<p>只适用于短语，不要用来不标记“使用条款”，“隐私政策”等长的法律声明。不单纯的样式标签（有意义的，对搜索引擎抓取有强调意义 strong &gt; em &gt; cite）</p>\n</blockquote>\n<p><code>&lt;strong&gt;&lt;/strong&gt;</code>：表示内容重要性。</p>\n<p><code>&lt;em&gt;&lt;/em&gt;</code>：标记内容着重点（大量用于提升段落文本语义）（斜体）</p>\n<p><code>&lt;cite&gt;&lt;/cite&gt;</code>：指明引用或者参考，如图书的标题，歌曲、电影、等的名称，演唱会、音乐会、规范、报纸、或法律文件等。（斜体）</p>\n<p><code>&lt;mark&gt;&lt;/mark&gt;</code>：突出显示文本（黄色背景颜色），提醒读者</p>\n<p><code>&lt;figure&gt;&lt;/figure&gt;</code>：创建图（默认有40px左右margin）</p>\n<p><code>&lt;figcaption&gt;&lt;/figcaption&gt;</code>：figure的标题，必须是figure内嵌的第一个或者最后一个元素。</p>\n<p><code>&lt;blockquoto&gt;&lt;/blockquoto&gt;</code>：引述文本，默认新的一行显示。</p>\n<p><code>&lt;time&gt;&lt;/time&gt;</code>：标记事件。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。（不再相关的时间用s标签）</p>\n<p><code>&lt;abbr&gt;&lt;/abbr&gt;</code>：解释缩写词。使用title属性可提供全称，只在第一次出现时使用就可以了</p>\n<p><code>&lt;dfn&gt;&lt;/dfn&gt;</code>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。</p>\n<p><code>&lt;address&gt;&lt;/address&gt;</code>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）表示一个具体的地址，字体为斜体，会自动换行</p>\n<p><code>&lt;del&gt;&lt;/del&gt;</code>：移除的内容。 <ins></ins>：添加的内容。</p>\n<blockquote>\n<p>少有的既可以包围块级，又可以包围短语内容的元素。</p>\n</blockquote>\n<p><code>&lt;code&gt;&lt;/code&gt;</code>：标记代码。包含示例代码或者文件名 （&lt; &lt; &gt; &gt;）</p>\n<p><code>&lt;pre&gt;&lt;/pre&gt;</code>：预格式化文本。保留文本固有的换行和空格。</p>\n<p><code>&lt;meter&gt;&lt;/meter&gt;</code>：表示分数的值或者已知范围的测量结果。如投票结果。</p>\n<blockquote>\n<p>例如：<code>&lt;meter value=&quot;0.2&quot; title=”Miles“&gt;20%completed&lt;/meter&gt;</code></p>\n</blockquote>\n<p><code>&lt;progress&gt;&lt;/progress&gt;</code>：完成进度。可通过js动态更新value。</p>\n<h3 id=\"标签新属性\"><a href=\"#标签新属性\" class=\"headerlink\" title=\"标签新属性\"></a>标签新属性</h3><hr>\n<h4 id=\"细说data-dataset-IE11，火狐谷歌\"><a href=\"#细说data-dataset-IE11，火狐谷歌\" class=\"headerlink\" title=\"细说data dataset(IE11，火狐谷歌)\"></a>细说data dataset(IE11，火狐谷歌)</h4><blockquote>\n<p>在HTML5中我们可以使用data-前缀设置我们需要的自定义属性，来进行一些数据的存放。通过dataset来获取这些数据。这里的data-前缀就被称为data属性，其可以通过脚本进行定义，也可以应用CSS属性选择器进行样式设置。数量不受限制，在控制和渲染数据的时候提供了非常强大的控制。</p>\n</blockquote>\n<h4 id=\"一个实例教你如何使用data-dataset\"><a href=\"#一个实例教你如何使用data-dataset\" class=\"headerlink\" title=\"一个实例教你如何使用data dataset\"></a>一个实例教你如何使用data dataset</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">例如我们要在一个文字按钮上存放相对应的id</div><div class=\"line\"></div><div class=\"line\">下面是元素应用data属性的一个例子：</div><div class=\"line\"></div><div class=\"line\">&lt;div id=&quot;food&quot; data-drink=&quot;coffee&quot; data-food=&quot;sushi&quot; data-meal=&quot;lunch&quot;&gt;¥20.12&lt;/div&gt;</div><div class=\"line\">// 要想获取某个属性的值，可以像下面这样使用dataset对象：</div><div class=\"line\">var food = document.getElementById(&apos;food&apos;); </div><div class=\"line\">var typeOfDrink = food.dataset.drink;</div><div class=\"line\">classList(火狐谷歌最新，IE10以上)</div><div class=\"line\">obj.classList.add() 添加class类</div><div class=\"line\">obj.classList.remove() 移出class类</div><div class=\"line\">obj.classList.contains() 判断是否包含指定class类</div><div class=\"line\">obj.classList.toggle() 切换class类</div><div class=\"line\">obj.classList.length 获取class类的个数</div></pre></td></tr></table></figure>\n<h4 id=\"classList-火狐谷歌最新，IE10以上\"><a href=\"#classList-火狐谷歌最新，IE10以上\" class=\"headerlink\" title=\"classList(火狐谷歌最新，IE10以上)\"></a>classList(火狐谷歌最新，IE10以上)</h4><ul>\n<li>obj.classList.add() 添加class类</li>\n<li>obj.classList.remove() 移出class类</li>\n<li>obj.classList.contains() 判断是否包含指定class类</li>\n<li>obj.classList.toggle() 切换class类</li>\n<li>obj.classList.length 获取class类的个数</li>\n</ul>\n<h3 id=\"HTML5新表单\"><a href=\"#HTML5新表单\" class=\"headerlink\" title=\"HTML5新表单\"></a>HTML5新表单</h3><hr>\n<h4 id=\"新的input类型\"><a href=\"#新的input类型\" class=\"headerlink\" title=\"新的input类型\"></a>新的input类型</h4><p>email<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">email 类型用于应该包含 e-mail 地址的输入域。在提交表单时，会自动验证 email 域的值。</div><div class=\"line\"></div><div class=\"line\">E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>url<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">url 类型用于应该包含 URL 地址的输入域。在提交表单时，会自动验证 url 域的值。</div><div class=\"line\"></div><div class=\"line\">Homepage: &lt;input type=&quot;url&quot; name=&quot;user_url&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>number<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">number 类型用于应该包含数值的输入域。您还能够设定对所接受的数字的限定：</div><div class=\"line\"></div><div class=\"line\">Points: &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>range<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">range 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。您还能够设定对所接受的数字的限定：</div><div class=\"line\"></div><div class=\"line\">&lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>search<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">search 类型用于搜索域，比如站点搜索或 Google 搜索。search 域显示为常规的文本域。</div></pre></td></tr></table></figure></p>\n<h4 id=\"新的form属性\"><a href=\"#新的form属性\" class=\"headerlink\" title=\"新的form属性\"></a>新的form属性</h4><p>autocomplete</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</div><div class=\"line\">注释：autocomplete 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;</div><div class=\"line\">    E-mail: &lt;input type=&quot;email&quot; name=&quot;email&quot; autocomplete=&quot;off&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p>novalidate<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">novalidate 属性规定在提交表单时不应该验证 form 或 input 域。</div><div class=\"line\">注释：novalidate 属性适用于 &lt;form&gt; 以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</div><div class=\"line\">    E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div><div class=\"line\">    &lt;input type=&quot;submit&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"新的input属性\"><a href=\"#新的input属性\" class=\"headerlink\" title=\"新的input属性\"></a>新的input属性</h4><p>autocomplete</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</div><div class=\"line\">注释：autocomplete 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;</div><div class=\"line\">    E-mail: &lt;input type=&quot;email&quot; name=&quot;email&quot; autocomplete=&quot;off&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p>autofocus</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">autofocus 属性规定在页面加载时，域自动地获得焦点。</div><div class=\"line\">注释：autofocus 属性适用于所有 &lt;input&gt; 标签的类型。</div><div class=\"line\"></div><div class=\"line\">User name: &lt;input type=&quot;text&quot; name=&quot;user_name&quot;  autofocus=&quot;autofocus&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>form</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">form 属性规定输入域所属的一个或多个表单。</div><div class=\"line\">注释：form 属性适用于所有 &lt;input&gt; 标签的类型。</div><div class=\"line\">form 属性必须引用所属表单的 id：</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; id=&quot;user_form&quot;&gt;</div><div class=\"line\">    First name:&lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;</div><div class=\"line\">    &lt;input type=&quot;submit&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; form=&quot;user_form&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">表单重写属性（form override attributes）允许您重写 form 元素的某些属性设定。</div><div class=\"line\">- 表单重写属性有：</div><div class=\"line\">    1. formaction - 重写表单的 action 属性</div><div class=\"line\">    2. formenctype - 重写表单的 enctype 属性</div><div class=\"line\">    3. formmethod - 重写表单的 method 属性</div><div class=\"line\">    4. formnovalidate - 重写表单的 novalidate 属性</div><div class=\"line\">    5. formtarget - 重写表单的 target 属性</div><div class=\"line\">注释：表单重写属性适用于以下类型的 &lt;input&gt; 标签：submit 和 image。</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; id=&quot;user_form&quot;&gt;</div><div class=\"line\">E-mail: &lt;input type=&quot;email&quot; name=&quot;userid&quot; /&gt;&lt;br /&gt;</div><div class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</div><div class=\"line\">&lt;br /&gt;</div><div class=\"line\">&lt;input type=&quot;submit&quot; formaction=&quot;demo_admin.asp&quot; value=&quot;Submit as admin&quot; /&gt;</div><div class=\"line\">&lt;br /&gt;</div><div class=\"line\">&lt;input type=&quot;submit&quot; formnovalidate=&quot;true&quot; value=&quot;Submit without validation&quot; /&gt;</div><div class=\"line\">&lt;br /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"height-和-width-属性\"><a href=\"#height-和-width-属性\" class=\"headerlink\" title=\"height 和 width 属性\"></a>height 和 width 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">height 和 width 属性规定用于 image 类型的 input 标签的图像高度和宽度。</div><div class=\"line\">注释：height 和 width 属性只适用于 image 类型的 &lt;input&gt; 标签。</div><div class=\"line\"></div><div class=\"line\">&lt;input type=&quot;image&quot; src=&quot;img_submit.gif&quot; width=&quot;99&quot; height=&quot;99&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"list-属性\"><a href=\"#list-属性\" class=\"headerlink\" title=\"list 属性\"></a>list 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">list 属性规定输入域的 datalist。datalist 是输入域的选项列表。</div><div class=\"line\">注释：list 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, date pickers, number, range 以及 color。</div><div class=\"line\"></div><div class=\"line\">Webpage: &lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;link&quot; /&gt;</div><div class=\"line\">    &lt;datalist id=&quot;url_list&quot;&gt;</div><div class=\"line\">    &lt;option label=&quot;W3Schools&quot; value=&quot;http://www.w3school.com.cn&quot; /&gt;</div><div class=\"line\">    &lt;option label=&quot;Google&quot; value=&quot;http://www.google.com&quot; /&gt;</div><div class=\"line\">    &lt;option label=&quot;Microsoft&quot; value=&quot;http://www.microsoft.com&quot; /&gt;</div><div class=\"line\">&lt;/datalist&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"min、max-和-step-属性\"><a href=\"#min、max-和-step-属性\" class=\"headerlink\" title=\"min、max 和 step 属性\"></a>min、max 和 step 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">min、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。</div><div class=\"line\">max 属性规定输入域所允许的最大值。</div><div class=\"line\">min 属性规定输入域所允许的最小值。</div><div class=\"line\">step 属性为输入域规定合法的数字间隔（如果 step=&quot;3&quot;，则合法的数是 -3,0,3,6 等）。</div><div class=\"line\">注释：min、max 和 step 属性适用于以下类型的 &lt;input&gt; 标签：date pickers、number 以及 range。</div><div class=\"line\">下面的例子显示一个数字域，该域接受介于 0 到 10 之间的值，且步进为 3（即合法的值为 0、3、6 和 9）：</div><div class=\"line\"></div><div class=\"line\">Points: &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;3&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"multiple-属性\"><a href=\"#multiple-属性\" class=\"headerlink\" title=\"multiple 属性\"></a>multiple 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">multiple 属性规定输入域中可选择多个值。</div><div class=\"line\">注释：multiple 属性适用于以下类型的 &lt;input&gt; 标签：email 和 file。</div><div class=\"line\"></div><div class=\"line\">Select images: &lt;input type=&quot;file&quot; name=&quot;img&quot; multiple=&quot;multiple&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"novalidate-属性\"><a href=\"#novalidate-属性\" class=\"headerlink\" title=\"novalidate 属性\"></a>novalidate 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">novalidate 属性规定在提交表单时不应该验证 form 或 input 域。</div><div class=\"line\">注释：novalidate 属性适用于 &lt;form&gt; 以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</div><div class=\"line\">    E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div><div class=\"line\">    &lt;input type=&quot;submit&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"pattern-属性\"><a href=\"#pattern-属性\" class=\"headerlink\" title=\"pattern 属性\"></a>pattern 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">pattern 属性规定用于验证 input 域的模式（pattern）。</div><div class=\"line\">注释：pattern 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email 以及 password。</div><div class=\"line\">下面的例子显示了一个只能包含三个字母的文本域（不含数字及特殊字符）：</div><div class=\"line\"></div><div class=\"line\">Country code: &lt;input type=&quot;text&quot; name=&quot;country_code&quot;</div><div class=\"line\">pattern=&quot;[A-z]&#123;3&#125;&quot; title=&quot;Three letter country code&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"placeholder-属性\"><a href=\"#placeholder-属性\" class=\"headerlink\" title=\"placeholder 属性\"></a>placeholder 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">placeholder 属性提供一种提示（hint），描述输入域所期待的值。</div><div class=\"line\">注释：placeholder 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email 以及 password。</div><div class=\"line\">提示（hint）会在输入域为空时显示出现，会在输入域获得焦点时消失：</div><div class=\"line\"></div><div class=\"line\">&lt;input type=&quot;search&quot; name=&quot;user_search&quot;  placeholder=&quot;Search W3School&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"required-属性\"><a href=\"#required-属性\" class=\"headerlink\" title=\"required 属性\"></a>required 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">required 属性规定必须在提交之前填写输入域（不能为空）。</div><div class=\"line\">注释：required 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。</div><div class=\"line\"></div><div class=\"line\">Name: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; required=&quot;required&quot; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"音频-audio-和视频-video\"><a href=\"#音频-audio-和视频-video\" class=\"headerlink\" title=\"音频(audio)和视频(video)\"></a>音频(audio)和视频(video)</h3><hr>\n<h4 id=\"支持的格式和写法\"><a href=\"#支持的格式和写法\" class=\"headerlink\" title=\"支持的格式和写法\"></a>支持的格式和写法</h4><p>音频元素支持的3种格式：Ogg MP3 Wav<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;audio controls&gt;</div><div class=\"line\">  &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt;</div><div class=\"line\">  &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;</div><div class=\"line\">  您的浏览器不支持 audio 元素。</div><div class=\"line\">&lt;/audio&gt;</div></pre></td></tr></table></figure></p>\n<p>视频元素支持三种视频格式：MP4、WebM、Ogg。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;</div><div class=\"line\">    &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</div><div class=\"line\">    &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</div><div class=\"line\">    您的浏览器不支持 video 标签。</div><div class=\"line\">&lt;/video&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"标签属性\"><a href=\"#标签属性\" class=\"headerlink\" title=\"标签属性\"></a>标签属性</h4><ul>\n<li>音视频：autoplay、controls、loop、muted、preload、src</li>\n<li>视频：autoplay、controls、loop、muted、width、height、poster、preload、src</li>\n</ul>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>load():重新加载音频／视频元素</li>\n<li>play()：开始播放音频／视频</li>\n<li>pause()：暂停当前播放的音频／视频</li>\n</ul>\n<h4 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h4><ul>\n<li>durationchange:当音频/视频的时长已更改时</li>\n<li>ended:当目前的播放列表已结束时</li>\n<li>pause:当音频/视频已暂停时</li>\n<li>play:当音频/视频已开始或不再暂停时</li>\n<li>ratechange:当音频/视频的播放速度已更改时</li>\n<li>timeupdate:当目前的播放位置已更改时</li>\n<li>volumechange:当音量已更改时</li>\n</ul>\n<h4 id=\"事件属性\"><a href=\"#事件属性\" class=\"headerlink\" title=\"事件属性\"></a>事件属性</h4><p>1.只读属性</p>\n<ul>\n<li>duration：返回当前的总时长</li>\n<li>currentSrc：返回当前URL</li>\n<li>ended：返回是否已结束</li>\n<li>paused：返回是否已暂停<br>2.获取并可修改的属性：</li>\n<li>autoplay：设置或返回是否自动播放</li>\n<li>controls：设置或返回是否显示控件（比如播放/暂停等）</li>\n<li>loop：设置或返回是否是循环播放</li>\n<li>muted：设置或返回是否静音</li>\n<li>currentTime：设置或返回当前播放位置（以秒计）</li>\n<li>volume：设置或返回音量（规定音频/视频的当前音量。必须是介于 0.0 与 1.0 之间的数字。）1.0 是最高音量（默认）；0.5 是一半音量 （50%）； 0.0 是静音；</li>\n<li>playbackRate：设置或返回播放速度</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"语义化标签\"><a href=\"#语义化标签\" class=\"headerlink\" title=\"语义化标签\"></a>语义化标签</h3><hr>\n<blockquote>\n<p>用最恰当的HTML元素标记的内容。</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li>提升可访问性</li>\n<li>SEO</li>\n<li>结构清晰，利于维护</li>\n</ul>\n<p>通用容器:</p>\n<ul>\n<li>div 块级通用容器</li>\n<li>span 短语内容无语义容器</li>\n</ul>\n<p><code>&lt;title&gt;&lt;/title&gt;</code>：简短、描述性、唯一（提升搜索引擎排名）。</p>\n<blockquote>\n<p>搜索引擎会将title作为判断页面主要内容的指标，有效的title应该包含几个与页面内容密切相关的关键字，建议将title核心内容放在前60个字符中。</p>\n</blockquote>\n<p><code>&lt;hn&gt;&lt;/hn&gt;</code>：h1~h6分级标题，用于创建页面信息的层级关系。</p>\n<blockquote>\n<p>对于搜索引擎而言，如果标题与搜索词匹配，这些标题就会被赋予很高的权重，尤其是h1</p>\n</blockquote>\n<p><code>&lt;header&gt;&lt;/header&gt;</code>：页眉通常包括网站标志、主导航、全站链接以及搜索框。</p>\n<blockquote>\n<p>也适合对页面内部一组介绍性或导航性内容进行标记。</p>\n</blockquote>\n<p><code>&lt;nav&gt;&lt;/nav&gt;</code>：标记导航，仅对文档中重要的链接群使用。</p>\n<blockquote>\n<p>Html5规范不推荐对辅助性页脚链接使用nav，除非页脚再次显示顶级全局导航、或者包含招聘信息等重要链接。</p>\n<p><main></main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。</p>\n</blockquote>\n<p><code>&lt;article&gt;&lt;/article&gt;</code>：表示文档、页面、应用或一个独立的容器。</p>\n<blockquote>\n<p>article可以嵌套article，只要里面的article与外面的是部分与整体的关系。</p>\n</blockquote>\n<p><code>&lt;section&gt;&lt;/section&gt;</code>：具有相似主图的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。</p>\n<blockquote>\n<p>如果只是为了添加样式，请用div</p>\n</blockquote>\n<p><code>&lt;aside&gt;&lt;/aside&gt;</code>：指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。</p>\n<blockquote>\n<p>如果放在main内，应该与所在内容密切相关。</p>\n</blockquote>\n<p><code>&lt;footer&gt;&lt;/footer&gt;</code>：页脚，只有当父级是body时，才是整个页面的页脚。</p>\n<p><code>&lt;small&gt;&lt;/small&gt;</code>：指定细则，输入免责声明、注解、署名、版权。</p>\n<blockquote>\n<p>只适用于短语，不要用来不标记“使用条款”，“隐私政策”等长的法律声明。不单纯的样式标签（有意义的，对搜索引擎抓取有强调意义 strong &gt; em &gt; cite）</p>\n</blockquote>\n<p><code>&lt;strong&gt;&lt;/strong&gt;</code>：表示内容重要性。</p>\n<p><code>&lt;em&gt;&lt;/em&gt;</code>：标记内容着重点（大量用于提升段落文本语义）（斜体）</p>\n<p><code>&lt;cite&gt;&lt;/cite&gt;</code>：指明引用或者参考，如图书的标题，歌曲、电影、等的名称，演唱会、音乐会、规范、报纸、或法律文件等。（斜体）</p>\n<p><code>&lt;mark&gt;&lt;/mark&gt;</code>：突出显示文本（黄色背景颜色），提醒读者</p>\n<p><code>&lt;figure&gt;&lt;/figure&gt;</code>：创建图（默认有40px左右margin）</p>\n<p><code>&lt;figcaption&gt;&lt;/figcaption&gt;</code>：figure的标题，必须是figure内嵌的第一个或者最后一个元素。</p>\n<p><code>&lt;blockquoto&gt;&lt;/blockquoto&gt;</code>：引述文本，默认新的一行显示。</p>\n<p><code>&lt;time&gt;&lt;/time&gt;</code>：标记事件。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。（不再相关的时间用s标签）</p>\n<p><code>&lt;abbr&gt;&lt;/abbr&gt;</code>：解释缩写词。使用title属性可提供全称，只在第一次出现时使用就可以了</p>\n<p><code>&lt;dfn&gt;&lt;/dfn&gt;</code>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。</p>\n<p><code>&lt;address&gt;&lt;/address&gt;</code>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）表示一个具体的地址，字体为斜体，会自动换行</p>\n<p><code>&lt;del&gt;&lt;/del&gt;</code>：移除的内容。 <ins></ins>：添加的内容。</p>\n<blockquote>\n<p>少有的既可以包围块级，又可以包围短语内容的元素。</p>\n</blockquote>\n<p><code>&lt;code&gt;&lt;/code&gt;</code>：标记代码。包含示例代码或者文件名 （&lt; &lt; &gt; &gt;）</p>\n<p><code>&lt;pre&gt;&lt;/pre&gt;</code>：预格式化文本。保留文本固有的换行和空格。</p>\n<p><code>&lt;meter&gt;&lt;/meter&gt;</code>：表示分数的值或者已知范围的测量结果。如投票结果。</p>\n<blockquote>\n<p>例如：<code>&lt;meter value=&quot;0.2&quot; title=”Miles“&gt;20%completed&lt;/meter&gt;</code></p>\n</blockquote>\n<p><code>&lt;progress&gt;&lt;/progress&gt;</code>：完成进度。可通过js动态更新value。</p>\n<h3 id=\"标签新属性\"><a href=\"#标签新属性\" class=\"headerlink\" title=\"标签新属性\"></a>标签新属性</h3><hr>\n<h4 id=\"细说data-dataset-IE11，火狐谷歌\"><a href=\"#细说data-dataset-IE11，火狐谷歌\" class=\"headerlink\" title=\"细说data dataset(IE11，火狐谷歌)\"></a>细说data dataset(IE11，火狐谷歌)</h4><blockquote>\n<p>在HTML5中我们可以使用data-前缀设置我们需要的自定义属性，来进行一些数据的存放。通过dataset来获取这些数据。这里的data-前缀就被称为data属性，其可以通过脚本进行定义，也可以应用CSS属性选择器进行样式设置。数量不受限制，在控制和渲染数据的时候提供了非常强大的控制。</p>\n</blockquote>\n<h4 id=\"一个实例教你如何使用data-dataset\"><a href=\"#一个实例教你如何使用data-dataset\" class=\"headerlink\" title=\"一个实例教你如何使用data dataset\"></a>一个实例教你如何使用data dataset</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">例如我们要在一个文字按钮上存放相对应的id</div><div class=\"line\"></div><div class=\"line\">下面是元素应用data属性的一个例子：</div><div class=\"line\"></div><div class=\"line\">&lt;div id=&quot;food&quot; data-drink=&quot;coffee&quot; data-food=&quot;sushi&quot; data-meal=&quot;lunch&quot;&gt;¥20.12&lt;/div&gt;</div><div class=\"line\">// 要想获取某个属性的值，可以像下面这样使用dataset对象：</div><div class=\"line\">var food = document.getElementById(&apos;food&apos;); </div><div class=\"line\">var typeOfDrink = food.dataset.drink;</div><div class=\"line\">classList(火狐谷歌最新，IE10以上)</div><div class=\"line\">obj.classList.add() 添加class类</div><div class=\"line\">obj.classList.remove() 移出class类</div><div class=\"line\">obj.classList.contains() 判断是否包含指定class类</div><div class=\"line\">obj.classList.toggle() 切换class类</div><div class=\"line\">obj.classList.length 获取class类的个数</div></pre></td></tr></table></figure>\n<h4 id=\"classList-火狐谷歌最新，IE10以上\"><a href=\"#classList-火狐谷歌最新，IE10以上\" class=\"headerlink\" title=\"classList(火狐谷歌最新，IE10以上)\"></a>classList(火狐谷歌最新，IE10以上)</h4><ul>\n<li>obj.classList.add() 添加class类</li>\n<li>obj.classList.remove() 移出class类</li>\n<li>obj.classList.contains() 判断是否包含指定class类</li>\n<li>obj.classList.toggle() 切换class类</li>\n<li>obj.classList.length 获取class类的个数</li>\n</ul>\n<h3 id=\"HTML5新表单\"><a href=\"#HTML5新表单\" class=\"headerlink\" title=\"HTML5新表单\"></a>HTML5新表单</h3><hr>\n<h4 id=\"新的input类型\"><a href=\"#新的input类型\" class=\"headerlink\" title=\"新的input类型\"></a>新的input类型</h4><p>email<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">email 类型用于应该包含 e-mail 地址的输入域。在提交表单时，会自动验证 email 域的值。</div><div class=\"line\"></div><div class=\"line\">E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>url<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">url 类型用于应该包含 URL 地址的输入域。在提交表单时，会自动验证 url 域的值。</div><div class=\"line\"></div><div class=\"line\">Homepage: &lt;input type=&quot;url&quot; name=&quot;user_url&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>number<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">number 类型用于应该包含数值的输入域。您还能够设定对所接受的数字的限定：</div><div class=\"line\"></div><div class=\"line\">Points: &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>range<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">range 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。您还能够设定对所接受的数字的限定：</div><div class=\"line\"></div><div class=\"line\">&lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>search<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">search 类型用于搜索域，比如站点搜索或 Google 搜索。search 域显示为常规的文本域。</div></pre></td></tr></table></figure></p>\n<h4 id=\"新的form属性\"><a href=\"#新的form属性\" class=\"headerlink\" title=\"新的form属性\"></a>新的form属性</h4><p>autocomplete</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</div><div class=\"line\">注释：autocomplete 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;</div><div class=\"line\">    E-mail: &lt;input type=&quot;email&quot; name=&quot;email&quot; autocomplete=&quot;off&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p>novalidate<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">novalidate 属性规定在提交表单时不应该验证 form 或 input 域。</div><div class=\"line\">注释：novalidate 属性适用于 &lt;form&gt; 以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</div><div class=\"line\">    E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div><div class=\"line\">    &lt;input type=&quot;submit&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"新的input属性\"><a href=\"#新的input属性\" class=\"headerlink\" title=\"新的input属性\"></a>新的input属性</h4><p>autocomplete</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</div><div class=\"line\">注释：autocomplete 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;</div><div class=\"line\">    E-mail: &lt;input type=&quot;email&quot; name=&quot;email&quot; autocomplete=&quot;off&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p>autofocus</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">autofocus 属性规定在页面加载时，域自动地获得焦点。</div><div class=\"line\">注释：autofocus 属性适用于所有 &lt;input&gt; 标签的类型。</div><div class=\"line\"></div><div class=\"line\">User name: &lt;input type=&quot;text&quot; name=&quot;user_name&quot;  autofocus=&quot;autofocus&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>form</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">form 属性规定输入域所属的一个或多个表单。</div><div class=\"line\">注释：form 属性适用于所有 &lt;input&gt; 标签的类型。</div><div class=\"line\">form 属性必须引用所属表单的 id：</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; id=&quot;user_form&quot;&gt;</div><div class=\"line\">    First name:&lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;</div><div class=\"line\">    &lt;input type=&quot;submit&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; form=&quot;user_form&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">表单重写属性（form override attributes）允许您重写 form 元素的某些属性设定。</div><div class=\"line\">- 表单重写属性有：</div><div class=\"line\">    1. formaction - 重写表单的 action 属性</div><div class=\"line\">    2. formenctype - 重写表单的 enctype 属性</div><div class=\"line\">    3. formmethod - 重写表单的 method 属性</div><div class=\"line\">    4. formnovalidate - 重写表单的 novalidate 属性</div><div class=\"line\">    5. formtarget - 重写表单的 target 属性</div><div class=\"line\">注释：表单重写属性适用于以下类型的 &lt;input&gt; 标签：submit 和 image。</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; id=&quot;user_form&quot;&gt;</div><div class=\"line\">E-mail: &lt;input type=&quot;email&quot; name=&quot;userid&quot; /&gt;&lt;br /&gt;</div><div class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</div><div class=\"line\">&lt;br /&gt;</div><div class=\"line\">&lt;input type=&quot;submit&quot; formaction=&quot;demo_admin.asp&quot; value=&quot;Submit as admin&quot; /&gt;</div><div class=\"line\">&lt;br /&gt;</div><div class=\"line\">&lt;input type=&quot;submit&quot; formnovalidate=&quot;true&quot; value=&quot;Submit without validation&quot; /&gt;</div><div class=\"line\">&lt;br /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"height-和-width-属性\"><a href=\"#height-和-width-属性\" class=\"headerlink\" title=\"height 和 width 属性\"></a>height 和 width 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">height 和 width 属性规定用于 image 类型的 input 标签的图像高度和宽度。</div><div class=\"line\">注释：height 和 width 属性只适用于 image 类型的 &lt;input&gt; 标签。</div><div class=\"line\"></div><div class=\"line\">&lt;input type=&quot;image&quot; src=&quot;img_submit.gif&quot; width=&quot;99&quot; height=&quot;99&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"list-属性\"><a href=\"#list-属性\" class=\"headerlink\" title=\"list 属性\"></a>list 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">list 属性规定输入域的 datalist。datalist 是输入域的选项列表。</div><div class=\"line\">注释：list 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, date pickers, number, range 以及 color。</div><div class=\"line\"></div><div class=\"line\">Webpage: &lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;link&quot; /&gt;</div><div class=\"line\">    &lt;datalist id=&quot;url_list&quot;&gt;</div><div class=\"line\">    &lt;option label=&quot;W3Schools&quot; value=&quot;http://www.w3school.com.cn&quot; /&gt;</div><div class=\"line\">    &lt;option label=&quot;Google&quot; value=&quot;http://www.google.com&quot; /&gt;</div><div class=\"line\">    &lt;option label=&quot;Microsoft&quot; value=&quot;http://www.microsoft.com&quot; /&gt;</div><div class=\"line\">&lt;/datalist&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"min、max-和-step-属性\"><a href=\"#min、max-和-step-属性\" class=\"headerlink\" title=\"min、max 和 step 属性\"></a>min、max 和 step 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">min、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。</div><div class=\"line\">max 属性规定输入域所允许的最大值。</div><div class=\"line\">min 属性规定输入域所允许的最小值。</div><div class=\"line\">step 属性为输入域规定合法的数字间隔（如果 step=&quot;3&quot;，则合法的数是 -3,0,3,6 等）。</div><div class=\"line\">注释：min、max 和 step 属性适用于以下类型的 &lt;input&gt; 标签：date pickers、number 以及 range。</div><div class=\"line\">下面的例子显示一个数字域，该域接受介于 0 到 10 之间的值，且步进为 3（即合法的值为 0、3、6 和 9）：</div><div class=\"line\"></div><div class=\"line\">Points: &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;3&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"multiple-属性\"><a href=\"#multiple-属性\" class=\"headerlink\" title=\"multiple 属性\"></a>multiple 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">multiple 属性规定输入域中可选择多个值。</div><div class=\"line\">注释：multiple 属性适用于以下类型的 &lt;input&gt; 标签：email 和 file。</div><div class=\"line\"></div><div class=\"line\">Select images: &lt;input type=&quot;file&quot; name=&quot;img&quot; multiple=&quot;multiple&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"novalidate-属性\"><a href=\"#novalidate-属性\" class=\"headerlink\" title=\"novalidate 属性\"></a>novalidate 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">novalidate 属性规定在提交表单时不应该验证 form 或 input 域。</div><div class=\"line\">注释：novalidate 属性适用于 &lt;form&gt; 以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</div><div class=\"line\">    E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div><div class=\"line\">    &lt;input type=&quot;submit&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"pattern-属性\"><a href=\"#pattern-属性\" class=\"headerlink\" title=\"pattern 属性\"></a>pattern 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">pattern 属性规定用于验证 input 域的模式（pattern）。</div><div class=\"line\">注释：pattern 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email 以及 password。</div><div class=\"line\">下面的例子显示了一个只能包含三个字母的文本域（不含数字及特殊字符）：</div><div class=\"line\"></div><div class=\"line\">Country code: &lt;input type=&quot;text&quot; name=&quot;country_code&quot;</div><div class=\"line\">pattern=&quot;[A-z]&#123;3&#125;&quot; title=&quot;Three letter country code&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"placeholder-属性\"><a href=\"#placeholder-属性\" class=\"headerlink\" title=\"placeholder 属性\"></a>placeholder 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">placeholder 属性提供一种提示（hint），描述输入域所期待的值。</div><div class=\"line\">注释：placeholder 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email 以及 password。</div><div class=\"line\">提示（hint）会在输入域为空时显示出现，会在输入域获得焦点时消失：</div><div class=\"line\"></div><div class=\"line\">&lt;input type=&quot;search&quot; name=&quot;user_search&quot;  placeholder=&quot;Search W3School&quot; /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"required-属性\"><a href=\"#required-属性\" class=\"headerlink\" title=\"required 属性\"></a>required 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">required 属性规定必须在提交之前填写输入域（不能为空）。</div><div class=\"line\">注释：required 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。</div><div class=\"line\"></div><div class=\"line\">Name: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; required=&quot;required&quot; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"音频-audio-和视频-video\"><a href=\"#音频-audio-和视频-video\" class=\"headerlink\" title=\"音频(audio)和视频(video)\"></a>音频(audio)和视频(video)</h3><hr>\n<h4 id=\"支持的格式和写法\"><a href=\"#支持的格式和写法\" class=\"headerlink\" title=\"支持的格式和写法\"></a>支持的格式和写法</h4><p>音频元素支持的3种格式：Ogg MP3 Wav<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;audio controls&gt;</div><div class=\"line\">  &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt;</div><div class=\"line\">  &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;</div><div class=\"line\">  您的浏览器不支持 audio 元素。</div><div class=\"line\">&lt;/audio&gt;</div></pre></td></tr></table></figure></p>\n<p>视频元素支持三种视频格式：MP4、WebM、Ogg。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;</div><div class=\"line\">    &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</div><div class=\"line\">    &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</div><div class=\"line\">    您的浏览器不支持 video 标签。</div><div class=\"line\">&lt;/video&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"标签属性\"><a href=\"#标签属性\" class=\"headerlink\" title=\"标签属性\"></a>标签属性</h4><ul>\n<li>音视频：autoplay、controls、loop、muted、preload、src</li>\n<li>视频：autoplay、controls、loop、muted、width、height、poster、preload、src</li>\n</ul>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>load():重新加载音频／视频元素</li>\n<li>play()：开始播放音频／视频</li>\n<li>pause()：暂停当前播放的音频／视频</li>\n</ul>\n<h4 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h4><ul>\n<li>durationchange:当音频/视频的时长已更改时</li>\n<li>ended:当目前的播放列表已结束时</li>\n<li>pause:当音频/视频已暂停时</li>\n<li>play:当音频/视频已开始或不再暂停时</li>\n<li>ratechange:当音频/视频的播放速度已更改时</li>\n<li>timeupdate:当目前的播放位置已更改时</li>\n<li>volumechange:当音量已更改时</li>\n</ul>\n<h4 id=\"事件属性\"><a href=\"#事件属性\" class=\"headerlink\" title=\"事件属性\"></a>事件属性</h4><p>1.只读属性</p>\n<ul>\n<li>duration：返回当前的总时长</li>\n<li>currentSrc：返回当前URL</li>\n<li>ended：返回是否已结束</li>\n<li>paused：返回是否已暂停<br>2.获取并可修改的属性：</li>\n<li>autoplay：设置或返回是否自动播放</li>\n<li>controls：设置或返回是否显示控件（比如播放/暂停等）</li>\n<li>loop：设置或返回是否是循环播放</li>\n<li>muted：设置或返回是否静音</li>\n<li>currentTime：设置或返回当前播放位置（以秒计）</li>\n<li>volume：设置或返回音量（规定音频/视频的当前音量。必须是介于 0.0 与 1.0 之间的数字。）1.0 是最高音量（默认）；0.5 是一半音量 （50%）； 0.0 是静音；</li>\n<li>playbackRate：设置或返回播放速度</li>\n</ul>\n"},{"title":"JSON","_content":"**JSON.parse()和JSON.stringify()**\n\n1. JSON.parse(string[, translator]) 将字符串转换为JSON对象\n\n示例代码：\n```\nvar str = '{\"name\":\"叶德华\",\"age\":23}';\nstr = JSON.parse(str);\n```\n\n2. JSON.stringify(object[, replacer[, space]])  将JSON对象转为字符串\n\n> 参数：\n\n> object：是要转为字符串的JSON对象。\n\n> replacer：可选，可以是改变字符串转换过程的函数，也可以是一组String和Number对象，这些对象用作一个白名单，用于选择要转换为字符串的对象的属性。如果这个值是空或没有提供，则在所得的JSON字符串中包含对象的所有属性。\n\n> space参数：可选，是一个String或Number对象，用于把空白插入输出的JSON字符串，以提高可读性。如果这是一个数值，则表示用作空白的空格字符数；如果该数值大于10，就取其值为10；小于1的值表示不应使用空格。如果这是一个字符串（如果该字符串多于10个字符，就取前10个字符），就把该字符串用作空白。如果没有提供这个参数（或者为空），就不使用空白。\n\n示例代码：\n```\nvar str = '{\"name\":\"叶德华\",\"age\":23}';\nstr = JSON.parse(str);\nconsole.info(JSON.stringify(str));\nconsole.info(JSON.stringify(str,null,5));\nconsole.info(JSON.stringify(str,[\"name\"],5));\nconsole.info(JSON.stringify(str,null,\"###\"));\n```","source":"_posts/json.md","raw":"---\ntitle: JSON\n---\n**JSON.parse()和JSON.stringify()**\n\n1. JSON.parse(string[, translator]) 将字符串转换为JSON对象\n\n示例代码：\n```\nvar str = '{\"name\":\"叶德华\",\"age\":23}';\nstr = JSON.parse(str);\n```\n\n2. JSON.stringify(object[, replacer[, space]])  将JSON对象转为字符串\n\n> 参数：\n\n> object：是要转为字符串的JSON对象。\n\n> replacer：可选，可以是改变字符串转换过程的函数，也可以是一组String和Number对象，这些对象用作一个白名单，用于选择要转换为字符串的对象的属性。如果这个值是空或没有提供，则在所得的JSON字符串中包含对象的所有属性。\n\n> space参数：可选，是一个String或Number对象，用于把空白插入输出的JSON字符串，以提高可读性。如果这是一个数值，则表示用作空白的空格字符数；如果该数值大于10，就取其值为10；小于1的值表示不应使用空格。如果这是一个字符串（如果该字符串多于10个字符，就取前10个字符），就把该字符串用作空白。如果没有提供这个参数（或者为空），就不使用空白。\n\n示例代码：\n```\nvar str = '{\"name\":\"叶德华\",\"age\":23}';\nstr = JSON.parse(str);\nconsole.info(JSON.stringify(str));\nconsole.info(JSON.stringify(str,null,5));\nconsole.info(JSON.stringify(str,[\"name\"],5));\nconsole.info(JSON.stringify(str,null,\"###\"));\n```","slug":"json","published":1,"date":"2017-07-21T08:13:44.329Z","updated":"2017-07-21T08:14:11.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsvf000a38tzqx4joxvm","content":"<p><strong>JSON.parse()和JSON.stringify()</strong></p>\n<ol>\n<li>JSON.parse(string[, translator]) 将字符串转换为JSON对象</li>\n</ol>\n<p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &apos;&#123;&quot;name&quot;:&quot;叶德华&quot;,&quot;age&quot;:23&#125;&apos;;</div><div class=\"line\">str = JSON.parse(str);</div></pre></td></tr></table></figure></p>\n<ol>\n<li>JSON.stringify(object[, replacer[, space]])  将JSON对象转为字符串</li>\n</ol>\n<blockquote>\n<p>参数：</p>\n<p>object：是要转为字符串的JSON对象。</p>\n<p>replacer：可选，可以是改变字符串转换过程的函数，也可以是一组String和Number对象，这些对象用作一个白名单，用于选择要转换为字符串的对象的属性。如果这个值是空或没有提供，则在所得的JSON字符串中包含对象的所有属性。</p>\n<p>space参数：可选，是一个String或Number对象，用于把空白插入输出的JSON字符串，以提高可读性。如果这是一个数值，则表示用作空白的空格字符数；如果该数值大于10，就取其值为10；小于1的值表示不应使用空格。如果这是一个字符串（如果该字符串多于10个字符，就取前10个字符），就把该字符串用作空白。如果没有提供这个参数（或者为空），就不使用空白。</p>\n</blockquote>\n<p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &apos;&#123;&quot;name&quot;:&quot;叶德华&quot;,&quot;age&quot;:23&#125;&apos;;</div><div class=\"line\">str = JSON.parse(str);</div><div class=\"line\">console.info(JSON.stringify(str));</div><div class=\"line\">console.info(JSON.stringify(str,null,5));</div><div class=\"line\">console.info(JSON.stringify(str,[&quot;name&quot;],5));</div><div class=\"line\">console.info(JSON.stringify(str,null,&quot;###&quot;));</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>JSON.parse()和JSON.stringify()</strong></p>\n<ol>\n<li>JSON.parse(string[, translator]) 将字符串转换为JSON对象</li>\n</ol>\n<p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &apos;&#123;&quot;name&quot;:&quot;叶德华&quot;,&quot;age&quot;:23&#125;&apos;;</div><div class=\"line\">str = JSON.parse(str);</div></pre></td></tr></table></figure></p>\n<ol>\n<li>JSON.stringify(object[, replacer[, space]])  将JSON对象转为字符串</li>\n</ol>\n<blockquote>\n<p>参数：</p>\n<p>object：是要转为字符串的JSON对象。</p>\n<p>replacer：可选，可以是改变字符串转换过程的函数，也可以是一组String和Number对象，这些对象用作一个白名单，用于选择要转换为字符串的对象的属性。如果这个值是空或没有提供，则在所得的JSON字符串中包含对象的所有属性。</p>\n<p>space参数：可选，是一个String或Number对象，用于把空白插入输出的JSON字符串，以提高可读性。如果这是一个数值，则表示用作空白的空格字符数；如果该数值大于10，就取其值为10；小于1的值表示不应使用空格。如果这是一个字符串（如果该字符串多于10个字符，就取前10个字符），就把该字符串用作空白。如果没有提供这个参数（或者为空），就不使用空白。</p>\n</blockquote>\n<p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &apos;&#123;&quot;name&quot;:&quot;叶德华&quot;,&quot;age&quot;:23&#125;&apos;;</div><div class=\"line\">str = JSON.parse(str);</div><div class=\"line\">console.info(JSON.stringify(str));</div><div class=\"line\">console.info(JSON.stringify(str,null,5));</div><div class=\"line\">console.info(JSON.stringify(str,[&quot;name&quot;],5));</div><div class=\"line\">console.info(JSON.stringify(str,null,&quot;###&quot;));</div></pre></td></tr></table></figure></p>\n"},{"title":"Flexbox","_content":"Flexbox 实现了帮助我们脱离 CSS 苦海（例如垂直居中）的目标，但想精通它却需要你应对一些挑战。所以，我们将通过一些动画让你直观地了解 Flexbox 的工作原理，并使用它来构建灵活的布局。\n\nFlexbox 的基本原则是提供一种构建灵活、直观的布局方式。\n\n为了达成这一目标，它让容器决定如何分配容器成员的大小以及空间。这听起来相当不错，那么，让我们来看看实践中它是如何工作的。\n\n在本文中，我们将深入的探讨 Flexbox 中 5 个常见的属性。看看它们能做什么，如何使用它们，以及使用它们构建的布局是什么样的。\n\n---\n\n##### 属性 #1: Display: Flex\n以下是示例页面：\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-523dbccc41453c86.gif)\n\n我们可以看到，在灰色的容器中，包含了 4 种不同颜色与大小的 div 元素。每个 div 元素都默认`display: block`，因此，每个四方体都占据了一行的整个宽度。\n\n为了开始使用 Flexbox 布局，你需要将你的容器变为 Flex 容器。这很容易实现：\n\n```\n#container {\n  display: flex;\n}\n```\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-603a348d420cd823.gif)\n\n##### 属性 #2: Flex Direction\n\nFlexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：\n\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-93f65b182a2f85d4.png)\n\n项目默认是由主轴（从左到右）排列的，这就是你使用display: flex后，四方体以水平线排列的原因。\n\n而`Flex-direction`决定了主轴的方向。\n```\n#container {\n  display: flex;\n  flex-direction: column;\n}\n```\n这里有一个重要的区别：`flex-direction: column`所指的是四方体将沿主轴的垂直方向对齐。它使主轴自身从水平到垂直。\n\n而`flex-direction`还有一些其他的值供你设置，例如：`row-reverse`与`column-reverse`.\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-643ed5f305d85377.gif)\n##### 属性 #3: Justify Content\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到`flex-direction: row`值上。\n```\n#container {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n}\n```\n`justify-content`属性包含了 5 个值供你使用：\n\n> Flex-start\nFlex-end\nCenter\nSpace-between\nSpace-around\n\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-739ce25a66110b9e.gif)\n\n`Space-around`与`Space-between`是两个不容易直观理解的值。`Space-between`实现了两端对齐，而四方体之间的间隔都是相等的。\n\n`Space-around`使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）\n\n最后一点：请记住 `justify-content`沿主轴对齐，而`flex-direction`决定了主轴的方向。它将决定你移动的方向。\n\n##### 属性 #4: Align Items\n\n当你理解了`justify-content`属性，理解`Align Items`属性就变得轻而易举了。\n\n`justify-content`定义了项目在主轴的对齐方式，而`align-items`属性则定义了项目在交叉轴上是如何对齐的。\n\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-82ed714fd22557a1.png)\n\n当我们将`flex-direction`属性值重置为row后，我们的轴看上去就与上图一致。\n\n那么，让我们深入的了解下`Align Items`属性有哪些值：\n> flex-start\nflex-end\ncenter\nstretch\nbaseline\n\n前三个值与`justify-content`属性中的值完全一致，没有太多需要解释的地方。\n\n但是，接下来两个值却有些不同。\n\n`Stretch`指的是如果项目未设置高度或设为`auto`，项目将占满整个容器。而`baseline`是指项目将与段落标签的底部对齐。\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-5884ef1046c04119.gif)\n\n（请注意，对于`align-items：stretch`，我不得不将四方体的高度设置为auto，否则height属性将覆盖该stretch）\n\n对于baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：\n\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-2c5a097f00549381.png)\n\n为了更好地演示主轴和交叉轴的表现，在基于`justify-content`属性和`align-items`属性的值为center的情况下，让我们看看赋予`flex-direction`属性两个不同值后，它的表现如何：\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-ca9a85bcbcd77fd1.gif)\n\n我们可以看到，对于row值，四方体沿着与主轴水平方向排列，而对于column值，它们则沿着与主轴垂直的方向排列。\n\n即使出现了同时保持水平与垂直居中的情况，两者也不可互换！\n\n##### 属性 #5: Align Self\n\n`align-self`属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖`align-items`属性。虽然它的默认值为auto，但它继承了父元素`align-items`的属性。除了auto外，其他都与`align-items`属性完全一致。\n\n```\n#container {\n  align-items: flex-start;\n}\n.square#one {\n  align-self: center;\n}\n// Only this square will be centered.\n```\n我们将在两个四方体上应用`align-self`属性，而其余的四方体则应用`align-items: center`与 `flex-direction: row`，让我们看看会发生什么：\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-91938230a16c111f.gif)","source":"_posts/flexbox.md","raw":"---\ntitle: Flexbox\n---\nFlexbox 实现了帮助我们脱离 CSS 苦海（例如垂直居中）的目标，但想精通它却需要你应对一些挑战。所以，我们将通过一些动画让你直观地了解 Flexbox 的工作原理，并使用它来构建灵活的布局。\n\nFlexbox 的基本原则是提供一种构建灵活、直观的布局方式。\n\n为了达成这一目标，它让容器决定如何分配容器成员的大小以及空间。这听起来相当不错，那么，让我们来看看实践中它是如何工作的。\n\n在本文中，我们将深入的探讨 Flexbox 中 5 个常见的属性。看看它们能做什么，如何使用它们，以及使用它们构建的布局是什么样的。\n\n---\n\n##### 属性 #1: Display: Flex\n以下是示例页面：\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-523dbccc41453c86.gif)\n\n我们可以看到，在灰色的容器中，包含了 4 种不同颜色与大小的 div 元素。每个 div 元素都默认`display: block`，因此，每个四方体都占据了一行的整个宽度。\n\n为了开始使用 Flexbox 布局，你需要将你的容器变为 Flex 容器。这很容易实现：\n\n```\n#container {\n  display: flex;\n}\n```\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-603a348d420cd823.gif)\n\n##### 属性 #2: Flex Direction\n\nFlexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：\n\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-93f65b182a2f85d4.png)\n\n项目默认是由主轴（从左到右）排列的，这就是你使用display: flex后，四方体以水平线排列的原因。\n\n而`Flex-direction`决定了主轴的方向。\n```\n#container {\n  display: flex;\n  flex-direction: column;\n}\n```\n这里有一个重要的区别：`flex-direction: column`所指的是四方体将沿主轴的垂直方向对齐。它使主轴自身从水平到垂直。\n\n而`flex-direction`还有一些其他的值供你设置，例如：`row-reverse`与`column-reverse`.\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-643ed5f305d85377.gif)\n##### 属性 #3: Justify Content\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到`flex-direction: row`值上。\n```\n#container {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n}\n```\n`justify-content`属性包含了 5 个值供你使用：\n\n> Flex-start\nFlex-end\nCenter\nSpace-between\nSpace-around\n\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-739ce25a66110b9e.gif)\n\n`Space-around`与`Space-between`是两个不容易直观理解的值。`Space-between`实现了两端对齐，而四方体之间的间隔都是相等的。\n\n`Space-around`使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）\n\n最后一点：请记住 `justify-content`沿主轴对齐，而`flex-direction`决定了主轴的方向。它将决定你移动的方向。\n\n##### 属性 #4: Align Items\n\n当你理解了`justify-content`属性，理解`Align Items`属性就变得轻而易举了。\n\n`justify-content`定义了项目在主轴的对齐方式，而`align-items`属性则定义了项目在交叉轴上是如何对齐的。\n\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-82ed714fd22557a1.png)\n\n当我们将`flex-direction`属性值重置为row后，我们的轴看上去就与上图一致。\n\n那么，让我们深入的了解下`Align Items`属性有哪些值：\n> flex-start\nflex-end\ncenter\nstretch\nbaseline\n\n前三个值与`justify-content`属性中的值完全一致，没有太多需要解释的地方。\n\n但是，接下来两个值却有些不同。\n\n`Stretch`指的是如果项目未设置高度或设为`auto`，项目将占满整个容器。而`baseline`是指项目将与段落标签的底部对齐。\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-5884ef1046c04119.gif)\n\n（请注意，对于`align-items：stretch`，我不得不将四方体的高度设置为auto，否则height属性将覆盖该stretch）\n\n对于baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：\n\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-2c5a097f00549381.png)\n\n为了更好地演示主轴和交叉轴的表现，在基于`justify-content`属性和`align-items`属性的值为center的情况下，让我们看看赋予`flex-direction`属性两个不同值后，它的表现如何：\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-ca9a85bcbcd77fd1.gif)\n\n我们可以看到，对于row值，四方体沿着与主轴水平方向排列，而对于column值，它们则沿着与主轴垂直的方向排列。\n\n即使出现了同时保持水平与垂直居中的情况，两者也不可互换！\n\n##### 属性 #5: Align Self\n\n`align-self`属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖`align-items`属性。虽然它的默认值为auto，但它继承了父元素`align-items`的属性。除了auto外，其他都与`align-items`属性完全一致。\n\n```\n#container {\n  align-items: flex-start;\n}\n.square#one {\n  align-self: center;\n}\n// Only this square will be centered.\n```\n我们将在两个四方体上应用`align-self`属性，而其余的四方体则应用`align-items: center`与 `flex-direction: row`，让我们看看会发生什么：\n![](https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-91938230a16c111f.gif)","slug":"flexbox","published":1,"date":"2017-07-21T07:55:10.912Z","updated":"2017-08-16T09:54:43.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsvf000b38tzpiqotdbw","content":"<p>Flexbox 实现了帮助我们脱离 CSS 苦海（例如垂直居中）的目标，但想精通它却需要你应对一些挑战。所以，我们将通过一些动画让你直观地了解 Flexbox 的工作原理，并使用它来构建灵活的布局。</p>\n<p>Flexbox 的基本原则是提供一种构建灵活、直观的布局方式。</p>\n<p>为了达成这一目标，它让容器决定如何分配容器成员的大小以及空间。这听起来相当不错，那么，让我们来看看实践中它是如何工作的。</p>\n<p>在本文中，我们将深入的探讨 Flexbox 中 5 个常见的属性。看看它们能做什么，如何使用它们，以及使用它们构建的布局是什么样的。</p>\n<hr>\n<h5 id=\"属性-1-Display-Flex\"><a href=\"#属性-1-Display-Flex\" class=\"headerlink\" title=\"属性 #1: Display: Flex\"></a>属性 #1: Display: Flex</h5><p>以下是示例页面：<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-523dbccc41453c86.gif\" alt=\"\"></p>\n<p>我们可以看到，在灰色的容器中，包含了 4 种不同颜色与大小的 div 元素。每个 div 元素都默认<code>display: block</code>，因此，每个四方体都占据了一行的整个宽度。</p>\n<p>为了开始使用 Flexbox 布局，你需要将你的容器变为 Flex 容器。这很容易实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-603a348d420cd823.gif\" alt=\"\"></p>\n<h5 id=\"属性-2-Flex-Direction\"><a href=\"#属性-2-Flex-Direction\" class=\"headerlink\" title=\"属性 #2: Flex Direction\"></a>属性 #2: Flex Direction</h5><p>Flexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：</p>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-93f65b182a2f85d4.png\" alt=\"\"></p>\n<p>项目默认是由主轴（从左到右）排列的，这就是你使用display: flex后，四方体以水平线排列的原因。</p>\n<p>而<code>Flex-direction</code>决定了主轴的方向。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  flex-direction: column;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里有一个重要的区别：<code>flex-direction: column</code>所指的是四方体将沿主轴的垂直方向对齐。它使主轴自身从水平到垂直。</p>\n<p>而<code>flex-direction</code>还有一些其他的值供你设置，例如：<code>row-reverse</code>与<code>column-reverse</code>.<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-643ed5f305d85377.gif\" alt=\"\"></p>\n<h5 id=\"属性-3-Justify-Content\"><a href=\"#属性-3-Justify-Content\" class=\"headerlink\" title=\"属性 #3: Justify Content\"></a>属性 #3: Justify Content</h5><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>\n<p>在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到<code>flex-direction: row</code>值上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  flex-direction: row;</div><div class=\"line\">  justify-content: flex-start;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>justify-content</code>属性包含了 5 个值供你使用：</p>\n<blockquote>\n<p>Flex-start<br>Flex-end<br>Center<br>Space-between<br>Space-around</p>\n</blockquote>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-739ce25a66110b9e.gif\" alt=\"\"></p>\n<p><code>Space-around</code>与<code>Space-between</code>是两个不容易直观理解的值。<code>Space-between</code>实现了两端对齐，而四方体之间的间隔都是相等的。</p>\n<p><code>Space-around</code>使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）</p>\n<p>最后一点：请记住 <code>justify-content</code>沿主轴对齐，而<code>flex-direction</code>决定了主轴的方向。它将决定你移动的方向。</p>\n<h5 id=\"属性-4-Align-Items\"><a href=\"#属性-4-Align-Items\" class=\"headerlink\" title=\"属性 #4: Align Items\"></a>属性 #4: Align Items</h5><p>当你理解了<code>justify-content</code>属性，理解<code>Align Items</code>属性就变得轻而易举了。</p>\n<p><code>justify-content</code>定义了项目在主轴的对齐方式，而<code>align-items</code>属性则定义了项目在交叉轴上是如何对齐的。</p>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-82ed714fd22557a1.png\" alt=\"\"></p>\n<p>当我们将<code>flex-direction</code>属性值重置为row后，我们的轴看上去就与上图一致。</p>\n<p>那么，让我们深入的了解下<code>Align Items</code>属性有哪些值：</p>\n<blockquote>\n<p>flex-start<br>flex-end<br>center<br>stretch<br>baseline</p>\n</blockquote>\n<p>前三个值与<code>justify-content</code>属性中的值完全一致，没有太多需要解释的地方。</p>\n<p>但是，接下来两个值却有些不同。</p>\n<p><code>Stretch</code>指的是如果项目未设置高度或设为<code>auto</code>，项目将占满整个容器。而<code>baseline</code>是指项目将与段落标签的底部对齐。<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-5884ef1046c04119.gif\" alt=\"\"></p>\n<p>（请注意，对于<code>align-items：stretch</code>，我不得不将四方体的高度设置为auto，否则height属性将覆盖该stretch）</p>\n<p>对于baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：</p>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-2c5a097f00549381.png\" alt=\"\"></p>\n<p>为了更好地演示主轴和交叉轴的表现，在基于<code>justify-content</code>属性和<code>align-items</code>属性的值为center的情况下，让我们看看赋予<code>flex-direction</code>属性两个不同值后，它的表现如何：<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-ca9a85bcbcd77fd1.gif\" alt=\"\"></p>\n<p>我们可以看到，对于row值，四方体沿着与主轴水平方向排列，而对于column值，它们则沿着与主轴垂直的方向排列。</p>\n<p>即使出现了同时保持水平与垂直居中的情况，两者也不可互换！</p>\n<h5 id=\"属性-5-Align-Self\"><a href=\"#属性-5-Align-Self\" class=\"headerlink\" title=\"属性 #5: Align Self\"></a>属性 #5: Align Self</h5><p><code>align-self</code>属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖<code>align-items</code>属性。虽然它的默认值为auto，但它继承了父元素<code>align-items</code>的属性。除了auto外，其他都与<code>align-items</code>属性完全一致。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  align-items: flex-start;</div><div class=\"line\">&#125;</div><div class=\"line\">.square#one &#123;</div><div class=\"line\">  align-self: center;</div><div class=\"line\">&#125;</div><div class=\"line\">// Only this square will be centered.</div></pre></td></tr></table></figure>\n<p>我们将在两个四方体上应用<code>align-self</code>属性，而其余的四方体则应用<code>align-items: center</code>与 <code>flex-direction: row</code>，让我们看看会发生什么：<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-91938230a16c111f.gif\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Flexbox 实现了帮助我们脱离 CSS 苦海（例如垂直居中）的目标，但想精通它却需要你应对一些挑战。所以，我们将通过一些动画让你直观地了解 Flexbox 的工作原理，并使用它来构建灵活的布局。</p>\n<p>Flexbox 的基本原则是提供一种构建灵活、直观的布局方式。</p>\n<p>为了达成这一目标，它让容器决定如何分配容器成员的大小以及空间。这听起来相当不错，那么，让我们来看看实践中它是如何工作的。</p>\n<p>在本文中，我们将深入的探讨 Flexbox 中 5 个常见的属性。看看它们能做什么，如何使用它们，以及使用它们构建的布局是什么样的。</p>\n<hr>\n<h5 id=\"属性-1-Display-Flex\"><a href=\"#属性-1-Display-Flex\" class=\"headerlink\" title=\"属性 #1: Display: Flex\"></a>属性 #1: Display: Flex</h5><p>以下是示例页面：<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-523dbccc41453c86.gif\" alt=\"\"></p>\n<p>我们可以看到，在灰色的容器中，包含了 4 种不同颜色与大小的 div 元素。每个 div 元素都默认<code>display: block</code>，因此，每个四方体都占据了一行的整个宽度。</p>\n<p>为了开始使用 Flexbox 布局，你需要将你的容器变为 Flex 容器。这很容易实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-603a348d420cd823.gif\" alt=\"\"></p>\n<h5 id=\"属性-2-Flex-Direction\"><a href=\"#属性-2-Flex-Direction\" class=\"headerlink\" title=\"属性 #2: Flex Direction\"></a>属性 #2: Flex Direction</h5><p>Flexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：</p>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-93f65b182a2f85d4.png\" alt=\"\"></p>\n<p>项目默认是由主轴（从左到右）排列的，这就是你使用display: flex后，四方体以水平线排列的原因。</p>\n<p>而<code>Flex-direction</code>决定了主轴的方向。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  flex-direction: column;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里有一个重要的区别：<code>flex-direction: column</code>所指的是四方体将沿主轴的垂直方向对齐。它使主轴自身从水平到垂直。</p>\n<p>而<code>flex-direction</code>还有一些其他的值供你设置，例如：<code>row-reverse</code>与<code>column-reverse</code>.<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-643ed5f305d85377.gif\" alt=\"\"></p>\n<h5 id=\"属性-3-Justify-Content\"><a href=\"#属性-3-Justify-Content\" class=\"headerlink\" title=\"属性 #3: Justify Content\"></a>属性 #3: Justify Content</h5><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>\n<p>在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到<code>flex-direction: row</code>值上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  flex-direction: row;</div><div class=\"line\">  justify-content: flex-start;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>justify-content</code>属性包含了 5 个值供你使用：</p>\n<blockquote>\n<p>Flex-start<br>Flex-end<br>Center<br>Space-between<br>Space-around</p>\n</blockquote>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-739ce25a66110b9e.gif\" alt=\"\"></p>\n<p><code>Space-around</code>与<code>Space-between</code>是两个不容易直观理解的值。<code>Space-between</code>实现了两端对齐，而四方体之间的间隔都是相等的。</p>\n<p><code>Space-around</code>使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）</p>\n<p>最后一点：请记住 <code>justify-content</code>沿主轴对齐，而<code>flex-direction</code>决定了主轴的方向。它将决定你移动的方向。</p>\n<h5 id=\"属性-4-Align-Items\"><a href=\"#属性-4-Align-Items\" class=\"headerlink\" title=\"属性 #4: Align Items\"></a>属性 #4: Align Items</h5><p>当你理解了<code>justify-content</code>属性，理解<code>Align Items</code>属性就变得轻而易举了。</p>\n<p><code>justify-content</code>定义了项目在主轴的对齐方式，而<code>align-items</code>属性则定义了项目在交叉轴上是如何对齐的。</p>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-82ed714fd22557a1.png\" alt=\"\"></p>\n<p>当我们将<code>flex-direction</code>属性值重置为row后，我们的轴看上去就与上图一致。</p>\n<p>那么，让我们深入的了解下<code>Align Items</code>属性有哪些值：</p>\n<blockquote>\n<p>flex-start<br>flex-end<br>center<br>stretch<br>baseline</p>\n</blockquote>\n<p>前三个值与<code>justify-content</code>属性中的值完全一致，没有太多需要解释的地方。</p>\n<p>但是，接下来两个值却有些不同。</p>\n<p><code>Stretch</code>指的是如果项目未设置高度或设为<code>auto</code>，项目将占满整个容器。而<code>baseline</code>是指项目将与段落标签的底部对齐。<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-5884ef1046c04119.gif\" alt=\"\"></p>\n<p>（请注意，对于<code>align-items：stretch</code>，我不得不将四方体的高度设置为auto，否则height属性将覆盖该stretch）</p>\n<p>对于baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：</p>\n<p><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-2c5a097f00549381.png\" alt=\"\"></p>\n<p>为了更好地演示主轴和交叉轴的表现，在基于<code>justify-content</code>属性和<code>align-items</code>属性的值为center的情况下，让我们看看赋予<code>flex-direction</code>属性两个不同值后，它的表现如何：<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-ca9a85bcbcd77fd1.gif\" alt=\"\"></p>\n<p>我们可以看到，对于row值，四方体沿着与主轴水平方向排列，而对于column值，它们则沿着与主轴垂直的方向排列。</p>\n<p>即使出现了同时保持水平与垂直居中的情况，两者也不可互换！</p>\n<h5 id=\"属性-5-Align-Self\"><a href=\"#属性-5-Align-Self\" class=\"headerlink\" title=\"属性 #5: Align Self\"></a>属性 #5: Align Self</h5><p><code>align-self</code>属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖<code>align-items</code>属性。虽然它的默认值为auto，但它继承了父元素<code>align-items</code>的属性。除了auto外，其他都与<code>align-items</code>属性完全一致。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  align-items: flex-start;</div><div class=\"line\">&#125;</div><div class=\"line\">.square#one &#123;</div><div class=\"line\">  align-self: center;</div><div class=\"line\">&#125;</div><div class=\"line\">// Only this square will be centered.</div></pre></td></tr></table></figure>\n<p>我们将在两个四方体上应用<code>align-self</code>属性，而其余的四方体则应用<code>align-items: center</code>与 <code>flex-direction: row</code>，让我们看看会发生什么：<br><img src=\"https://my-owo-ink.b0.upaiyun.com/owo.ink/flexbox/675733-91938230a16c111f.gif\" alt=\"\"></p>\n"},{"title":"vue子组件与父组件通讯","_content":"记录\n\nJSON转字符串 JSON.stringify()\n\nJSON字符串转换为JSON对象 JSON.parse(str)\n\n判断数据类型 typeof\n\n查看进程：ps -ef |grep nodejs\n\nnohup后台 nohup meteor --production &\n\n查看运行的后台进程  jobs\n\nfg %n将后台脚本调到前台执行\n\nlinux重启：shutdown -r now ","source":"_posts/text.md","raw":"---\ntitle: vue子组件与父组件通讯\n---\n记录\n\nJSON转字符串 JSON.stringify()\n\nJSON字符串转换为JSON对象 JSON.parse(str)\n\n判断数据类型 typeof\n\n查看进程：ps -ef |grep nodejs\n\nnohup后台 nohup meteor --production &\n\n查看运行的后台进程  jobs\n\nfg %n将后台脚本调到前台执行\n\nlinux重启：shutdown -r now ","slug":"text","published":1,"date":"2017-07-21T08:22:49.623Z","updated":"2017-07-21T08:23:54.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsvf000c38tzdgzjmr6b","content":"<p>记录</p>\n<p>JSON转字符串 JSON.stringify()</p>\n<p>JSON字符串转换为JSON对象 JSON.parse(str)</p>\n<p>判断数据类型 typeof</p>\n<p>查看进程：ps -ef |grep nodejs</p>\n<p>nohup后台 nohup meteor –production &amp;</p>\n<p>查看运行的后台进程  jobs</p>\n<p>fg %n将后台脚本调到前台执行</p>\n<p>linux重启：shutdown -r now </p>\n","site":{"data":{}},"excerpt":"","more":"<p>记录</p>\n<p>JSON转字符串 JSON.stringify()</p>\n<p>JSON字符串转换为JSON对象 JSON.parse(str)</p>\n<p>判断数据类型 typeof</p>\n<p>查看进程：ps -ef |grep nodejs</p>\n<p>nohup后台 nohup meteor –production &amp;</p>\n<p>查看运行的后台进程  jobs</p>\n<p>fg %n将后台脚本调到前台执行</p>\n<p>linux重启：shutdown -r now </p>\n"},{"title":"八段代码彻底掌握 Promise","_content":"### 1.Promise的立即执行性\n```\nvar p = new Promise(function(resolve, reject){\n  console.log(\"create a promise\");\n  resolve(\"success\");\n});\n\nconsole.log(\"after new Promise\");\n\np.then(function(value){\n  console.log(value);\n});\n```\n控制台输出：\n```\n\"create a promise\"\n\"after new Promise\"\n\"success\"\n```\nPromise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中\"create a promise\"先于\"after new Promise\"输出。\n\n### 2.Promise 三种状态\n```\nvar p1 = new Promise(function(resolve,reject){\n  resolve(1);\n});\nvar p2 = new Promise(function(resolve,reject){\n  setTimeout(function(){\n    resolve(2);  \n  }, 500);      \n});\nvar p3 = new Promise(function(resolve,reject){\n  setTimeout(function(){\n    reject(3);  \n  }, 500);      \n});\n\nconsole.log(p1);\nconsole.log(p2);\nconsole.log(p3);\nsetTimeout(function(){\n  console.log(p2);\n}, 1000);\nsetTimeout(function(){\n  console.log(p3);\n}, 1000);\n\np1.then(function(value){\n  console.log(value);\n});\np2.then(function(value){\n  console.log(value);\n});\np3.catch(function(err){\n  console.log(err);\n});\n```\n控制台输出：\n```\nPromise {[[PromiseStatus]]: \"resolved\", [[PromiseValue]]: 1}\nPromise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\nPromise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\n1\n2\n3\nPromise {[[PromiseStatus]]: \"resolved\", [[PromiseValue]]: 2}\nPromise {[[PromiseStatus]]: \"rejected\", [[PromiseValue]]: 3}\n```\nPromise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。\n\np2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个`setTimeout`函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。\n\n### 3.Promise 状态的不可逆性\n\n```\nvar p1 = new Promise(function(resolve, reject){\n  resolve(\"success1\");\n  resolve(\"success2\");\n});\n\nvar p2 = new Promise(function(resolve, reject){\n  resolve(\"success\");\n  reject(\"reject\");\n});\n\np1.then(function(value){\n  console.log(value);\n});\n\np2.then(function(value){\n  console.log(value);\n});\n```\n控制台输出：\n\n```\n\"success1\"\n\"success\"\n```\n\nPromise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中`resolve(\"success2\")`并不能将p1的值更改为`success2`，p2中`reject(\"reject\")`也不能将p2的状态由resolved改变为rejected.\n\n### 4.链式调用\n\n```\nvar p = new Promise(function(resolve, reject){\n  resolve(1);\n});\np.then(function(value){               //第一个then\n  console.log(value);\n  return value*2;\n}).then(function(value){              //第二个then\n  console.log(value);\n}).then(function(value){              //第三个then\n  console.log(value);\n  return Promise.resolve('resolve'); \n}).then(function(value){              //第四个then\n  console.log(value);\n  return Promise.reject('reject');\n}).then(function(value){              //第五个then\n  console.log('resolve: '+ value);\n}, function(err){\n  console.log('reject: ' + err);\n})\n```\n控制台输出：\n\n```\n1\n2\nundefined\n\"resolve\"\n\"reject: reject\"\n```\n\nPromise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：\n\n* return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。\n* return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。\n* throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。\n\n根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。\n\n### 5.Promise then() 回调异步性\n```\nvar p = new Promise(function(resolve, reject){\n  resolve(\"success\");\n});\n\np.then(function(value){\n  console.log(value);\n});\n\nconsole.log(\"which one is called first ?\");\n```\n控制台输出：\n\n```\n\"which one is called first ?\"\n\"success\"\n```\nPromise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，\"success\"会在后面输出。\n\n### 6.Promise 中的异常\n```\nvar p1 = new Promise( function(resolve,reject){\n  foo.bar();\n  resolve( 1 );      \n});\n\np1.then(\n  function(value){\n    console.log('p1 then value: ' + value);\n  },\n  function(err){\n    console.log('p1 then err: ' + err);\n  }\n).then(\n  function(value){\n    console.log('p1 then then value: '+value);\n  },\n  function(err){\n    console.log('p1 then then err: ' + err);\n  }\n);\n\nvar p2 = new Promise(function(resolve,reject){\n  resolve( 2 );    \n});\n\np2.then(\n  function(value){\n    console.log('p2 then value: ' + value);\n    foo.bar();\n  }, \n  function(err){\n    console.log('p2 then err: ' + err);\n  }\n).then(\n  function(value){\n    console.log('p2 then then value: ' + value);\n  },\n  function(err){\n    console.log('p2 then then err: ' + err);\n    return 1;\n  }\n).then(\n  function(value){\n    console.log('p2 then then then value: ' + value);\n  },\n  function(err){\n    console.log('p2 then then then err: ' + err);\n  }\n);\n```\n\n控制台输出：\n\n```\np1 then err: ReferenceError: foo is not defined\np2 then value: 2\np1 then then value: undefined\np2 then then err: ReferenceError: foo is not defined\np2 then then then value: 1\n```\nPromise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。\n\n### 7.Promise.resolve()\n```\nvar p1 = Promise.resolve( 1 );\nvar p2 = Promise.resolve( p1 );\nvar p3 = new Promise(function(resolve, reject){\n  resolve(1);\n});\nvar p4 = new Promise(function(resolve, reject){\n  resolve(p1);\n});\n\nconsole.log(p1 === p2); \nconsole.log(p1 === p3);\nconsole.log(p1 === p4);\nconsole.log(p3 === p4);\n\np4.then(function(value){\n  console.log('p4=' + value);\n});\n\np2.then(function(value){\n  console.log('p2=' + value);\n})\n\np1.then(function(value){\n  console.log('p1=' + value);\n})\n```\n控制台输出：\n\n```\ntrue\nfalse\nfalse\nfalse\np2=1\np1=1\np4=1\n```\n\n`Promise.resolve(...)`可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。\n\n### 8.resolve vs reject\n```\nvar p1 = new Promise(function(resolve, reject){\n  resolve(Promise.resolve('resolve'));\n});\n\nvar p2 = new Promise(function(resolve, reject){\n  resolve(Promise.reject('reject'));\n});\n\nvar p3 = new Promise(function(resolve, reject){\n  reject(Promise.resolve('resolve'));\n});\n\np1.then(\n  function fulfilled(value){\n    console.log('fulfilled: ' + value);\n  }, \n  function rejected(err){\n    console.log('rejected: ' + err);\n  }\n);\n\np2.then(\n  function fulfilled(value){\n    console.log('fulfilled: ' + value);\n  }, \n  function rejected(err){\n    console.log('rejected: ' + err);\n  }\n);\n\np3.then(\n  function fulfilled(value){\n    console.log('fulfilled: ' + value);\n  }, \n  function rejected(err){\n    console.log('rejected: ' + err);\n  }\n);\n```\n控制台输出：\n\n```\np3 rejected: [object Promise]\np1 fulfilled: resolve\np2 rejected: reject\n```\n\nPromise回调函数中的第一个参数resolve，会对Promise执行\"拆箱\"动作。即当resolve的参数是一个Promise对象时，resolve会\"拆箱\"获取这个Promise对象的状态和值，但这个过程是异步的。p1\"拆箱\"后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2\"拆箱\"后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。\n","source":"_posts/promise.md","raw":"---\ntitle: 八段代码彻底掌握 Promise\n---\n### 1.Promise的立即执行性\n```\nvar p = new Promise(function(resolve, reject){\n  console.log(\"create a promise\");\n  resolve(\"success\");\n});\n\nconsole.log(\"after new Promise\");\n\np.then(function(value){\n  console.log(value);\n});\n```\n控制台输出：\n```\n\"create a promise\"\n\"after new Promise\"\n\"success\"\n```\nPromise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中\"create a promise\"先于\"after new Promise\"输出。\n\n### 2.Promise 三种状态\n```\nvar p1 = new Promise(function(resolve,reject){\n  resolve(1);\n});\nvar p2 = new Promise(function(resolve,reject){\n  setTimeout(function(){\n    resolve(2);  \n  }, 500);      \n});\nvar p3 = new Promise(function(resolve,reject){\n  setTimeout(function(){\n    reject(3);  \n  }, 500);      \n});\n\nconsole.log(p1);\nconsole.log(p2);\nconsole.log(p3);\nsetTimeout(function(){\n  console.log(p2);\n}, 1000);\nsetTimeout(function(){\n  console.log(p3);\n}, 1000);\n\np1.then(function(value){\n  console.log(value);\n});\np2.then(function(value){\n  console.log(value);\n});\np3.catch(function(err){\n  console.log(err);\n});\n```\n控制台输出：\n```\nPromise {[[PromiseStatus]]: \"resolved\", [[PromiseValue]]: 1}\nPromise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\nPromise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\n1\n2\n3\nPromise {[[PromiseStatus]]: \"resolved\", [[PromiseValue]]: 2}\nPromise {[[PromiseStatus]]: \"rejected\", [[PromiseValue]]: 3}\n```\nPromise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。\n\np2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个`setTimeout`函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。\n\n### 3.Promise 状态的不可逆性\n\n```\nvar p1 = new Promise(function(resolve, reject){\n  resolve(\"success1\");\n  resolve(\"success2\");\n});\n\nvar p2 = new Promise(function(resolve, reject){\n  resolve(\"success\");\n  reject(\"reject\");\n});\n\np1.then(function(value){\n  console.log(value);\n});\n\np2.then(function(value){\n  console.log(value);\n});\n```\n控制台输出：\n\n```\n\"success1\"\n\"success\"\n```\n\nPromise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中`resolve(\"success2\")`并不能将p1的值更改为`success2`，p2中`reject(\"reject\")`也不能将p2的状态由resolved改变为rejected.\n\n### 4.链式调用\n\n```\nvar p = new Promise(function(resolve, reject){\n  resolve(1);\n});\np.then(function(value){               //第一个then\n  console.log(value);\n  return value*2;\n}).then(function(value){              //第二个then\n  console.log(value);\n}).then(function(value){              //第三个then\n  console.log(value);\n  return Promise.resolve('resolve'); \n}).then(function(value){              //第四个then\n  console.log(value);\n  return Promise.reject('reject');\n}).then(function(value){              //第五个then\n  console.log('resolve: '+ value);\n}, function(err){\n  console.log('reject: ' + err);\n})\n```\n控制台输出：\n\n```\n1\n2\nundefined\n\"resolve\"\n\"reject: reject\"\n```\n\nPromise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：\n\n* return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。\n* return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。\n* throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。\n\n根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。\n\n### 5.Promise then() 回调异步性\n```\nvar p = new Promise(function(resolve, reject){\n  resolve(\"success\");\n});\n\np.then(function(value){\n  console.log(value);\n});\n\nconsole.log(\"which one is called first ?\");\n```\n控制台输出：\n\n```\n\"which one is called first ?\"\n\"success\"\n```\nPromise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，\"success\"会在后面输出。\n\n### 6.Promise 中的异常\n```\nvar p1 = new Promise( function(resolve,reject){\n  foo.bar();\n  resolve( 1 );      \n});\n\np1.then(\n  function(value){\n    console.log('p1 then value: ' + value);\n  },\n  function(err){\n    console.log('p1 then err: ' + err);\n  }\n).then(\n  function(value){\n    console.log('p1 then then value: '+value);\n  },\n  function(err){\n    console.log('p1 then then err: ' + err);\n  }\n);\n\nvar p2 = new Promise(function(resolve,reject){\n  resolve( 2 );    \n});\n\np2.then(\n  function(value){\n    console.log('p2 then value: ' + value);\n    foo.bar();\n  }, \n  function(err){\n    console.log('p2 then err: ' + err);\n  }\n).then(\n  function(value){\n    console.log('p2 then then value: ' + value);\n  },\n  function(err){\n    console.log('p2 then then err: ' + err);\n    return 1;\n  }\n).then(\n  function(value){\n    console.log('p2 then then then value: ' + value);\n  },\n  function(err){\n    console.log('p2 then then then err: ' + err);\n  }\n);\n```\n\n控制台输出：\n\n```\np1 then err: ReferenceError: foo is not defined\np2 then value: 2\np1 then then value: undefined\np2 then then err: ReferenceError: foo is not defined\np2 then then then value: 1\n```\nPromise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。\n\n### 7.Promise.resolve()\n```\nvar p1 = Promise.resolve( 1 );\nvar p2 = Promise.resolve( p1 );\nvar p3 = new Promise(function(resolve, reject){\n  resolve(1);\n});\nvar p4 = new Promise(function(resolve, reject){\n  resolve(p1);\n});\n\nconsole.log(p1 === p2); \nconsole.log(p1 === p3);\nconsole.log(p1 === p4);\nconsole.log(p3 === p4);\n\np4.then(function(value){\n  console.log('p4=' + value);\n});\n\np2.then(function(value){\n  console.log('p2=' + value);\n})\n\np1.then(function(value){\n  console.log('p1=' + value);\n})\n```\n控制台输出：\n\n```\ntrue\nfalse\nfalse\nfalse\np2=1\np1=1\np4=1\n```\n\n`Promise.resolve(...)`可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。\n\n### 8.resolve vs reject\n```\nvar p1 = new Promise(function(resolve, reject){\n  resolve(Promise.resolve('resolve'));\n});\n\nvar p2 = new Promise(function(resolve, reject){\n  resolve(Promise.reject('reject'));\n});\n\nvar p3 = new Promise(function(resolve, reject){\n  reject(Promise.resolve('resolve'));\n});\n\np1.then(\n  function fulfilled(value){\n    console.log('fulfilled: ' + value);\n  }, \n  function rejected(err){\n    console.log('rejected: ' + err);\n  }\n);\n\np2.then(\n  function fulfilled(value){\n    console.log('fulfilled: ' + value);\n  }, \n  function rejected(err){\n    console.log('rejected: ' + err);\n  }\n);\n\np3.then(\n  function fulfilled(value){\n    console.log('fulfilled: ' + value);\n  }, \n  function rejected(err){\n    console.log('rejected: ' + err);\n  }\n);\n```\n控制台输出：\n\n```\np3 rejected: [object Promise]\np1 fulfilled: resolve\np2 rejected: reject\n```\n\nPromise回调函数中的第一个参数resolve，会对Promise执行\"拆箱\"动作。即当resolve的参数是一个Promise对象时，resolve会\"拆箱\"获取这个Promise对象的状态和值，但这个过程是异步的。p1\"拆箱\"后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2\"拆箱\"后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。\n","slug":"promise","published":1,"date":"2017-07-27T05:52:58.479Z","updated":"2017-08-02T07:35:22.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsvu000d38tztir90fvc","content":"<h3 id=\"1-Promise的立即执行性\"><a href=\"#1-Promise的立即执行性\" class=\"headerlink\" title=\"1.Promise的立即执行性\"></a>1.Promise的立即执行性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  console.log(&quot;create a promise&quot;);</div><div class=\"line\">  resolve(&quot;success&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;after new Promise&quot;);</div><div class=\"line\"></div><div class=\"line\">p.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>控制台输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;create a promise&quot;</div><div class=\"line\">&quot;after new Promise&quot;</div><div class=\"line\">&quot;success&quot;</div></pre></td></tr></table></figure></p>\n<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。</p>\n<h3 id=\"2-Promise-三种状态\"><a href=\"#2-Promise-三种状态\" class=\"headerlink\" title=\"2.Promise 三种状态\"></a>2.Promise 三种状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = new Promise(function(resolve,reject)&#123;</div><div class=\"line\">  resolve(1);</div><div class=\"line\">&#125;);</div><div class=\"line\">var p2 = new Promise(function(resolve,reject)&#123;</div><div class=\"line\">  setTimeout(function()&#123;</div><div class=\"line\">    resolve(2);  </div><div class=\"line\">  &#125;, 500);      </div><div class=\"line\">&#125;);</div><div class=\"line\">var p3 = new Promise(function(resolve,reject)&#123;</div><div class=\"line\">  setTimeout(function()&#123;</div><div class=\"line\">    reject(3);  </div><div class=\"line\">  &#125;, 500);      </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(p1);</div><div class=\"line\">console.log(p2);</div><div class=\"line\">console.log(p3);</div><div class=\"line\">setTimeout(function()&#123;</div><div class=\"line\">  console.log(p2);</div><div class=\"line\">&#125;, 1000);</div><div class=\"line\">setTimeout(function()&#123;</div><div class=\"line\">  console.log(p3);</div><div class=\"line\">&#125;, 1000);</div><div class=\"line\"></div><div class=\"line\">p1.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\">p2.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\">p3.catch(function(err)&#123;</div><div class=\"line\">  console.log(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>控制台输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1&#125;</div><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</div><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2&#125;</div><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3&#125;</div></pre></td></tr></table></figure></p>\n<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>\n<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个<code>setTimeout</code>函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>\n<h3 id=\"3-Promise-状态的不可逆性\"><a href=\"#3-Promise-状态的不可逆性\" class=\"headerlink\" title=\"3.Promise 状态的不可逆性\"></a>3.Promise 状态的不可逆性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(&quot;success1&quot;);</div><div class=\"line\">  resolve(&quot;success2&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var p2 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(&quot;success&quot;);</div><div class=\"line\">  reject(&quot;reject&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p1.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p2.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;success1&quot;</div><div class=\"line\">&quot;success&quot;</div></pre></td></tr></table></figure>\n<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中<code>resolve(&quot;success2&quot;)</code>并不能将p1的值更改为<code>success2</code>，p2中<code>reject(&quot;reject&quot;)</code>也不能将p2的状态由resolved改变为rejected.</p>\n<h3 id=\"4-链式调用\"><a href=\"#4-链式调用\" class=\"headerlink\" title=\"4.链式调用\"></a>4.链式调用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(1);</div><div class=\"line\">&#125;);</div><div class=\"line\">p.then(function(value)&#123;               //第一个then</div><div class=\"line\">  console.log(value);</div><div class=\"line\">  return value*2;</div><div class=\"line\">&#125;).then(function(value)&#123;              //第二个then</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;).then(function(value)&#123;              //第三个then</div><div class=\"line\">  console.log(value);</div><div class=\"line\">  return Promise.resolve(&apos;resolve&apos;); </div><div class=\"line\">&#125;).then(function(value)&#123;              //第四个then</div><div class=\"line\">  console.log(value);</div><div class=\"line\">  return Promise.reject(&apos;reject&apos;);</div><div class=\"line\">&#125;).then(function(value)&#123;              //第五个then</div><div class=\"line\">  console.log(&apos;resolve: &apos;+ value);</div><div class=\"line\">&#125;, function(err)&#123;</div><div class=\"line\">  console.log(&apos;reject: &apos; + err);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">undefined</div><div class=\"line\">&quot;resolve&quot;</div><div class=\"line\">&quot;reject: reject&quot;</div></pre></td></tr></table></figure>\n<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>\n<ul>\n<li>return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>\n<li>return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>\n<li>throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。</li>\n</ul>\n<p>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p>\n<h3 id=\"5-Promise-then-回调异步性\"><a href=\"#5-Promise-then-回调异步性\" class=\"headerlink\" title=\"5.Promise then() 回调异步性\"></a>5.Promise then() 回调异步性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(&quot;success&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;which one is called first ?&quot;);</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;which one is called first ?&quot;</div><div class=\"line\">&quot;success&quot;</div></pre></td></tr></table></figure>\n<p>Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>\n<h3 id=\"6-Promise-中的异常\"><a href=\"#6-Promise-中的异常\" class=\"headerlink\" title=\"6.Promise 中的异常\"></a>6.Promise 中的异常</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = new Promise( function(resolve,reject)&#123;</div><div class=\"line\">  foo.bar();</div><div class=\"line\">  resolve( 1 );      </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p1.then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p1 then value: &apos; + value);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p1 then err: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">).then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p1 then then value: &apos;+value);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p1 then then err: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">var p2 = new Promise(function(resolve,reject)&#123;</div><div class=\"line\">  resolve( 2 );    </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p2.then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p2 then value: &apos; + value);</div><div class=\"line\">    foo.bar();</div><div class=\"line\">  &#125;, </div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p2 then err: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">).then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p2 then then value: &apos; + value);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p2 then then err: &apos; + err);</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;</div><div class=\"line\">).then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p2 then then then value: &apos; + value);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p2 then then then err: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">p1 then err: ReferenceError: foo is not defined</div><div class=\"line\">p2 then value: 2</div><div class=\"line\">p1 then then value: undefined</div><div class=\"line\">p2 then then err: ReferenceError: foo is not defined</div><div class=\"line\">p2 then then then value: 1</div></pre></td></tr></table></figure>\n<p>Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。</p>\n<h3 id=\"7-Promise-resolve\"><a href=\"#7-Promise-resolve\" class=\"headerlink\" title=\"7.Promise.resolve()\"></a>7.Promise.resolve()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = Promise.resolve( 1 );</div><div class=\"line\">var p2 = Promise.resolve( p1 );</div><div class=\"line\">var p3 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(1);</div><div class=\"line\">&#125;);</div><div class=\"line\">var p4 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(p1);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(p1 === p2); </div><div class=\"line\">console.log(p1 === p3);</div><div class=\"line\">console.log(p1 === p4);</div><div class=\"line\">console.log(p3 === p4);</div><div class=\"line\"></div><div class=\"line\">p4.then(function(value)&#123;</div><div class=\"line\">  console.log(&apos;p4=&apos; + value);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p2.then(function(value)&#123;</div><div class=\"line\">  console.log(&apos;p2=&apos; + value);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">p1.then(function(value)&#123;</div><div class=\"line\">  console.log(&apos;p1=&apos; + value);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">true</div><div class=\"line\">false</div><div class=\"line\">false</div><div class=\"line\">false</div><div class=\"line\">p2=1</div><div class=\"line\">p1=1</div><div class=\"line\">p4=1</div></pre></td></tr></table></figure>\n<p><code>Promise.resolve(...)</code>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>\n<h3 id=\"8-resolve-vs-reject\"><a href=\"#8-resolve-vs-reject\" class=\"headerlink\" title=\"8.resolve vs reject\"></a>8.resolve vs reject</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(Promise.resolve(&apos;resolve&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var p2 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(Promise.reject(&apos;reject&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var p3 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  reject(Promise.resolve(&apos;resolve&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p1.then(</div><div class=\"line\">  function fulfilled(value)&#123;</div><div class=\"line\">    console.log(&apos;fulfilled: &apos; + value);</div><div class=\"line\">  &#125;, </div><div class=\"line\">  function rejected(err)&#123;</div><div class=\"line\">    console.log(&apos;rejected: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">p2.then(</div><div class=\"line\">  function fulfilled(value)&#123;</div><div class=\"line\">    console.log(&apos;fulfilled: &apos; + value);</div><div class=\"line\">  &#125;, </div><div class=\"line\">  function rejected(err)&#123;</div><div class=\"line\">    console.log(&apos;rejected: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">p3.then(</div><div class=\"line\">  function fulfilled(value)&#123;</div><div class=\"line\">    console.log(&apos;fulfilled: &apos; + value);</div><div class=\"line\">  &#125;, </div><div class=\"line\">  function rejected(err)&#123;</div><div class=\"line\">    console.log(&apos;rejected: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">p3 rejected: [object Promise]</div><div class=\"line\">p1 fulfilled: resolve</div><div class=\"line\">p2 rejected: reject</div></pre></td></tr></table></figure>\n<p>Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-Promise的立即执行性\"><a href=\"#1-Promise的立即执行性\" class=\"headerlink\" title=\"1.Promise的立即执行性\"></a>1.Promise的立即执行性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  console.log(&quot;create a promise&quot;);</div><div class=\"line\">  resolve(&quot;success&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;after new Promise&quot;);</div><div class=\"line\"></div><div class=\"line\">p.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>控制台输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;create a promise&quot;</div><div class=\"line\">&quot;after new Promise&quot;</div><div class=\"line\">&quot;success&quot;</div></pre></td></tr></table></figure></p>\n<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。</p>\n<h3 id=\"2-Promise-三种状态\"><a href=\"#2-Promise-三种状态\" class=\"headerlink\" title=\"2.Promise 三种状态\"></a>2.Promise 三种状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = new Promise(function(resolve,reject)&#123;</div><div class=\"line\">  resolve(1);</div><div class=\"line\">&#125;);</div><div class=\"line\">var p2 = new Promise(function(resolve,reject)&#123;</div><div class=\"line\">  setTimeout(function()&#123;</div><div class=\"line\">    resolve(2);  </div><div class=\"line\">  &#125;, 500);      </div><div class=\"line\">&#125;);</div><div class=\"line\">var p3 = new Promise(function(resolve,reject)&#123;</div><div class=\"line\">  setTimeout(function()&#123;</div><div class=\"line\">    reject(3);  </div><div class=\"line\">  &#125;, 500);      </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(p1);</div><div class=\"line\">console.log(p2);</div><div class=\"line\">console.log(p3);</div><div class=\"line\">setTimeout(function()&#123;</div><div class=\"line\">  console.log(p2);</div><div class=\"line\">&#125;, 1000);</div><div class=\"line\">setTimeout(function()&#123;</div><div class=\"line\">  console.log(p3);</div><div class=\"line\">&#125;, 1000);</div><div class=\"line\"></div><div class=\"line\">p1.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\">p2.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\">p3.catch(function(err)&#123;</div><div class=\"line\">  console.log(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>控制台输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1&#125;</div><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</div><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2&#125;</div><div class=\"line\">Promise &#123;[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3&#125;</div></pre></td></tr></table></figure></p>\n<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>\n<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个<code>setTimeout</code>函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>\n<h3 id=\"3-Promise-状态的不可逆性\"><a href=\"#3-Promise-状态的不可逆性\" class=\"headerlink\" title=\"3.Promise 状态的不可逆性\"></a>3.Promise 状态的不可逆性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(&quot;success1&quot;);</div><div class=\"line\">  resolve(&quot;success2&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var p2 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(&quot;success&quot;);</div><div class=\"line\">  reject(&quot;reject&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p1.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p2.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;success1&quot;</div><div class=\"line\">&quot;success&quot;</div></pre></td></tr></table></figure>\n<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中<code>resolve(&quot;success2&quot;)</code>并不能将p1的值更改为<code>success2</code>，p2中<code>reject(&quot;reject&quot;)</code>也不能将p2的状态由resolved改变为rejected.</p>\n<h3 id=\"4-链式调用\"><a href=\"#4-链式调用\" class=\"headerlink\" title=\"4.链式调用\"></a>4.链式调用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(1);</div><div class=\"line\">&#125;);</div><div class=\"line\">p.then(function(value)&#123;               //第一个then</div><div class=\"line\">  console.log(value);</div><div class=\"line\">  return value*2;</div><div class=\"line\">&#125;).then(function(value)&#123;              //第二个then</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;).then(function(value)&#123;              //第三个then</div><div class=\"line\">  console.log(value);</div><div class=\"line\">  return Promise.resolve(&apos;resolve&apos;); </div><div class=\"line\">&#125;).then(function(value)&#123;              //第四个then</div><div class=\"line\">  console.log(value);</div><div class=\"line\">  return Promise.reject(&apos;reject&apos;);</div><div class=\"line\">&#125;).then(function(value)&#123;              //第五个then</div><div class=\"line\">  console.log(&apos;resolve: &apos;+ value);</div><div class=\"line\">&#125;, function(err)&#123;</div><div class=\"line\">  console.log(&apos;reject: &apos; + err);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">undefined</div><div class=\"line\">&quot;resolve&quot;</div><div class=\"line\">&quot;reject: reject&quot;</div></pre></td></tr></table></figure>\n<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>\n<ul>\n<li>return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>\n<li>return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>\n<li>throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。</li>\n</ul>\n<p>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p>\n<h3 id=\"5-Promise-then-回调异步性\"><a href=\"#5-Promise-then-回调异步性\" class=\"headerlink\" title=\"5.Promise then() 回调异步性\"></a>5.Promise then() 回调异步性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(&quot;success&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p.then(function(value)&#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;which one is called first ?&quot;);</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;which one is called first ?&quot;</div><div class=\"line\">&quot;success&quot;</div></pre></td></tr></table></figure>\n<p>Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>\n<h3 id=\"6-Promise-中的异常\"><a href=\"#6-Promise-中的异常\" class=\"headerlink\" title=\"6.Promise 中的异常\"></a>6.Promise 中的异常</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = new Promise( function(resolve,reject)&#123;</div><div class=\"line\">  foo.bar();</div><div class=\"line\">  resolve( 1 );      </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p1.then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p1 then value: &apos; + value);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p1 then err: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">).then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p1 then then value: &apos;+value);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p1 then then err: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">var p2 = new Promise(function(resolve,reject)&#123;</div><div class=\"line\">  resolve( 2 );    </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p2.then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p2 then value: &apos; + value);</div><div class=\"line\">    foo.bar();</div><div class=\"line\">  &#125;, </div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p2 then err: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">).then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p2 then then value: &apos; + value);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p2 then then err: &apos; + err);</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;</div><div class=\"line\">).then(</div><div class=\"line\">  function(value)&#123;</div><div class=\"line\">    console.log(&apos;p2 then then then value: &apos; + value);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  function(err)&#123;</div><div class=\"line\">    console.log(&apos;p2 then then then err: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">p1 then err: ReferenceError: foo is not defined</div><div class=\"line\">p2 then value: 2</div><div class=\"line\">p1 then then value: undefined</div><div class=\"line\">p2 then then err: ReferenceError: foo is not defined</div><div class=\"line\">p2 then then then value: 1</div></pre></td></tr></table></figure>\n<p>Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。</p>\n<h3 id=\"7-Promise-resolve\"><a href=\"#7-Promise-resolve\" class=\"headerlink\" title=\"7.Promise.resolve()\"></a>7.Promise.resolve()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = Promise.resolve( 1 );</div><div class=\"line\">var p2 = Promise.resolve( p1 );</div><div class=\"line\">var p3 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(1);</div><div class=\"line\">&#125;);</div><div class=\"line\">var p4 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(p1);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(p1 === p2); </div><div class=\"line\">console.log(p1 === p3);</div><div class=\"line\">console.log(p1 === p4);</div><div class=\"line\">console.log(p3 === p4);</div><div class=\"line\"></div><div class=\"line\">p4.then(function(value)&#123;</div><div class=\"line\">  console.log(&apos;p4=&apos; + value);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p2.then(function(value)&#123;</div><div class=\"line\">  console.log(&apos;p2=&apos; + value);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">p1.then(function(value)&#123;</div><div class=\"line\">  console.log(&apos;p1=&apos; + value);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">true</div><div class=\"line\">false</div><div class=\"line\">false</div><div class=\"line\">false</div><div class=\"line\">p2=1</div><div class=\"line\">p1=1</div><div class=\"line\">p4=1</div></pre></td></tr></table></figure>\n<p><code>Promise.resolve(...)</code>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>\n<h3 id=\"8-resolve-vs-reject\"><a href=\"#8-resolve-vs-reject\" class=\"headerlink\" title=\"8.resolve vs reject\"></a>8.resolve vs reject</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p1 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(Promise.resolve(&apos;resolve&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var p2 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  resolve(Promise.reject(&apos;reject&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var p3 = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">  reject(Promise.resolve(&apos;resolve&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p1.then(</div><div class=\"line\">  function fulfilled(value)&#123;</div><div class=\"line\">    console.log(&apos;fulfilled: &apos; + value);</div><div class=\"line\">  &#125;, </div><div class=\"line\">  function rejected(err)&#123;</div><div class=\"line\">    console.log(&apos;rejected: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">p2.then(</div><div class=\"line\">  function fulfilled(value)&#123;</div><div class=\"line\">    console.log(&apos;fulfilled: &apos; + value);</div><div class=\"line\">  &#125;, </div><div class=\"line\">  function rejected(err)&#123;</div><div class=\"line\">    console.log(&apos;rejected: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">p3.then(</div><div class=\"line\">  function fulfilled(value)&#123;</div><div class=\"line\">    console.log(&apos;fulfilled: &apos; + value);</div><div class=\"line\">  &#125;, </div><div class=\"line\">  function rejected(err)&#123;</div><div class=\"line\">    console.log(&apos;rejected: &apos; + err);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">p3 rejected: [object Promise]</div><div class=\"line\">p1 fulfilled: resolve</div><div class=\"line\">p2 rejected: reject</div></pre></td></tr></table></figure>\n<p>Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</p>\n"},{"title":"vue子组件与父组件通讯","_content":"1.创建文件Order.js，内容为：\n```\n\"use strict\";\nimport Vue from 'vue';\nexport var Order = new Vue();\n```\n2.在父组件里导入Order.js并监听事件,父组件内容为:\n```\nimport { Order } from './Order.js'\n// ...\ncreated () {\n  Order.$on('tip', (text) => {\n    alert(text)\n  })\n}\n```\n3.在子组件里导入Order.js并发送事件,子组件内容为:\n```\nimport { Order } from './Order.js'\n // ...\nOrder.$emit('tip', '123')\n```","source":"_posts/order.md","raw":"---\ntitle: vue子组件与父组件通讯\n---\n1.创建文件Order.js，内容为：\n```\n\"use strict\";\nimport Vue from 'vue';\nexport var Order = new Vue();\n```\n2.在父组件里导入Order.js并监听事件,父组件内容为:\n```\nimport { Order } from './Order.js'\n// ...\ncreated () {\n  Order.$on('tip', (text) => {\n    alert(text)\n  })\n}\n```\n3.在子组件里导入Order.js并发送事件,子组件内容为:\n```\nimport { Order } from './Order.js'\n // ...\nOrder.$emit('tip', '123')\n```","slug":"order","published":1,"date":"2017-07-21T08:02:45.039Z","updated":"2017-07-21T08:10:51.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6eufsvu000e38tzweud3uhl","content":"<p>1.创建文件Order.js，内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">import Vue from &apos;vue&apos;;</div><div class=\"line\">export var Order = new Vue();</div></pre></td></tr></table></figure></p>\n<p>2.在父组件里导入Order.js并监听事件,父组件内容为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; Order &#125; from &apos;./Order.js&apos;</div><div class=\"line\">// ...</div><div class=\"line\">created () &#123;</div><div class=\"line\">  Order.$on(&apos;tip&apos;, (text) =&gt; &#123;</div><div class=\"line\">    alert(text)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>3.在子组件里导入Order.js并发送事件,子组件内容为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; Order &#125; from &apos;./Order.js&apos;</div><div class=\"line\"> // ...</div><div class=\"line\">Order.$emit(&apos;tip&apos;, &apos;123&apos;)</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.创建文件Order.js，内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">import Vue from &apos;vue&apos;;</div><div class=\"line\">export var Order = new Vue();</div></pre></td></tr></table></figure></p>\n<p>2.在父组件里导入Order.js并监听事件,父组件内容为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; Order &#125; from &apos;./Order.js&apos;</div><div class=\"line\">// ...</div><div class=\"line\">created () &#123;</div><div class=\"line\">  Order.$on(&apos;tip&apos;, (text) =&gt; &#123;</div><div class=\"line\">    alert(text)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>3.在子组件里导入Order.js并发送事件,子组件内容为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; Order &#125; from &apos;./Order.js&apos;</div><div class=\"line\"> // ...</div><div class=\"line\">Order.$emit(&apos;tip&apos;, &apos;123&apos;)</div></pre></td></tr></table></figure></p>\n"},{"title":"ES2017异步函数现已正式可用","_content":"ES2017标准已于2017年6月份正式定稿了，并广泛支持最新的特性：异步函数。如果你曾经被异步 JavaScript 的逻辑困扰，这么新函数正是为你设计的。\n\n异步函数或多或少会让你编写一些顺序的 JavaScript 代码，但是却不需要在 callbacks、generators 或 promise 中包含你的逻辑。\n\n如下代码：\n```\nfunction logger() {\n    let data = fetch('http://sampleapi.com/posts')\n    console.log(data)\n}\nlogger()\n```\n\n这段代码并未实现你的预期。如果你是在JS中编写的，那么你可能会知道为什么。\n\n下面这段代码，却实现了你的预期。\n```\nasync function logger() {\n    let data = await fetch('http:sampleapi.com/posts')\n    console.log(data)\n}\nlogger()\n```\n\n这段代码起作用了，从直观上看，仅仅只是多了 async 和 await 两个词。\n\n \n\nES6 标准之前的 JavaScript 异步函数\n\n在深入学习 async 和 await 之前，我们需要先理解 Promise。为了领会 Promise，我们需要回到普通回调函数中进一步学习。\n\nPromise 是在 ES6 中引入的，并促使在编写 JavaScript 的异步代码方面，实现了巨大的提升。从此编写回调函数不再那么痛苦。\n\n回调是一个函数，可以将结果传递给函数并在该函数内进行调用，以便作为事件的响应。同时，这也是JS的基础。\n```\nfunction readFile('file.txt', (data) => {\n    // This is inside the callback function\n    console.log(data)\n}\n```\n\n这个函数只是简单的向文件中记录数据，在文件完成之前进行读取是不可能的。这个过程似乎很简单，但是如果想要按顺序读取并记录五个不同的文件，需要怎么实现呢？\n\n没有 Promise 的时候，为了按顺序执行任务，就需要通过嵌套回调来实现，就像下面的代码：\n```\n// This is officially callback hell\nfunction combineFiles(file1, file2, file3, printFileCallBack) {\n    let newFileText = ''\n    readFile(string1, (text) => {\n        newFileText += text\n        readFile(string2, (text) => {\n            newFileText += text\n            readFile(string3, (text) => {\n                newFileText += text\n                printFileCallBack(newFileText)\n            }\n        }\n    }\n}\n```\n这就很难推断函数下面会发生什么，同时也很难处理各种场景下发生的错误，比如其中某个文件不存在的情况。\n\n \n\nPromise 改善了这种情况\n\n这正是 Promise 的优势所在，Promise 是对还未产生的数据的一种推理。Kyle Simpson 将 Promise 解释为：就像在快餐店里点餐一样。\n\n* 点餐\n* 为所点的午餐付费，并拿到排队单号\n* 等待午餐\n* 当你的午餐准备好了，会叫你的单号提醒你取餐\n* 收到午餐\n\n正如上面的这种场景，当你等餐时，你是无法吃到午餐的，但是你可以提前为吃午餐做好准备。你可以进行其它事情，此时你知道午餐就要来了，虽然此刻你还无法享用它，但是这个午餐已经“promise”给你了。这就是所谓的 promise，表示一个最终会存在的数据的对象。\n```\nreadFile(file1)\n    .then((file1-data) => { /* do something */ })\n    .then((previous-promise-data) => { /* do the next thing */ })\n    .catch( /* handle errors */ )\n```\n上面是 Promise 语法。它主要的优点就是可以将队列事件以一种直观的方式链接在一起。虽然这个示例清晰易懂，但是还是用到了回调。Promise 只是让回调显得比较简单和更加直观。\n\n \n\n最佳方式：async / await\n\n若干年前，async 函数纳入了 JavaScript 生态系统。就在上个月，async 函数成为了 JavaScript 语言的官方特性，并得到了广泛支持。\n\nasync 和 await 是建立在 Promise 和 generator上。本质上，允许我们使用 await 这个关键词在任何函数中的任何我们想要的地方进行暂停。\n```\nasync function logger() {\n    // pause until fetch returns\n    let data = await fetch('http://sampleapi.com/posts')\n    console.log(data)\n}\n```\n\n上面这段代码运行之后，得到了想要的结果。代码从 API 调用中记录了数据。\n\n这种方式的好处就是非常直观。编写代码的方式就是大脑思考的方式，告诉脚本在需要的地方暂停。\n\n另一个好处是，当我们不能使用 promise 时，还可以使用 try 和 catch：\n```\nasync function logger ()  {\n    try {\n        let user_id = await fetch('/api/users/username')\n        let posts = await fetch('/api/`${user_id}`')\n        let object = JSON.parse(user.posts.toString())\n        console.log(posts)\n    } catch (error) {\n        console.error('Error:', error)\n    }\n}\n```\n\n上面是一个刻意写错的示例，为了证明了一点：在运行过程中，catch 可以捕获任何步骤中发生的错误。至少有三个地方，try 可能会失败，这是在异步代码中的一种最干净的方式来处理错误。\n\n我们还可以使用带有循环和条件的 async 函数：\n```\nasync function count() {\n    let counter = 1\n    for (let i = 0; i < 100; i++) {\n        counter += 1\n        console.log(counter)\n        await sleep(1000)\n    }\n}\n```\n\n这是一个很简答的例子，如果运行这段程序，将会看到代码在 sleep 调用时暂停，下一个循环迭代将会在1秒后启动。\n\n \n\n要点和细节\n\n相信我们已经感受到了 asyns 和 await 的美妙之处，接下来让我们深入了解一下细节：\n\nasync 和 await 建立在 Promise 之上。使用 async，总是会返回一个 Promise。请记住这一点，因为这也是容易犯错的地方。\n当执行到 await 时，程序会暂停当前函数，而不是所有代码\nasync 和 await 是非阻塞的\n依旧可以使用 Promise helpers，例如 Promise.all( )\n正如之前的示例：\n```\nasync function logPosts ()  {\n    try {\n        let user_id = await fetch('/api/users/username')\n        let post_ids = await fetch('/api/posts/<code>${user_id}')\n        let promises = post_ids.map(post_id => {\n            return  fetch('/api/posts/${post_id}')\n        }\n        let posts = await Promise.all(promises)\n        console.log(posts)\n    } catch (error) {\n        console.error('Error:', error)\n    }\n}\n```\n\nawait 只能用于声明为 async 的函数中\n因此，不能在全局范围内使用 await\n如下代码：\n```\n// throws an error\nfunction logger (callBack) {\n    console.log(await callBack)\n}\n\n// works!\nasync function logger () {\n    console.log(await callBack)\n}\n```\n\n现已正式可用\n\n到2017年6月，几乎所有浏览器都可以使用 async 和 await。为了确保你的代码随时可用，则需要使用 Babel 将你的 JavaScript 代码编译为旧浏览器也支持的语法。\n\n如果对更多ES2017内容感兴趣，请访问ES2017特性的完整列表。","source":"_posts/es2017.md","raw":"---\ntitle: ES2017异步函数现已正式可用\n---\nES2017标准已于2017年6月份正式定稿了，并广泛支持最新的特性：异步函数。如果你曾经被异步 JavaScript 的逻辑困扰，这么新函数正是为你设计的。\n\n异步函数或多或少会让你编写一些顺序的 JavaScript 代码，但是却不需要在 callbacks、generators 或 promise 中包含你的逻辑。\n\n如下代码：\n```\nfunction logger() {\n    let data = fetch('http://sampleapi.com/posts')\n    console.log(data)\n}\nlogger()\n```\n\n这段代码并未实现你的预期。如果你是在JS中编写的，那么你可能会知道为什么。\n\n下面这段代码，却实现了你的预期。\n```\nasync function logger() {\n    let data = await fetch('http:sampleapi.com/posts')\n    console.log(data)\n}\nlogger()\n```\n\n这段代码起作用了，从直观上看，仅仅只是多了 async 和 await 两个词。\n\n \n\nES6 标准之前的 JavaScript 异步函数\n\n在深入学习 async 和 await 之前，我们需要先理解 Promise。为了领会 Promise，我们需要回到普通回调函数中进一步学习。\n\nPromise 是在 ES6 中引入的，并促使在编写 JavaScript 的异步代码方面，实现了巨大的提升。从此编写回调函数不再那么痛苦。\n\n回调是一个函数，可以将结果传递给函数并在该函数内进行调用，以便作为事件的响应。同时，这也是JS的基础。\n```\nfunction readFile('file.txt', (data) => {\n    // This is inside the callback function\n    console.log(data)\n}\n```\n\n这个函数只是简单的向文件中记录数据，在文件完成之前进行读取是不可能的。这个过程似乎很简单，但是如果想要按顺序读取并记录五个不同的文件，需要怎么实现呢？\n\n没有 Promise 的时候，为了按顺序执行任务，就需要通过嵌套回调来实现，就像下面的代码：\n```\n// This is officially callback hell\nfunction combineFiles(file1, file2, file3, printFileCallBack) {\n    let newFileText = ''\n    readFile(string1, (text) => {\n        newFileText += text\n        readFile(string2, (text) => {\n            newFileText += text\n            readFile(string3, (text) => {\n                newFileText += text\n                printFileCallBack(newFileText)\n            }\n        }\n    }\n}\n```\n这就很难推断函数下面会发生什么，同时也很难处理各种场景下发生的错误，比如其中某个文件不存在的情况。\n\n \n\nPromise 改善了这种情况\n\n这正是 Promise 的优势所在，Promise 是对还未产生的数据的一种推理。Kyle Simpson 将 Promise 解释为：就像在快餐店里点餐一样。\n\n* 点餐\n* 为所点的午餐付费，并拿到排队单号\n* 等待午餐\n* 当你的午餐准备好了，会叫你的单号提醒你取餐\n* 收到午餐\n\n正如上面的这种场景，当你等餐时，你是无法吃到午餐的，但是你可以提前为吃午餐做好准备。你可以进行其它事情，此时你知道午餐就要来了，虽然此刻你还无法享用它，但是这个午餐已经“promise”给你了。这就是所谓的 promise，表示一个最终会存在的数据的对象。\n```\nreadFile(file1)\n    .then((file1-data) => { /* do something */ })\n    .then((previous-promise-data) => { /* do the next thing */ })\n    .catch( /* handle errors */ )\n```\n上面是 Promise 语法。它主要的优点就是可以将队列事件以一种直观的方式链接在一起。虽然这个示例清晰易懂，但是还是用到了回调。Promise 只是让回调显得比较简单和更加直观。\n\n \n\n最佳方式：async / await\n\n若干年前，async 函数纳入了 JavaScript 生态系统。就在上个月，async 函数成为了 JavaScript 语言的官方特性，并得到了广泛支持。\n\nasync 和 await 是建立在 Promise 和 generator上。本质上，允许我们使用 await 这个关键词在任何函数中的任何我们想要的地方进行暂停。\n```\nasync function logger() {\n    // pause until fetch returns\n    let data = await fetch('http://sampleapi.com/posts')\n    console.log(data)\n}\n```\n\n上面这段代码运行之后，得到了想要的结果。代码从 API 调用中记录了数据。\n\n这种方式的好处就是非常直观。编写代码的方式就是大脑思考的方式，告诉脚本在需要的地方暂停。\n\n另一个好处是，当我们不能使用 promise 时，还可以使用 try 和 catch：\n```\nasync function logger ()  {\n    try {\n        let user_id = await fetch('/api/users/username')\n        let posts = await fetch('/api/`${user_id}`')\n        let object = JSON.parse(user.posts.toString())\n        console.log(posts)\n    } catch (error) {\n        console.error('Error:', error)\n    }\n}\n```\n\n上面是一个刻意写错的示例，为了证明了一点：在运行过程中，catch 可以捕获任何步骤中发生的错误。至少有三个地方，try 可能会失败，这是在异步代码中的一种最干净的方式来处理错误。\n\n我们还可以使用带有循环和条件的 async 函数：\n```\nasync function count() {\n    let counter = 1\n    for (let i = 0; i < 100; i++) {\n        counter += 1\n        console.log(counter)\n        await sleep(1000)\n    }\n}\n```\n\n这是一个很简答的例子，如果运行这段程序，将会看到代码在 sleep 调用时暂停，下一个循环迭代将会在1秒后启动。\n\n \n\n要点和细节\n\n相信我们已经感受到了 asyns 和 await 的美妙之处，接下来让我们深入了解一下细节：\n\nasync 和 await 建立在 Promise 之上。使用 async，总是会返回一个 Promise。请记住这一点，因为这也是容易犯错的地方。\n当执行到 await 时，程序会暂停当前函数，而不是所有代码\nasync 和 await 是非阻塞的\n依旧可以使用 Promise helpers，例如 Promise.all( )\n正如之前的示例：\n```\nasync function logPosts ()  {\n    try {\n        let user_id = await fetch('/api/users/username')\n        let post_ids = await fetch('/api/posts/<code>${user_id}')\n        let promises = post_ids.map(post_id => {\n            return  fetch('/api/posts/${post_id}')\n        }\n        let posts = await Promise.all(promises)\n        console.log(posts)\n    } catch (error) {\n        console.error('Error:', error)\n    }\n}\n```\n\nawait 只能用于声明为 async 的函数中\n因此，不能在全局范围内使用 await\n如下代码：\n```\n// throws an error\nfunction logger (callBack) {\n    console.log(await callBack)\n}\n\n// works!\nasync function logger () {\n    console.log(await callBack)\n}\n```\n\n现已正式可用\n\n到2017年6月，几乎所有浏览器都可以使用 async 和 await。为了确保你的代码随时可用，则需要使用 Babel 将你的 JavaScript 代码编译为旧浏览器也支持的语法。\n\n如果对更多ES2017内容感兴趣，请访问ES2017特性的完整列表。","slug":"es2017","published":1,"date":"2017-08-22T05:58:24.541Z","updated":"2017-08-22T06:03:24.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n6q2lu00003ctzyaib4edf","content":"<p>ES2017标准已于2017年6月份正式定稿了，并广泛支持最新的特性：异步函数。如果你曾经被异步 JavaScript 的逻辑困扰，这么新函数正是为你设计的。</p>\n<p>异步函数或多或少会让你编写一些顺序的 JavaScript 代码，但是却不需要在 callbacks、generators 或 promise 中包含你的逻辑。</p>\n<p>如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function logger() &#123;</div><div class=\"line\">    let data = fetch(&apos;http://sampleapi.com/posts&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">&#125;</div><div class=\"line\">logger()</div></pre></td></tr></table></figure></p>\n<p>这段代码并未实现你的预期。如果你是在JS中编写的，那么你可能会知道为什么。</p>\n<p>下面这段代码，却实现了你的预期。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function logger() &#123;</div><div class=\"line\">    let data = await fetch(&apos;http:sampleapi.com/posts&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">&#125;</div><div class=\"line\">logger()</div></pre></td></tr></table></figure></p>\n<p>这段代码起作用了，从直观上看，仅仅只是多了 async 和 await 两个词。</p>\n<p>ES6 标准之前的 JavaScript 异步函数</p>\n<p>在深入学习 async 和 await 之前，我们需要先理解 Promise。为了领会 Promise，我们需要回到普通回调函数中进一步学习。</p>\n<p>Promise 是在 ES6 中引入的，并促使在编写 JavaScript 的异步代码方面，实现了巨大的提升。从此编写回调函数不再那么痛苦。</p>\n<p>回调是一个函数，可以将结果传递给函数并在该函数内进行调用，以便作为事件的响应。同时，这也是JS的基础。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function readFile(&apos;file.txt&apos;, (data) =&gt; &#123;</div><div class=\"line\">    // This is inside the callback function</div><div class=\"line\">    console.log(data)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个函数只是简单的向文件中记录数据，在文件完成之前进行读取是不可能的。这个过程似乎很简单，但是如果想要按顺序读取并记录五个不同的文件，需要怎么实现呢？</p>\n<p>没有 Promise 的时候，为了按顺序执行任务，就需要通过嵌套回调来实现，就像下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// This is officially callback hell</div><div class=\"line\">function combineFiles(file1, file2, file3, printFileCallBack) &#123;</div><div class=\"line\">    let newFileText = &apos;&apos;</div><div class=\"line\">    readFile(string1, (text) =&gt; &#123;</div><div class=\"line\">        newFileText += text</div><div class=\"line\">        readFile(string2, (text) =&gt; &#123;</div><div class=\"line\">            newFileText += text</div><div class=\"line\">            readFile(string3, (text) =&gt; &#123;</div><div class=\"line\">                newFileText += text</div><div class=\"line\">                printFileCallBack(newFileText)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这就很难推断函数下面会发生什么，同时也很难处理各种场景下发生的错误，比如其中某个文件不存在的情况。</p>\n<p>Promise 改善了这种情况</p>\n<p>这正是 Promise 的优势所在，Promise 是对还未产生的数据的一种推理。Kyle Simpson 将 Promise 解释为：就像在快餐店里点餐一样。</p>\n<ul>\n<li>点餐</li>\n<li>为所点的午餐付费，并拿到排队单号</li>\n<li>等待午餐</li>\n<li>当你的午餐准备好了，会叫你的单号提醒你取餐</li>\n<li>收到午餐</li>\n</ul>\n<p>正如上面的这种场景，当你等餐时，你是无法吃到午餐的，但是你可以提前为吃午餐做好准备。你可以进行其它事情，此时你知道午餐就要来了，虽然此刻你还无法享用它，但是这个午餐已经“promise”给你了。这就是所谓的 promise，表示一个最终会存在的数据的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">readFile(file1)</div><div class=\"line\">    .then((file1-data) =&gt; &#123; /* do something */ &#125;)</div><div class=\"line\">    .then((previous-promise-data) =&gt; &#123; /* do the next thing */ &#125;)</div><div class=\"line\">    .catch( /* handle errors */ )</div></pre></td></tr></table></figure></p>\n<p>上面是 Promise 语法。它主要的优点就是可以将队列事件以一种直观的方式链接在一起。虽然这个示例清晰易懂，但是还是用到了回调。Promise 只是让回调显得比较简单和更加直观。</p>\n<p>最佳方式：async / await</p>\n<p>若干年前，async 函数纳入了 JavaScript 生态系统。就在上个月，async 函数成为了 JavaScript 语言的官方特性，并得到了广泛支持。</p>\n<p>async 和 await 是建立在 Promise 和 generator上。本质上，允许我们使用 await 这个关键词在任何函数中的任何我们想要的地方进行暂停。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function logger() &#123;</div><div class=\"line\">    // pause until fetch returns</div><div class=\"line\">    let data = await fetch(&apos;http://sampleapi.com/posts&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面这段代码运行之后，得到了想要的结果。代码从 API 调用中记录了数据。</p>\n<p>这种方式的好处就是非常直观。编写代码的方式就是大脑思考的方式，告诉脚本在需要的地方暂停。</p>\n<p>另一个好处是，当我们不能使用 promise 时，还可以使用 try 和 catch：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function logger ()  &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        let user_id = await fetch(&apos;/api/users/username&apos;)</div><div class=\"line\">        let posts = await fetch(&apos;/api/`$&#123;user_id&#125;`&apos;)</div><div class=\"line\">        let object = JSON.parse(user.posts.toString())</div><div class=\"line\">        console.log(posts)</div><div class=\"line\">    &#125; catch (error) &#123;</div><div class=\"line\">        console.error(&apos;Error:&apos;, error)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面是一个刻意写错的示例，为了证明了一点：在运行过程中，catch 可以捕获任何步骤中发生的错误。至少有三个地方，try 可能会失败，这是在异步代码中的一种最干净的方式来处理错误。</p>\n<p>我们还可以使用带有循环和条件的 async 函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function count() &#123;</div><div class=\"line\">    let counter = 1</div><div class=\"line\">    for (let i = 0; i &lt; 100; i++) &#123;</div><div class=\"line\">        counter += 1</div><div class=\"line\">        console.log(counter)</div><div class=\"line\">        await sleep(1000)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这是一个很简答的例子，如果运行这段程序，将会看到代码在 sleep 调用时暂停，下一个循环迭代将会在1秒后启动。</p>\n<p>要点和细节</p>\n<p>相信我们已经感受到了 asyns 和 await 的美妙之处，接下来让我们深入了解一下细节：</p>\n<p>async 和 await 建立在 Promise 之上。使用 async，总是会返回一个 Promise。请记住这一点，因为这也是容易犯错的地方。<br>当执行到 await 时，程序会暂停当前函数，而不是所有代码<br>async 和 await 是非阻塞的<br>依旧可以使用 Promise helpers，例如 Promise.all( )<br>正如之前的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function logPosts ()  &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        let user_id = await fetch(&apos;/api/users/username&apos;)</div><div class=\"line\">        let post_ids = await fetch(&apos;/api/posts/&lt;code&gt;$&#123;user_id&#125;&apos;)</div><div class=\"line\">        let promises = post_ids.map(post_id =&gt; &#123;</div><div class=\"line\">            return  fetch(&apos;/api/posts/$&#123;post_id&#125;&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        let posts = await Promise.all(promises)</div><div class=\"line\">        console.log(posts)</div><div class=\"line\">    &#125; catch (error) &#123;</div><div class=\"line\">        console.error(&apos;Error:&apos;, error)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>await 只能用于声明为 async 的函数中<br>因此，不能在全局范围内使用 await<br>如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// throws an error</div><div class=\"line\">function logger (callBack) &#123;</div><div class=\"line\">    console.log(await callBack)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// works!</div><div class=\"line\">async function logger () &#123;</div><div class=\"line\">    console.log(await callBack)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>现已正式可用</p>\n<p>到2017年6月，几乎所有浏览器都可以使用 async 和 await。为了确保你的代码随时可用，则需要使用 Babel 将你的 JavaScript 代码编译为旧浏览器也支持的语法。</p>\n<p>如果对更多ES2017内容感兴趣，请访问ES2017特性的完整列表。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ES2017标准已于2017年6月份正式定稿了，并广泛支持最新的特性：异步函数。如果你曾经被异步 JavaScript 的逻辑困扰，这么新函数正是为你设计的。</p>\n<p>异步函数或多或少会让你编写一些顺序的 JavaScript 代码，但是却不需要在 callbacks、generators 或 promise 中包含你的逻辑。</p>\n<p>如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function logger() &#123;</div><div class=\"line\">    let data = fetch(&apos;http://sampleapi.com/posts&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">&#125;</div><div class=\"line\">logger()</div></pre></td></tr></table></figure></p>\n<p>这段代码并未实现你的预期。如果你是在JS中编写的，那么你可能会知道为什么。</p>\n<p>下面这段代码，却实现了你的预期。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function logger() &#123;</div><div class=\"line\">    let data = await fetch(&apos;http:sampleapi.com/posts&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">&#125;</div><div class=\"line\">logger()</div></pre></td></tr></table></figure></p>\n<p>这段代码起作用了，从直观上看，仅仅只是多了 async 和 await 两个词。</p>\n<p>ES6 标准之前的 JavaScript 异步函数</p>\n<p>在深入学习 async 和 await 之前，我们需要先理解 Promise。为了领会 Promise，我们需要回到普通回调函数中进一步学习。</p>\n<p>Promise 是在 ES6 中引入的，并促使在编写 JavaScript 的异步代码方面，实现了巨大的提升。从此编写回调函数不再那么痛苦。</p>\n<p>回调是一个函数，可以将结果传递给函数并在该函数内进行调用，以便作为事件的响应。同时，这也是JS的基础。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function readFile(&apos;file.txt&apos;, (data) =&gt; &#123;</div><div class=\"line\">    // This is inside the callback function</div><div class=\"line\">    console.log(data)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个函数只是简单的向文件中记录数据，在文件完成之前进行读取是不可能的。这个过程似乎很简单，但是如果想要按顺序读取并记录五个不同的文件，需要怎么实现呢？</p>\n<p>没有 Promise 的时候，为了按顺序执行任务，就需要通过嵌套回调来实现，就像下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// This is officially callback hell</div><div class=\"line\">function combineFiles(file1, file2, file3, printFileCallBack) &#123;</div><div class=\"line\">    let newFileText = &apos;&apos;</div><div class=\"line\">    readFile(string1, (text) =&gt; &#123;</div><div class=\"line\">        newFileText += text</div><div class=\"line\">        readFile(string2, (text) =&gt; &#123;</div><div class=\"line\">            newFileText += text</div><div class=\"line\">            readFile(string3, (text) =&gt; &#123;</div><div class=\"line\">                newFileText += text</div><div class=\"line\">                printFileCallBack(newFileText)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这就很难推断函数下面会发生什么，同时也很难处理各种场景下发生的错误，比如其中某个文件不存在的情况。</p>\n<p>Promise 改善了这种情况</p>\n<p>这正是 Promise 的优势所在，Promise 是对还未产生的数据的一种推理。Kyle Simpson 将 Promise 解释为：就像在快餐店里点餐一样。</p>\n<ul>\n<li>点餐</li>\n<li>为所点的午餐付费，并拿到排队单号</li>\n<li>等待午餐</li>\n<li>当你的午餐准备好了，会叫你的单号提醒你取餐</li>\n<li>收到午餐</li>\n</ul>\n<p>正如上面的这种场景，当你等餐时，你是无法吃到午餐的，但是你可以提前为吃午餐做好准备。你可以进行其它事情，此时你知道午餐就要来了，虽然此刻你还无法享用它，但是这个午餐已经“promise”给你了。这就是所谓的 promise，表示一个最终会存在的数据的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">readFile(file1)</div><div class=\"line\">    .then((file1-data) =&gt; &#123; /* do something */ &#125;)</div><div class=\"line\">    .then((previous-promise-data) =&gt; &#123; /* do the next thing */ &#125;)</div><div class=\"line\">    .catch( /* handle errors */ )</div></pre></td></tr></table></figure></p>\n<p>上面是 Promise 语法。它主要的优点就是可以将队列事件以一种直观的方式链接在一起。虽然这个示例清晰易懂，但是还是用到了回调。Promise 只是让回调显得比较简单和更加直观。</p>\n<p>最佳方式：async / await</p>\n<p>若干年前，async 函数纳入了 JavaScript 生态系统。就在上个月，async 函数成为了 JavaScript 语言的官方特性，并得到了广泛支持。</p>\n<p>async 和 await 是建立在 Promise 和 generator上。本质上，允许我们使用 await 这个关键词在任何函数中的任何我们想要的地方进行暂停。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function logger() &#123;</div><div class=\"line\">    // pause until fetch returns</div><div class=\"line\">    let data = await fetch(&apos;http://sampleapi.com/posts&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面这段代码运行之后，得到了想要的结果。代码从 API 调用中记录了数据。</p>\n<p>这种方式的好处就是非常直观。编写代码的方式就是大脑思考的方式，告诉脚本在需要的地方暂停。</p>\n<p>另一个好处是，当我们不能使用 promise 时，还可以使用 try 和 catch：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function logger ()  &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        let user_id = await fetch(&apos;/api/users/username&apos;)</div><div class=\"line\">        let posts = await fetch(&apos;/api/`$&#123;user_id&#125;`&apos;)</div><div class=\"line\">        let object = JSON.parse(user.posts.toString())</div><div class=\"line\">        console.log(posts)</div><div class=\"line\">    &#125; catch (error) &#123;</div><div class=\"line\">        console.error(&apos;Error:&apos;, error)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面是一个刻意写错的示例，为了证明了一点：在运行过程中，catch 可以捕获任何步骤中发生的错误。至少有三个地方，try 可能会失败，这是在异步代码中的一种最干净的方式来处理错误。</p>\n<p>我们还可以使用带有循环和条件的 async 函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function count() &#123;</div><div class=\"line\">    let counter = 1</div><div class=\"line\">    for (let i = 0; i &lt; 100; i++) &#123;</div><div class=\"line\">        counter += 1</div><div class=\"line\">        console.log(counter)</div><div class=\"line\">        await sleep(1000)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这是一个很简答的例子，如果运行这段程序，将会看到代码在 sleep 调用时暂停，下一个循环迭代将会在1秒后启动。</p>\n<p>要点和细节</p>\n<p>相信我们已经感受到了 asyns 和 await 的美妙之处，接下来让我们深入了解一下细节：</p>\n<p>async 和 await 建立在 Promise 之上。使用 async，总是会返回一个 Promise。请记住这一点，因为这也是容易犯错的地方。<br>当执行到 await 时，程序会暂停当前函数，而不是所有代码<br>async 和 await 是非阻塞的<br>依旧可以使用 Promise helpers，例如 Promise.all( )<br>正如之前的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function logPosts ()  &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        let user_id = await fetch(&apos;/api/users/username&apos;)</div><div class=\"line\">        let post_ids = await fetch(&apos;/api/posts/&lt;code&gt;$&#123;user_id&#125;&apos;)</div><div class=\"line\">        let promises = post_ids.map(post_id =&gt; &#123;</div><div class=\"line\">            return  fetch(&apos;/api/posts/$&#123;post_id&#125;&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        let posts = await Promise.all(promises)</div><div class=\"line\">        console.log(posts)</div><div class=\"line\">    &#125; catch (error) &#123;</div><div class=\"line\">        console.error(&apos;Error:&apos;, error)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>await 只能用于声明为 async 的函数中<br>因此，不能在全局范围内使用 await<br>如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// throws an error</div><div class=\"line\">function logger (callBack) &#123;</div><div class=\"line\">    console.log(await callBack)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// works!</div><div class=\"line\">async function logger () &#123;</div><div class=\"line\">    console.log(await callBack)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>现已正式可用</p>\n<p>到2017年6月，几乎所有浏览器都可以使用 async 和 await。为了确保你的代码随时可用，则需要使用 Babel 将你的 JavaScript 代码编译为旧浏览器也支持的语法。</p>\n<p>如果对更多ES2017内容感兴趣，请访问ES2017特性的完整列表。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}