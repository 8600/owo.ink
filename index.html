<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  
  
  
  
  
  
  <title>owo.ink</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="owo.ink">
<meta property="og:url" content="https://owo.ink/index.html">
<meta property="og:site_name" content="owo.ink">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="owo.ink">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
  <hgroup>
    <h1 class="site-title">
      <a href="/" title="owo.ink" rel="home">owo.ink</a>
    </h1>
    
  </hgroup>

  <nav id="site-navigation" class="main-navigation" role="navigation">
    <button class="menu-toggle">菜单</button>
    <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
    <div class="menu-main-container">
      <ul id="menu-main" class="nav-menu">
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">主页</a></li>
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">归档</a></li>
      
      </ul>
    </div>
  </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-saveFile" class="post-saveFile post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/saveFile/">js保存文件</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 在本地进行文件保存</div><div class="line">* @param  &#123;String&#125; content     要保存到本地的图片数据</div><div class="line">* @param  &#123;String&#125; fileName 文件名</div><div class="line">*/</div><div class="line">saveFile (content, fileName) &#123;</div><div class="line">  const aLink = document.createElement(&apos;a&apos;)</div><div class="line">  const blob = new Blob([content], &#123;</div><div class="line">    type: &apos;text/plain&apos;</div><div class="line">  &#125;)</div><div class="line">  aLink.download = fileName</div><div class="line">  aLink.href = URL.createObjectURL(blob)</div><div class="line">  aLink.click()</div><div class="line">  URL.revokeObjectURL(blob)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 在本地进行文件保存</div><div class="line">* @param  &#123;String&#125; content     要保存到本地的图片数据</div><div class="line">* @param  &#123;String&#125; fileName 文件名</div><div class="line">*/</div><div class="line">saveFile (content, fileName) &#123;</div><div class="line">  let saveLink = document.createElementNS(&apos;http://www.w3.org/1999/xhtml&apos;, &apos;a&apos;)</div><div class="line">  saveLink.href = data</div><div class="line">  saveLink.download = filename</div><div class="line">  const event = document.createEvent(&apos;MouseEvents&apos;)</div><div class="line">  event.initMouseEvent(&apos;click&apos;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null)</div><div class="line">  saveLink.dispatchEvent(event)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/saveFile/">
    <time datetime="2017-11-23T01:45:54.029Z" class="entry-date">
        2017-11-23
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-string" class="post-string post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/string/">JavaScript 字符串实用常操纪要</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h6 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h6><h5 id="1-substring"><a href="#1-substring" class="headerlink" title="1. substring()"></a>1. substring()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xString.substring(start,end)</div></pre></td></tr></table></figure>
<p>substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(str.substring(0,3)) // www</div><div class="line">console.log(str.substring(0))   //www.jeffjade.com</div><div class="line">console.log(str.substring(-2))  //www.jeffjade.com (传负值则视为0)</div></pre></td></tr></table></figure>
<h5 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice()"></a>2. slice()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stringObject.slice(start, end)</div></pre></td></tr></table></figure>
<p>slice()方法与substring()方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，slice()中的参数可以为负值，如果参数是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(str.slice(0, 3))    // www</div><div class="line">console.log(str.slice(-3, -1))  // co</div><div class="line">console.log(str.slice(1, -1))   // www.jeffjade.co</div><div class="line">console.log(str.slice(2, 1))    // &apos;&apos; (返回空字符串,start须小于end)</div><div class="line">console.log(str.slice(-3, 0))   // &apos;&apos; (返回空字符串,start须小于end)</div></pre></td></tr></table></figure>
<h5 id="3-substr"><a href="#3-substr" class="headerlink" title="3. substr()"></a>3. substr()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stringObject.substr(start,length)</div></pre></td></tr></table></figure>
<p>substr()方法可在字符串中抽取从start下标开始的指定数目的字符。其返回值为一个字符串，包含从 stringObject的start（包括start所指的字符）处开始的length个字符。如果没有指定 length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，则表示从字符串尾部开始算起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(webStr.substr(1, 3))   // ww.</div><div class="line">console.log(webStr.substr(0))      // www.jeffjade.com</div><div class="line">console.log(webStr.substr(-3, 3))  // com</div><div class="line">console.log(webStr.substr(-1, 5))  // m  (目标长度较大的话，以实际截取的长度为准)</div></pre></td></tr></table></figure>
<h5 id="4-split"><a href="#4-split" class="headerlink" title="4. split()"></a>4. split()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str.split([separator][, limit])</div></pre></td></tr></table></figure>
<ul>
<li>separator 指定用来分割字符串的字符（串）。separator 可以是一个字符串或正则表达式。 如果忽略 separator，则返回整个字符串的数组形式。如果 separator 是一个空字符串，则 str 将会把原字符串中每个字符的数组形式返回。</li>
<li>limit 一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">str.split(&apos;.&apos;)      // [&quot;www&quot;, &quot;jeffjade&quot;, &quot;com&quot;]</div><div class="line">str.split(&apos;.&apos;, 1)   // [&quot;www&quot;]</div><div class="line">str.split(&apos;.&apos;).join(&apos;&apos;) // wwwjeffjadecom</div></pre></td></tr></table></figure>
<p>话说这个函数真心好用，很多时候的字符截取需求，就是依赖于某个字符；而以上三个函数都需知道其位置。我们当然可以借助 indexOf 等方法获取，很显然这很繁琐；而借助 split 则显得更轻而易举。</p>
<h5 id="5-replace"><a href="#5-replace" class="headerlink" title="5. replace()"></a>5. replace()</h5><p>replace，这个方法挺有用。如果是在稍微擅长正则的情形下，用 replace 等方法，来截取字符串，也是一个挺不错的选择；这对于某些场景下，可达到事半功倍之效，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let str = &apos;jeff@nice&amp;jade&apos;</div><div class="line">str.replace(/@[\s\S]*/g, &apos;&apos;)       // &quot;jeff&quot;</div><div class="line">str.replace(/@[\s\S]*&amp;/g, &apos;&apos;)      // &quot;jeffjade&quot;</div></pre></td></tr></table></figure>
<h6 id="查找类方法"><a href="#查找类方法" class="headerlink" title="查找类方法"></a>查找类方法</h6><h5 id="1-indexOf-amp-includes"><a href="#1-indexOf-amp-includes" class="headerlink" title="1. indexOf() &amp; includes()"></a>1. indexOf() &amp; includes()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stringObject.indexOf(searchValue,fromIndex)</div></pre></td></tr></table></figure>
<p>indexOf()用来检索指定的字符串值在字符串中首次出现的位置。它可以接收两个参数，searchValue 表示要查找的子字符串，fromIndex 表示查找的开始位置，省略的话则从开始位置进行检索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(str.indexOf(&apos;.&apos;))     // 3</div><div class="line">console.log(str.indexOf(&apos;.&apos;, 1))  // 3</div><div class="line">console.log(str.indexOf(&apos;.&apos;, 5))  // 12</div><div class="line">console.log(str.indexOf(&apos;.&apos;, 12)) // -1</div></pre></td></tr></table></figure>
<p>虽然 indexOf()用来检索指定的字符串值在字符串中首次出现的位置 ，然而很多时候，使用它的场景在于判断字符串中是否存在指定的字符串；因此代码就会如此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (str.indexOf(&apos;yoursPecifiedStr&apos;) !== -1) &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要知道在这样的场景下，ES6 语言中的includes()就显得更优雅许多；includes() 方法用于判断一个字符串是否被包含在另一个字符串中，如果是返回true，否则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str.includes(searchString[, position])</div></pre></td></tr></table></figure>
<p>searchString 将要搜寻的子字符串。position 可选。从当前字符串的哪个索引位置开始搜寻子字符串；默认为0。需要注意的是，includes() 是区分大小写的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;Blue Whale&apos;.includes(&apos;blue&apos;); // returns false</div><div class="line">&apos;乔峰乔布斯乔帮主&apos;.includes(&apos;乔布斯&apos;); // returns true</div><div class="line">if (str.includes(&apos;yoursPecifiedStr&apos;)) &#123;</div><div class="line">    // do something(这样写是不是更为人性化？Yeah，这是一个更趋向人性化的时代嘛)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-lastIndexOf"><a href="#2-lastIndexOf" class="headerlink" title="2. lastIndexOf()"></a>2. lastIndexOf()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stringObject.lastIndexOf(searchValue,fromIndex)</div></pre></td></tr></table></figure>
<p>lastIndexOf()语法与indexOf()类似，它返回的是一个指定的子字符串值最后出现的位置，其检索顺序是从后向前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(str.lastIndexOf(&apos;.&apos;))     // 12</div><div class="line">console.log(str.lastIndexOf(&apos;.&apos;, 1))  // -1</div><div class="line">console.log(str.lastIndexOf(&apos;.&apos;, 5))  // 3</div><div class="line">console.log(str.lastIndexOf(&apos;.&apos;, 12)) // 12</div></pre></td></tr></table></figure>
<h5 id="3-search"><a href="#3-search" class="headerlink" title="3. search()"></a>3. search()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stringObject.search(substr)</div><div class="line">stringObject.search(regexp)</div></pre></td></tr></table></figure>
<p>search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(str.search(&apos;w&apos;))    // 0</div><div class="line">console.log(str.search(/j/g))   // 4</div><div class="line">console.log(str.search(/\./g))  // 3</div></pre></td></tr></table></figure>
<h5 id="4-match"><a href="#4-match" class="headerlink" title="4. match()"></a>4. match()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stringObject.match(substr)</div><div class="line">stringObject.match(regexp)</div></pre></td></tr></table></figure>
<p>match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p>
<p>如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let str = &apos;#1a2b3c4d5e#&apos;;</div><div class="line">console.log(str.match(&apos;A&apos;));    //返回null</div><div class="line">console.log(str.match(&apos;b&apos;));    //返回[&quot;b&quot;, index: 4, input: &quot;#1a2b3c4d5e#&quot;]</div><div class="line">console.log(str.match(/b/));    //返回[&quot;b&quot;, index: 4, input: &quot;#1a2b3c4d5e#&quot;]</div></pre></td></tr></table></figure>
<p>如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let str = &apos;#1a2b3c4d5e#&apos;</div><div class="line">console.log(str.match(/h/g))     //返回null</div><div class="line">console.log(str.match(/\d/g))    //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</div></pre></td></tr></table></figure>
<h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><h5 id="1-replace"><a href="#1-replace" class="headerlink" title="1. replace()"></a>1. replace()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stringObject.replace(regexp/substr,replacement)</div></pre></td></tr></table></figure>
<p>replace()方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。</p>
<p>如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(str.replace(&apos;w&apos;, &apos;W&apos;))   // Www.jeffjade.com</div><div class="line">console.log(str.replace(/w/, &apos;W&apos;))   // Www.jeffjade.com</div></pre></td></tr></table></figure>
<p>如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(str.replace(/w/g, &apos;W&apos;))   // WWW.jeffjade.com</div></pre></td></tr></table></figure>
<h5 id="2-toLowerCase-amp-toUpperCase"><a href="#2-toLowerCase-amp-toUpperCase" class="headerlink" title="2. toLowerCase() &amp; toUpperCase()"></a>2. toLowerCase() &amp; toUpperCase()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stringObject.toLowerCase()</div><div class="line">stringObject.toUpperCase()</div></pre></td></tr></table></figure>
<p>toLowerCase()方法可以把字符串中的大写字母转换为小写，toUpperCase()方法可以把字符串中的小写字母转换为大写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let str = &apos;www.jeffjade.com&apos;</div><div class="line">console.log(str.toLowerCase())   // www.jeffjade.com</div><div class="line">console.log(str.toUpperCase())   // WWW.JEFFJADE.COM</div></pre></td></tr></table></figure>
<h6 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function ncieFunc() &#123;</div><div class="line">  return &quot;四海无人对夕阳&quot;;</div><div class="line">&#125;</div><div class="line">var niceMan = &quot;陈寅恪&quot;;</div><div class="line">var jadeTalk = `一生负气成今日 \n $&#123;ncieFunc()&#125; ,</div><div class="line">语出 $&#123;niceMan&#125; 的《忆故居》。</div><div class="line">`</div><div class="line">console.log(jadeTalk)</div></pre></td></tr></table></figure>
<p>运行之，Chrome Console 输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">一生负气成今日</div><div class="line">四海无人对夕阳 ,</div><div class="line">语出 陈寅恪 的《忆故居》。</div></pre></td></tr></table></figure>
<h6 id="组合其法"><a href="#组合其法" class="headerlink" title="组合其法"></a>组合其法</h6><p>细看 JavaScript 提供的String Api，还是有蛮多的，也有些许废弃的，也有将在未来版本会出来的；这其中不乏很多也挺有用的，譬如： charAt(x)、charCodeAt(x)、concat(v1, v2,…)、fromCharCode(c1, c2,…) 等等,还有 ES6 对字符串的扩展，比如 字符串的遍历器接口，repeat() 等等，这可以参见 ES6-string，这里就不多赘述。</p>
<p>在实际代码生产中，很多时候需要用这些提供的基本方法，来打出一套组合拳，以解决其需求所需。很显然又可以借助 prototype 属性，将自造的各路拳法，其归置于 String 对象，然后天亮啦。这一步就看个人喜好了，这里抛出一二段，以引大玉。</p>
<h6 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String.prototype.reverse = function () &#123;</div><div class="line">	return this.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="去除空白行"><a href="#去除空白行" class="headerlink" title="去除空白行"></a>去除空白行</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String.prototype.removeBlankLines = function () &#123;</div><div class="line">	return this.replace(/(\n[\s\t]*\r*\n)/g, &apos;\n&apos;).replace(/^[\n\r\n\t]*|[\n\r\n\t]*$/g, &apos;&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="String转化为数组"><a href="#String转化为数组" class="headerlink" title="String转化为数组"></a>String转化为数组</h6><h5 id="1-转化为一维数组"><a href="#1-转化为一维数组" class="headerlink" title="1. 转化为一维数组"></a>1. 转化为一维数组</h5><p>场景是根据某子字符串转化，直接就用 split 就好；如果转换规则不统一，那么请自求多福吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let Str = &apos;陈寅恪,鲁迅,钱钟书,胡适,王国维,梁启超,吴宓,季羡林&apos;</div><div class="line">let hallAllOfFameArr = Str.split(&apos;,&apos;)</div><div class="line">console.log(hallAllOfFameArr)</div><div class="line">// [&quot;陈寅恪&quot;, &quot;鲁迅&quot;, &quot;钱钟书&quot;, &quot;胡适&quot;, &quot;王国维&quot;, &quot;梁启超&quot;, &quot;吴宓&quot;, &quot;季羡林&quot;]</div></pre></td></tr></table></figure>
<h5 id="2-转化为二维数组"><a href="#2-转化为二维数组" class="headerlink" title="2. 转化为二维数组"></a>2. 转化为二维数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">String.prototype.removeBlankLines = function () &#123;</div><div class="line">	return this.replace(/(\n[\s\t]*\r*\n)/g, &apos;\n&apos;).replace(/^[\n\r\n\t]*|[\n\r\n\t]*$/g, &apos;&apos;)</div><div class="line">&#125;</div><div class="line">String.prototype.strTo2dArr = function(firstSplit, secondSplit)&#123;</div><div class="line">	var contentStr = this.removeBlankLines(),</div><div class="line">		contentStrArr = contentStr.split(firstSplit),</div><div class="line">		resultArr = contentStrArr.map((element) =&gt; &#123;</div><div class="line">            return element.split(secondSplit)</div><div class="line">        &#125;)</div><div class="line">	return resultArr</div><div class="line">&#125;</div><div class="line">var str = `</div><div class="line">渺渺钟声出远方,依依林影万鸦藏。</div><div class="line">一生负气成今日,四海无人对夕阳。</div><div class="line">破碎山河迎胜利,残馀岁月送凄凉。</div><div class="line">松门松菊何年梦,且认他乡作故乡。</div><div class="line">`</div><div class="line">console.log(str.strTo2dArr(&apos;\n&apos;, &apos;,&apos;))</div></pre></td></tr></table></figure>
<p>运行之，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ [ ‘渺渺钟声出远方’, ‘依依林影万鸦藏。’ ],</div><div class="line">[ ‘一生负气成今日’, ‘四海无人对夕阳。’ ],</div><div class="line">[ ‘破碎山河迎胜利’, ‘残馀岁月送凄凉。’ ],</div><div class="line">[ ‘松门松菊何年梦’, ‘且认他乡作故乡。’ ] ]</div></pre></td></tr></table></figure>
<h5 id="3-startsWith"><a href="#3-startsWith" class="headerlink" title="3. startsWith()"></a>3. startsWith()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (typeof String.prototype.startsWith != &apos;function&apos;) &#123;</div><div class="line">  String.prototype.startsWith = function (prefix)&#123;</div><div class="line">    return this.slice(0, prefix.length) === prefix</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-endsWith"><a href="#4-endsWith" class="headerlink" title="4. endsWith()"></a>4. endsWith()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (typeof String.prototype.endsWith != &apos;function&apos;) &#123;</div><div class="line">  String.prototype.endsWith = function(suffix) &#123;</div><div class="line">    return this.indexOf(suffix, this.length - suffix.length) !== -1</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/string/">
    <time datetime="2017-10-09T08:58:28.619Z" class="entry-date">
        2017-10-09
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-nodejs_recursive_copy" class="post-nodejs_recursive_copy post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/nodejs_recursive_copy/">Node.JS循环递归复制文件目录</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>在Node.js中，要实现目录文件夹的循环递归复制也非常简单，使用fs模块即可，仅需几行，而且性能也不错，我们先来实现文件的复制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let fs   = require(&apos;fs&apos;)</div><div class="line">let path = require(&apos;path&apos;)</div><div class="line"></div><div class="line">let copyFile = function(srcPath, tarPath, cb) &#123;</div><div class="line">  let rs = fs.createReadStream(srcPath)</div><div class="line">  rs.on(&apos;error&apos;, function(err) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">      console.log(&apos;read error&apos;, srcPath)</div><div class="line">    &#125;</div><div class="line">    cb &amp;&amp; cb(err)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  let ws = fs.createWriteStream(tarPath)</div><div class="line">  ws.on(&apos;error&apos;, function(err) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">      console.log(&apos;write error&apos;, tarPath)</div><div class="line">    &#125;</div><div class="line">    cb &amp;&amp; cb(err)</div><div class="line">  &#125;)</div><div class="line">  ws.on(&apos;close&apos;, function(ex) &#123;</div><div class="line">    cb &amp;&amp; cb(ex)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  rs.pipe(ws)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>复制目录及其子目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">let copyFolder = function(srcDir, tarDir, cb) &#123;</div><div class="line">  fs.readdir(srcDir, function(err, files) &#123;</div><div class="line">    let count = 0</div><div class="line">    let checkEnd = function() &#123;</div><div class="line">      ++count == files.length &amp;&amp; cb &amp;&amp; cb()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (err) &#123;</div><div class="line">      checkEnd()</div><div class="line">      return</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    files.forEach(function(file) &#123;</div><div class="line">      let srcPath = path.join(srcDir, file)</div><div class="line">      let tarPath = path.join(tarDir, file)</div><div class="line"></div><div class="line">      fs.stat(srcPath, function(err, stats) &#123;</div><div class="line">        if (stats.isDirectory()) &#123;</div><div class="line">          console.log(&apos;mkdir&apos;, tarPath)</div><div class="line">          fs.mkdir(tarPath, function(err) &#123;</div><div class="line">            if (err) &#123;</div><div class="line">              console.log(err)</div><div class="line">              return</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            copyFolder(srcPath, tarPath, checkEnd)</div><div class="line">          &#125;)</div><div class="line">        &#125; else &#123;</div><div class="line">          copyFile(srcPath, tarPath, checkEnd)</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    //为空时直接回调</div><div class="line">    files.length === 0 &amp;&amp; cb &amp;&amp; cb()</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">copyFolder(&apos;...&apos;, &apos;....&apos;, function(err) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //continue</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/nodejs_recursive_copy/">
    <time datetime="2017-09-06T09:42:56.013Z" class="entry-date">
        2017-09-06
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-es2017" class="post-es2017 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/es2017/">ES2017异步函数现已正式可用</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>ES2017标准已于2017年6月份正式定稿了，并广泛支持最新的特性：异步函数。如果你曾经被异步 JavaScript 的逻辑困扰，这么新函数正是为你设计的。</p>
<p>异步函数或多或少会让你编写一些顺序的 JavaScript 代码，但是却不需要在 callbacks、generators 或 promise 中包含你的逻辑。</p>
<p>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function logger() &#123;</div><div class="line">    let data = fetch(&apos;http://sampleapi.com/posts&apos;)</div><div class="line">    console.log(data)</div><div class="line">&#125;</div><div class="line">logger()</div></pre></td></tr></table></figure></p>
<p>这段代码并未实现你的预期。如果你是在JS中编写的，那么你可能会知道为什么。</p>
<p>下面这段代码，却实现了你的预期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">async function logger() &#123;</div><div class="line">    let data = await fetch(&apos;http:sampleapi.com/posts&apos;)</div><div class="line">    console.log(data)</div><div class="line">&#125;</div><div class="line">logger()</div></pre></td></tr></table></figure></p>
<p>这段代码起作用了，从直观上看，仅仅只是多了 async 和 await 两个词。</p>
<p>ES6 标准之前的 JavaScript 异步函数</p>
<p>在深入学习 async 和 await 之前，我们需要先理解 Promise。为了领会 Promise，我们需要回到普通回调函数中进一步学习。</p>
<p>Promise 是在 ES6 中引入的，并促使在编写 JavaScript 的异步代码方面，实现了巨大的提升。从此编写回调函数不再那么痛苦。</p>
<p>回调是一个函数，可以将结果传递给函数并在该函数内进行调用，以便作为事件的响应。同时，这也是JS的基础。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function readFile(&apos;file.txt&apos;, (data) =&gt; &#123;</div><div class="line">    // This is inside the callback function</div><div class="line">    console.log(data)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数只是简单的向文件中记录数据，在文件完成之前进行读取是不可能的。这个过程似乎很简单，但是如果想要按顺序读取并记录五个不同的文件，需要怎么实现呢？</p>
<p>没有 Promise 的时候，为了按顺序执行任务，就需要通过嵌套回调来实现，就像下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// This is officially callback hell</div><div class="line">function combineFiles(file1, file2, file3, printFileCallBack) &#123;</div><div class="line">    let newFileText = &apos;&apos;</div><div class="line">    readFile(string1, (text) =&gt; &#123;</div><div class="line">        newFileText += text</div><div class="line">        readFile(string2, (text) =&gt; &#123;</div><div class="line">            newFileText += text</div><div class="line">            readFile(string3, (text) =&gt; &#123;</div><div class="line">                newFileText += text</div><div class="line">                printFileCallBack(newFileText)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就很难推断函数下面会发生什么，同时也很难处理各种场景下发生的错误，比如其中某个文件不存在的情况。</p>
<p>Promise 改善了这种情况</p>
<p>这正是 Promise 的优势所在，Promise 是对还未产生的数据的一种推理。Kyle Simpson 将 Promise 解释为：就像在快餐店里点餐一样。</p>
<ul>
<li>点餐</li>
<li>为所点的午餐付费，并拿到排队单号</li>
<li>等待午餐</li>
<li>当你的午餐准备好了，会叫你的单号提醒你取餐</li>
<li>收到午餐</li>
</ul>
<p>正如上面的这种场景，当你等餐时，你是无法吃到午餐的，但是你可以提前为吃午餐做好准备。你可以进行其它事情，此时你知道午餐就要来了，虽然此刻你还无法享用它，但是这个午餐已经“promise”给你了。这就是所谓的 promise，表示一个最终会存在的数据的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">readFile(file1)</div><div class="line">    .then((file1-data) =&gt; &#123; /* do something */ &#125;)</div><div class="line">    .then((previous-promise-data) =&gt; &#123; /* do the next thing */ &#125;)</div><div class="line">    .catch( /* handle errors */ )</div></pre></td></tr></table></figure></p>
<p>上面是 Promise 语法。它主要的优点就是可以将队列事件以一种直观的方式链接在一起。虽然这个示例清晰易懂，但是还是用到了回调。Promise 只是让回调显得比较简单和更加直观。</p>
<p>最佳方式：async / await</p>
<p>若干年前，async 函数纳入了 JavaScript 生态系统。就在上个月，async 函数成为了 JavaScript 语言的官方特性，并得到了广泛支持。</p>
<p>async 和 await 是建立在 Promise 和 generator上。本质上，允许我们使用 await 这个关键词在任何函数中的任何我们想要的地方进行暂停。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">async function logger() &#123;</div><div class="line">    // pause until fetch returns</div><div class="line">    let data = await fetch(&apos;http://sampleapi.com/posts&apos;)</div><div class="line">    console.log(data)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这段代码运行之后，得到了想要的结果。代码从 API 调用中记录了数据。</p>
<p>这种方式的好处就是非常直观。编写代码的方式就是大脑思考的方式，告诉脚本在需要的地方暂停。</p>
<p>另一个好处是，当我们不能使用 promise 时，还可以使用 try 和 catch：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async function logger ()  &#123;</div><div class="line">    try &#123;</div><div class="line">        let user_id = await fetch(&apos;/api/users/username&apos;)</div><div class="line">        let posts = await fetch(&apos;/api/`$&#123;user_id&#125;`&apos;)</div><div class="line">        let object = JSON.parse(user.posts.toString())</div><div class="line">        console.log(posts)</div><div class="line">    &#125; catch (error) &#123;</div><div class="line">        console.error(&apos;Error:&apos;, error)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是一个刻意写错的示例，为了证明了一点：在运行过程中，catch 可以捕获任何步骤中发生的错误。至少有三个地方，try 可能会失败，这是在异步代码中的一种最干净的方式来处理错误。</p>
<p>我们还可以使用带有循环和条件的 async 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">async function count() &#123;</div><div class="line">    let counter = 1</div><div class="line">    for (let i = 0; i &lt; 100; i++) &#123;</div><div class="line">        counter += 1</div><div class="line">        console.log(counter)</div><div class="line">        await sleep(1000)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个很简答的例子，如果运行这段程序，将会看到代码在 sleep 调用时暂停，下一个循环迭代将会在1秒后启动。</p>
<p>要点和细节</p>
<p>相信我们已经感受到了 asyns 和 await 的美妙之处，接下来让我们深入了解一下细节：</p>
<p>async 和 await 建立在 Promise 之上。使用 async，总是会返回一个 Promise。请记住这一点，因为这也是容易犯错的地方。<br>当执行到 await 时，程序会暂停当前函数，而不是所有代码<br>async 和 await 是非阻塞的<br>依旧可以使用 Promise helpers，例如 Promise.all( )<br>正如之前的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">async function logPosts ()  &#123;</div><div class="line">    try &#123;</div><div class="line">        let user_id = await fetch(&apos;/api/users/username&apos;)</div><div class="line">        let post_ids = await fetch(&apos;/api/posts/&lt;code&gt;$&#123;user_id&#125;&apos;)</div><div class="line">        let promises = post_ids.map(post_id =&gt; &#123;</div><div class="line">            return  fetch(&apos;/api/posts/$&#123;post_id&#125;&apos;)</div><div class="line">        &#125;</div><div class="line">        let posts = await Promise.all(promises)</div><div class="line">        console.log(posts)</div><div class="line">    &#125; catch (error) &#123;</div><div class="line">        console.error(&apos;Error:&apos;, error)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>await 只能用于声明为 async 的函数中<br>因此，不能在全局范围内使用 await<br>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// throws an error</div><div class="line">function logger (callBack) &#123;</div><div class="line">    console.log(await callBack)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// works!</div><div class="line">async function logger () &#123;</div><div class="line">    console.log(await callBack)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现已正式可用</p>
<p>到2017年6月，几乎所有浏览器都可以使用 async 和 await。为了确保你的代码随时可用，则需要使用 Babel 将你的 JavaScript 代码编译为旧浏览器也支持的语法。</p>
<p>如果对更多ES2017内容感兴趣，请访问ES2017特性的完整列表。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/es2017/">
    <time datetime="2017-08-22T05:58:24.541Z" class="entry-date">
        2017-08-22
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-html5" class="post-html5 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/html5/">HTML5</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><hr>
<blockquote>
<p>用最恰当的HTML元素标记的内容。</p>
</blockquote>
<p>优点：</p>
<ul>
<li>提升可访问性</li>
<li>SEO</li>
<li>结构清晰，利于维护</li>
</ul>
<p>通用容器:</p>
<ul>
<li>div 块级通用容器</li>
<li>span 短语内容无语义容器</li>
</ul>
<p><code>&lt;title&gt;&lt;/title&gt;</code>：简短、描述性、唯一（提升搜索引擎排名）。</p>
<blockquote>
<p>搜索引擎会将title作为判断页面主要内容的指标，有效的title应该包含几个与页面内容密切相关的关键字，建议将title核心内容放在前60个字符中。</p>
</blockquote>
<p><code>&lt;hn&gt;&lt;/hn&gt;</code>：h1~h6分级标题，用于创建页面信息的层级关系。</p>
<blockquote>
<p>对于搜索引擎而言，如果标题与搜索词匹配，这些标题就会被赋予很高的权重，尤其是h1</p>
</blockquote>
<p><code>&lt;header&gt;&lt;/header&gt;</code>：页眉通常包括网站标志、主导航、全站链接以及搜索框。</p>
<blockquote>
<p>也适合对页面内部一组介绍性或导航性内容进行标记。</p>
</blockquote>
<p><code>&lt;nav&gt;&lt;/nav&gt;</code>：标记导航，仅对文档中重要的链接群使用。</p>
<blockquote>
<p>Html5规范不推荐对辅助性页脚链接使用nav，除非页脚再次显示顶级全局导航、或者包含招聘信息等重要链接。</p>
<p><main></main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。</p>
</blockquote>
<p><code>&lt;article&gt;&lt;/article&gt;</code>：表示文档、页面、应用或一个独立的容器。</p>
<blockquote>
<p>article可以嵌套article，只要里面的article与外面的是部分与整体的关系。</p>
</blockquote>
<p><code>&lt;section&gt;&lt;/section&gt;</code>：具有相似主图的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。</p>
<blockquote>
<p>如果只是为了添加样式，请用div</p>
</blockquote>
<p><code>&lt;aside&gt;&lt;/aside&gt;</code>：指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。</p>
<blockquote>
<p>如果放在main内，应该与所在内容密切相关。</p>
</blockquote>
<p><code>&lt;footer&gt;&lt;/footer&gt;</code>：页脚，只有当父级是body时，才是整个页面的页脚。</p>
<p><code>&lt;small&gt;&lt;/small&gt;</code>：指定细则，输入免责声明、注解、署名、版权。</p>
<blockquote>
<p>只适用于短语，不要用来不标记“使用条款”，“隐私政策”等长的法律声明。不单纯的样式标签（有意义的，对搜索引擎抓取有强调意义 strong &gt; em &gt; cite）</p>
</blockquote>
<p><code>&lt;strong&gt;&lt;/strong&gt;</code>：表示内容重要性。</p>
<p><code>&lt;em&gt;&lt;/em&gt;</code>：标记内容着重点（大量用于提升段落文本语义）（斜体）</p>
<p><code>&lt;cite&gt;&lt;/cite&gt;</code>：指明引用或者参考，如图书的标题，歌曲、电影、等的名称，演唱会、音乐会、规范、报纸、或法律文件等。（斜体）</p>
<p><code>&lt;mark&gt;&lt;/mark&gt;</code>：突出显示文本（黄色背景颜色），提醒读者</p>
<p><code>&lt;figure&gt;&lt;/figure&gt;</code>：创建图（默认有40px左右margin）</p>
<p><code>&lt;figcaption&gt;&lt;/figcaption&gt;</code>：figure的标题，必须是figure内嵌的第一个或者最后一个元素。</p>
<p><code>&lt;blockquoto&gt;&lt;/blockquoto&gt;</code>：引述文本，默认新的一行显示。</p>
<p><code>&lt;time&gt;&lt;/time&gt;</code>：标记事件。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。（不再相关的时间用s标签）</p>
<p><code>&lt;abbr&gt;&lt;/abbr&gt;</code>：解释缩写词。使用title属性可提供全称，只在第一次出现时使用就可以了</p>
<p><code>&lt;dfn&gt;&lt;/dfn&gt;</code>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。</p>
<p><code>&lt;address&gt;&lt;/address&gt;</code>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）表示一个具体的地址，字体为斜体，会自动换行</p>
<p><code>&lt;del&gt;&lt;/del&gt;</code>：移除的内容。 <ins></ins>：添加的内容。</p>
<blockquote>
<p>少有的既可以包围块级，又可以包围短语内容的元素。</p>
</blockquote>
<p><code>&lt;code&gt;&lt;/code&gt;</code>：标记代码。包含示例代码或者文件名 （&lt; &lt; &gt; &gt;）</p>
<p><code>&lt;pre&gt;&lt;/pre&gt;</code>：预格式化文本。保留文本固有的换行和空格。</p>
<p><code>&lt;meter&gt;&lt;/meter&gt;</code>：表示分数的值或者已知范围的测量结果。如投票结果。</p>
<blockquote>
<p>例如：<code>&lt;meter value=&quot;0.2&quot; title=”Miles“&gt;20%completed&lt;/meter&gt;</code></p>
</blockquote>
<p><code>&lt;progress&gt;&lt;/progress&gt;</code>：完成进度。可通过js动态更新value。</p>
<h3 id="标签新属性"><a href="#标签新属性" class="headerlink" title="标签新属性"></a>标签新属性</h3><hr>
<h4 id="细说data-dataset-IE11，火狐谷歌"><a href="#细说data-dataset-IE11，火狐谷歌" class="headerlink" title="细说data dataset(IE11，火狐谷歌)"></a>细说data dataset(IE11，火狐谷歌)</h4><blockquote>
<p>在HTML5中我们可以使用data-前缀设置我们需要的自定义属性，来进行一些数据的存放。通过dataset来获取这些数据。这里的data-前缀就被称为data属性，其可以通过脚本进行定义，也可以应用CSS属性选择器进行样式设置。数量不受限制，在控制和渲染数据的时候提供了非常强大的控制。</p>
</blockquote>
<h4 id="一个实例教你如何使用data-dataset"><a href="#一个实例教你如何使用data-dataset" class="headerlink" title="一个实例教你如何使用data dataset"></a>一个实例教你如何使用data dataset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">例如我们要在一个文字按钮上存放相对应的id</div><div class="line"></div><div class="line">下面是元素应用data属性的一个例子：</div><div class="line"></div><div class="line">&lt;div id=&quot;food&quot; data-drink=&quot;coffee&quot; data-food=&quot;sushi&quot; data-meal=&quot;lunch&quot;&gt;¥20.12&lt;/div&gt;</div><div class="line">// 要想获取某个属性的值，可以像下面这样使用dataset对象：</div><div class="line">var food = document.getElementById(&apos;food&apos;); </div><div class="line">var typeOfDrink = food.dataset.drink;</div><div class="line">classList(火狐谷歌最新，IE10以上)</div><div class="line">obj.classList.add() 添加class类</div><div class="line">obj.classList.remove() 移出class类</div><div class="line">obj.classList.contains() 判断是否包含指定class类</div><div class="line">obj.classList.toggle() 切换class类</div><div class="line">obj.classList.length 获取class类的个数</div></pre></td></tr></table></figure>
<h4 id="classList-火狐谷歌最新，IE10以上"><a href="#classList-火狐谷歌最新，IE10以上" class="headerlink" title="classList(火狐谷歌最新，IE10以上)"></a>classList(火狐谷歌最新，IE10以上)</h4><ul>
<li>obj.classList.add() 添加class类</li>
<li>obj.classList.remove() 移出class类</li>
<li>obj.classList.contains() 判断是否包含指定class类</li>
<li>obj.classList.toggle() 切换class类</li>
<li>obj.classList.length 获取class类的个数</li>
</ul>
<h3 id="HTML5新表单"><a href="#HTML5新表单" class="headerlink" title="HTML5新表单"></a>HTML5新表单</h3><hr>
<h4 id="新的input类型"><a href="#新的input类型" class="headerlink" title="新的input类型"></a>新的input类型</h4><p>email<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">email 类型用于应该包含 e-mail 地址的输入域。在提交表单时，会自动验证 email 域的值。</div><div class="line"></div><div class="line">E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">url 类型用于应该包含 URL 地址的输入域。在提交表单时，会自动验证 url 域的值。</div><div class="line"></div><div class="line">Homepage: &lt;input type=&quot;url&quot; name=&quot;user_url&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>number<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">number 类型用于应该包含数值的输入域。您还能够设定对所接受的数字的限定：</div><div class="line"></div><div class="line">Points: &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>range<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">range 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。您还能够设定对所接受的数字的限定：</div><div class="line"></div><div class="line">&lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>search<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">search 类型用于搜索域，比如站点搜索或 Google 搜索。search 域显示为常规的文本域。</div></pre></td></tr></table></figure></p>
<h4 id="新的form属性"><a href="#新的form属性" class="headerlink" title="新的form属性"></a>新的form属性</h4><p>autocomplete</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</div><div class="line">注释：autocomplete 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。</div><div class="line"></div><div class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;</div><div class="line">    E-mail: &lt;input type=&quot;email&quot; name=&quot;email&quot; autocomplete=&quot;off&quot; /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>novalidate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">novalidate 属性规定在提交表单时不应该验证 form 或 input 域。</div><div class="line">注释：novalidate 属性适用于 &lt;form&gt; 以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.</div><div class="line"></div><div class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</div><div class="line">    E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div><div class="line">    &lt;input type=&quot;submit&quot; /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<h4 id="新的input属性"><a href="#新的input属性" class="headerlink" title="新的input属性"></a>新的input属性</h4><p>autocomplete</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</div><div class="line">注释：autocomplete 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。</div><div class="line"></div><div class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;</div><div class="line">    E-mail: &lt;input type=&quot;email&quot; name=&quot;email&quot; autocomplete=&quot;off&quot; /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>autofocus</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">autofocus 属性规定在页面加载时，域自动地获得焦点。</div><div class="line">注释：autofocus 属性适用于所有 &lt;input&gt; 标签的类型。</div><div class="line"></div><div class="line">User name: &lt;input type=&quot;text&quot; name=&quot;user_name&quot;  autofocus=&quot;autofocus&quot; /&gt;</div></pre></td></tr></table></figure>
<p>form</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">form 属性规定输入域所属的一个或多个表单。</div><div class="line">注释：form 属性适用于所有 &lt;input&gt; 标签的类型。</div><div class="line">form 属性必须引用所属表单的 id：</div><div class="line"></div><div class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; id=&quot;user_form&quot;&gt;</div><div class="line">    First name:&lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;</div><div class="line">    &lt;input type=&quot;submit&quot; /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; form=&quot;user_form&quot; /&gt;</div></pre></td></tr></table></figure>
<p>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">表单重写属性（form override attributes）允许您重写 form 元素的某些属性设定。</div><div class="line">- 表单重写属性有：</div><div class="line">    1. formaction - 重写表单的 action 属性</div><div class="line">    2. formenctype - 重写表单的 enctype 属性</div><div class="line">    3. formmethod - 重写表单的 method 属性</div><div class="line">    4. formnovalidate - 重写表单的 novalidate 属性</div><div class="line">    5. formtarget - 重写表单的 target 属性</div><div class="line">注释：表单重写属性适用于以下类型的 &lt;input&gt; 标签：submit 和 image。</div><div class="line"></div><div class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; id=&quot;user_form&quot;&gt;</div><div class="line">E-mail: &lt;input type=&quot;email&quot; name=&quot;userid&quot; /&gt;&lt;br /&gt;</div><div class="line">&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</div><div class="line">&lt;br /&gt;</div><div class="line">&lt;input type=&quot;submit&quot; formaction=&quot;demo_admin.asp&quot; value=&quot;Submit as admin&quot; /&gt;</div><div class="line">&lt;br /&gt;</div><div class="line">&lt;input type=&quot;submit&quot; formnovalidate=&quot;true&quot; value=&quot;Submit without validation&quot; /&gt;</div><div class="line">&lt;br /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<h4 id="height-和-width-属性"><a href="#height-和-width-属性" class="headerlink" title="height 和 width 属性"></a>height 和 width 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">height 和 width 属性规定用于 image 类型的 input 标签的图像高度和宽度。</div><div class="line">注释：height 和 width 属性只适用于 image 类型的 &lt;input&gt; 标签。</div><div class="line"></div><div class="line">&lt;input type=&quot;image&quot; src=&quot;img_submit.gif&quot; width=&quot;99&quot; height=&quot;99&quot; /&gt;</div></pre></td></tr></table></figure>
<h4 id="list-属性"><a href="#list-属性" class="headerlink" title="list 属性"></a>list 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">list 属性规定输入域的 datalist。datalist 是输入域的选项列表。</div><div class="line">注释：list 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, date pickers, number, range 以及 color。</div><div class="line"></div><div class="line">Webpage: &lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;link&quot; /&gt;</div><div class="line">    &lt;datalist id=&quot;url_list&quot;&gt;</div><div class="line">    &lt;option label=&quot;W3Schools&quot; value=&quot;http://www.w3school.com.cn&quot; /&gt;</div><div class="line">    &lt;option label=&quot;Google&quot; value=&quot;http://www.google.com&quot; /&gt;</div><div class="line">    &lt;option label=&quot;Microsoft&quot; value=&quot;http://www.microsoft.com&quot; /&gt;</div><div class="line">&lt;/datalist&gt;</div></pre></td></tr></table></figure>
<h4 id="min、max-和-step-属性"><a href="#min、max-和-step-属性" class="headerlink" title="min、max 和 step 属性"></a>min、max 和 step 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">min、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。</div><div class="line">max 属性规定输入域所允许的最大值。</div><div class="line">min 属性规定输入域所允许的最小值。</div><div class="line">step 属性为输入域规定合法的数字间隔（如果 step=&quot;3&quot;，则合法的数是 -3,0,3,6 等）。</div><div class="line">注释：min、max 和 step 属性适用于以下类型的 &lt;input&gt; 标签：date pickers、number 以及 range。</div><div class="line">下面的例子显示一个数字域，该域接受介于 0 到 10 之间的值，且步进为 3（即合法的值为 0、3、6 和 9）：</div><div class="line"></div><div class="line">Points: &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;3&quot; /&gt;</div></pre></td></tr></table></figure>
<h4 id="multiple-属性"><a href="#multiple-属性" class="headerlink" title="multiple 属性"></a>multiple 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">multiple 属性规定输入域中可选择多个值。</div><div class="line">注释：multiple 属性适用于以下类型的 &lt;input&gt; 标签：email 和 file。</div><div class="line"></div><div class="line">Select images: &lt;input type=&quot;file&quot; name=&quot;img&quot; multiple=&quot;multiple&quot; /&gt;</div></pre></td></tr></table></figure>
<h4 id="novalidate-属性"><a href="#novalidate-属性" class="headerlink" title="novalidate 属性"></a>novalidate 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">novalidate 属性规定在提交表单时不应该验证 form 或 input 域。</div><div class="line">注释：novalidate 属性适用于 &lt;form&gt; 以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, range 以及 color.</div><div class="line"></div><div class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</div><div class="line">    E-mail: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</div><div class="line">    &lt;input type=&quot;submit&quot; /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<h4 id="pattern-属性"><a href="#pattern-属性" class="headerlink" title="pattern 属性"></a>pattern 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pattern 属性规定用于验证 input 域的模式（pattern）。</div><div class="line">注释：pattern 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email 以及 password。</div><div class="line">下面的例子显示了一个只能包含三个字母的文本域（不含数字及特殊字符）：</div><div class="line"></div><div class="line">Country code: &lt;input type=&quot;text&quot; name=&quot;country_code&quot;</div><div class="line">pattern=&quot;[A-z]&#123;3&#125;&quot; title=&quot;Three letter country code&quot; /&gt;</div></pre></td></tr></table></figure>
<h4 id="placeholder-属性"><a href="#placeholder-属性" class="headerlink" title="placeholder 属性"></a>placeholder 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">placeholder 属性提供一种提示（hint），描述输入域所期待的值。</div><div class="line">注释：placeholder 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email 以及 password。</div><div class="line">提示（hint）会在输入域为空时显示出现，会在输入域获得焦点时消失：</div><div class="line"></div><div class="line">&lt;input type=&quot;search&quot; name=&quot;user_search&quot;  placeholder=&quot;Search W3School&quot; /&gt;</div></pre></td></tr></table></figure>
<h4 id="required-属性"><a href="#required-属性" class="headerlink" title="required 属性"></a>required 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">required 属性规定必须在提交之前填写输入域（不能为空）。</div><div class="line">注释：required 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。</div><div class="line"></div><div class="line">Name: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; required=&quot;required&quot; /&gt;</div></pre></td></tr></table></figure>
<h3 id="音频-audio-和视频-video"><a href="#音频-audio-和视频-video" class="headerlink" title="音频(audio)和视频(video)"></a>音频(audio)和视频(video)</h3><hr>
<h4 id="支持的格式和写法"><a href="#支持的格式和写法" class="headerlink" title="支持的格式和写法"></a>支持的格式和写法</h4><p>音频元素支持的3种格式：Ogg MP3 Wav<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;audio controls&gt;</div><div class="line">  &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt;</div><div class="line">  &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;</div><div class="line">  您的浏览器不支持 audio 元素。</div><div class="line">&lt;/audio&gt;</div></pre></td></tr></table></figure></p>
<p>视频元素支持三种视频格式：MP4、WebM、Ogg。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;</div><div class="line">    &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</div><div class="line">    &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</div><div class="line">    您的浏览器不支持 video 标签。</div><div class="line">&lt;/video&gt;</div></pre></td></tr></table></figure></p>
<h4 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h4><ul>
<li>音视频：autoplay、controls、loop、muted、preload、src</li>
<li>视频：autoplay、controls、loop、muted、width、height、poster、preload、src</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>load():重新加载音频／视频元素</li>
<li>play()：开始播放音频／视频</li>
<li>pause()：暂停当前播放的音频／视频</li>
</ul>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul>
<li>durationchange:当音频/视频的时长已更改时</li>
<li>ended:当目前的播放列表已结束时</li>
<li>pause:当音频/视频已暂停时</li>
<li>play:当音频/视频已开始或不再暂停时</li>
<li>ratechange:当音频/视频的播放速度已更改时</li>
<li>timeupdate:当目前的播放位置已更改时</li>
<li>volumechange:当音量已更改时</li>
</ul>
<h4 id="事件属性"><a href="#事件属性" class="headerlink" title="事件属性"></a>事件属性</h4><p>1.只读属性</p>
<ul>
<li>duration：返回当前的总时长</li>
<li>currentSrc：返回当前URL</li>
<li>ended：返回是否已结束</li>
<li>paused：返回是否已暂停<br>2.获取并可修改的属性：</li>
<li>autoplay：设置或返回是否自动播放</li>
<li>controls：设置或返回是否显示控件（比如播放/暂停等）</li>
<li>loop：设置或返回是否是循环播放</li>
<li>muted：设置或返回是否静音</li>
<li>currentTime：设置或返回当前播放位置（以秒计）</li>
<li>volume：设置或返回音量（规定音频/视频的当前音量。必须是介于 0.0 与 1.0 之间的数字。）1.0 是最高音量（默认）；0.5 是一半音量 （50%）； 0.0 是静音；</li>
<li>playbackRate：设置或返回播放速度</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/html5/">
    <time datetime="2017-08-07T09:24:23.777Z" class="entry-date">
        2017-08-07
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-promise" class="post-promise post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/promise/">八段代码彻底掌握 Promise</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="1-Promise的立即执行性"><a href="#1-Promise的立即执行性" class="headerlink" title="1.Promise的立即执行性"></a>1.Promise的立即执行性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var p = new Promise(function(resolve, reject)&#123;</div><div class="line">  console.log(&quot;create a promise&quot;);</div><div class="line">  resolve(&quot;success&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&quot;after new Promise&quot;);</div><div class="line"></div><div class="line">p.then(function(value)&#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;create a promise&quot;</div><div class="line">&quot;after new Promise&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure></p>
<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。</p>
<h3 id="2-Promise-三种状态"><a href="#2-Promise-三种状态" class="headerlink" title="2.Promise 三种状态"></a>2.Promise 三种状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function(resolve,reject)&#123;</div><div class="line">  resolve(1);</div><div class="line">&#125;);</div><div class="line">var p2 = new Promise(function(resolve,reject)&#123;</div><div class="line">  setTimeout(function()&#123;</div><div class="line">    resolve(2);  </div><div class="line">  &#125;, 500);      </div><div class="line">&#125;);</div><div class="line">var p3 = new Promise(function(resolve,reject)&#123;</div><div class="line">  setTimeout(function()&#123;</div><div class="line">    reject(3);  </div><div class="line">  &#125;, 500);      </div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(p1);</div><div class="line">console.log(p2);</div><div class="line">console.log(p3);</div><div class="line">setTimeout(function()&#123;</div><div class="line">  console.log(p2);</div><div class="line">&#125;, 1000);</div><div class="line">setTimeout(function()&#123;</div><div class="line">  console.log(p3);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">p1.then(function(value)&#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;);</div><div class="line">p2.then(function(value)&#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;);</div><div class="line">p3.catch(function(err)&#123;</div><div class="line">  console.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1&#125;</div><div class="line">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</div><div class="line">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2&#125;</div><div class="line">Promise &#123;[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3&#125;</div></pre></td></tr></table></figure></p>
<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>
<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个<code>setTimeout</code>函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>
<h3 id="3-Promise-状态的不可逆性"><a href="#3-Promise-状态的不可逆性" class="headerlink" title="3.Promise 状态的不可逆性"></a>3.Promise 状态的不可逆性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function(resolve, reject)&#123;</div><div class="line">  resolve(&quot;success1&quot;);</div><div class="line">  resolve(&quot;success2&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p2 = new Promise(function(resolve, reject)&#123;</div><div class="line">  resolve(&quot;success&quot;);</div><div class="line">  reject(&quot;reject&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(function(value)&#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(function(value)&#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;success1&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure>
<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中<code>resolve(&quot;success2&quot;)</code>并不能将p1的值更改为<code>success2</code>，p2中<code>reject(&quot;reject&quot;)</code>也不能将p2的状态由resolved改变为rejected.</p>
<h3 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4.链式调用"></a>4.链式调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var p = new Promise(function(resolve, reject)&#123;</div><div class="line">  resolve(1);</div><div class="line">&#125;);</div><div class="line">p.then(function(value)&#123;               //第一个then</div><div class="line">  console.log(value);</div><div class="line">  return value*2;</div><div class="line">&#125;).then(function(value)&#123;              //第二个then</div><div class="line">  console.log(value);</div><div class="line">&#125;).then(function(value)&#123;              //第三个then</div><div class="line">  console.log(value);</div><div class="line">  return Promise.resolve(&apos;resolve&apos;); </div><div class="line">&#125;).then(function(value)&#123;              //第四个then</div><div class="line">  console.log(value);</div><div class="line">  return Promise.reject(&apos;reject&apos;);</div><div class="line">&#125;).then(function(value)&#123;              //第五个then</div><div class="line">  console.log(&apos;resolve: &apos;+ value);</div><div class="line">&#125;, function(err)&#123;</div><div class="line">  console.log(&apos;reject: &apos; + err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">undefined</div><div class="line">&quot;resolve&quot;</div><div class="line">&quot;reject: reject&quot;</div></pre></td></tr></table></figure>
<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li>return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li>return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
<li>throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。</li>
</ul>
<p>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p>
<h3 id="5-Promise-then-回调异步性"><a href="#5-Promise-then-回调异步性" class="headerlink" title="5.Promise then() 回调异步性"></a>5.Promise then() 回调异步性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var p = new Promise(function(resolve, reject)&#123;</div><div class="line">  resolve(&quot;success&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(function(value)&#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&quot;which one is called first ?&quot;);</div></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;which one is called first ?&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure>
<p>Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>
<h3 id="6-Promise-中的异常"><a href="#6-Promise-中的异常" class="headerlink" title="6.Promise 中的异常"></a>6.Promise 中的异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise( function(resolve,reject)&#123;</div><div class="line">  foo.bar();</div><div class="line">  resolve( 1 );      </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  function(value)&#123;</div><div class="line">    console.log(&apos;p1 then value: &apos; + value);</div><div class="line">  &#125;,</div><div class="line">  function(err)&#123;</div><div class="line">    console.log(&apos;p1 then err: &apos; + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  function(value)&#123;</div><div class="line">    console.log(&apos;p1 then then value: &apos;+value);</div><div class="line">  &#125;,</div><div class="line">  function(err)&#123;</div><div class="line">    console.log(&apos;p1 then then err: &apos; + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">var p2 = new Promise(function(resolve,reject)&#123;</div><div class="line">  resolve( 2 );    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  function(value)&#123;</div><div class="line">    console.log(&apos;p2 then value: &apos; + value);</div><div class="line">    foo.bar();</div><div class="line">  &#125;, </div><div class="line">  function(err)&#123;</div><div class="line">    console.log(&apos;p2 then err: &apos; + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  function(value)&#123;</div><div class="line">    console.log(&apos;p2 then then value: &apos; + value);</div><div class="line">  &#125;,</div><div class="line">  function(err)&#123;</div><div class="line">    console.log(&apos;p2 then then err: &apos; + err);</div><div class="line">    return 1;</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  function(value)&#123;</div><div class="line">    console.log(&apos;p2 then then then value: &apos; + value);</div><div class="line">  &#125;,</div><div class="line">  function(err)&#123;</div><div class="line">    console.log(&apos;p2 then then then err: &apos; + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p1 then err: ReferenceError: foo is not defined</div><div class="line">p2 then value: 2</div><div class="line">p1 then then value: undefined</div><div class="line">p2 then then err: ReferenceError: foo is not defined</div><div class="line">p2 then then then value: 1</div></pre></td></tr></table></figure>
<p>Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。</p>
<h3 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7.Promise.resolve()"></a>7.Promise.resolve()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var p1 = Promise.resolve( 1 );</div><div class="line">var p2 = Promise.resolve( p1 );</div><div class="line">var p3 = new Promise(function(resolve, reject)&#123;</div><div class="line">  resolve(1);</div><div class="line">&#125;);</div><div class="line">var p4 = new Promise(function(resolve, reject)&#123;</div><div class="line">  resolve(p1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(p1 === p2); </div><div class="line">console.log(p1 === p3);</div><div class="line">console.log(p1 === p4);</div><div class="line">console.log(p3 === p4);</div><div class="line"></div><div class="line">p4.then(function(value)&#123;</div><div class="line">  console.log(&apos;p4=&apos; + value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(function(value)&#123;</div><div class="line">  console.log(&apos;p2=&apos; + value);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p1.then(function(value)&#123;</div><div class="line">  console.log(&apos;p1=&apos; + value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">false</div><div class="line">false</div><div class="line">false</div><div class="line">p2=1</div><div class="line">p1=1</div><div class="line">p4=1</div></pre></td></tr></table></figure>
<p><code>Promise.resolve(...)</code>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h3 id="8-resolve-vs-reject"><a href="#8-resolve-vs-reject" class="headerlink" title="8.resolve vs reject"></a>8.resolve vs reject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function(resolve, reject)&#123;</div><div class="line">  resolve(Promise.resolve(&apos;resolve&apos;));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p2 = new Promise(function(resolve, reject)&#123;</div><div class="line">  resolve(Promise.reject(&apos;reject&apos;));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p3 = new Promise(function(resolve, reject)&#123;</div><div class="line">  reject(Promise.resolve(&apos;resolve&apos;));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  function fulfilled(value)&#123;</div><div class="line">    console.log(&apos;fulfilled: &apos; + value);</div><div class="line">  &#125;, </div><div class="line">  function rejected(err)&#123;</div><div class="line">    console.log(&apos;rejected: &apos; + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  function fulfilled(value)&#123;</div><div class="line">    console.log(&apos;fulfilled: &apos; + value);</div><div class="line">  &#125;, </div><div class="line">  function rejected(err)&#123;</div><div class="line">    console.log(&apos;rejected: &apos; + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p3.then(</div><div class="line">  function fulfilled(value)&#123;</div><div class="line">    console.log(&apos;fulfilled: &apos; + value);</div><div class="line">  &#125;, </div><div class="line">  function rejected(err)&#123;</div><div class="line">    console.log(&apos;rejected: &apos; + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p3 rejected: [object Promise]</div><div class="line">p1 fulfilled: resolve</div><div class="line">p2 rejected: reject</div></pre></td></tr></table></figure>
<p>Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/promise/">
    <time datetime="2017-07-27T05:52:58.479Z" class="entry-date">
        2017-07-27
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-nodejs-email" class="post-nodejs-email post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/nodejs-email/">Node.js获取Email</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>POP3POP3全称为Post Office Protocol version3，是TCP/IP协议族的一员，由RFC 1939定义。其主要提供离线处理邮件，这种离线访问的模式是一种存储转发服务，将邮件从邮件服务器传送到客户端，本地的一些移动、标记操作并不影响服务器端。POP3的客户端首先与服务器建立TCP连接(默认端口是110)，随后向服务器发送命令并等待响应。服务器接收客户端的命令并返回响应。这种你来我往的交互方式维持着两者之间的通信并持续到连接终止。</p>
<p>客户端的命令由一个命令和一些参数组成并以空格隔开，以CRLF(Carriage Return-Line Feed:\r\n)对结束。其中命令采用ASCII码，但不区分大小写，区分大小写的是其随后的参数。POP3服务器响应由一个状态码和一个可能跟有附加信息的命令组成，所有响应也是由CRLF对结束。状态码的值分为”positive”(“+OK”)和”negetive”(“-ERR”)。当信息发送完毕时，最后一行以结束符(.)加CRLF对。</p>
<p>在整个生命周期中，POP3会话存在的状态有如下几种。当服务器响应命令请求发送授权响应，这一过程为授权(AUTHORIZATION)状态。客户端向服务器发出身份认证并经过服务器确认后就进入了事务（TRANSACTION）状态。这一状态下，服务器获取客户的相关邮件资源，并接收客户端的如下命令：STAT、LIST、RETR、DELE、NOOP、RSET、QUIT 。当客户端发出QUIT命令后，会话会进入更新(UPDATE)状态。在这状态中，服务器会释放上一状态中取得的资源，并终止连接。<br><img title="" src="https://my-owo-ink.b0.upaiyun.com/owo.ink/nodejs-email/1f86d20ff453fb2a49c457b5f96e5.png"></p>
<p>接下来使用node的poplib包来实现POP3客户端的功能。这里我以qq邮件举例，我们先需要把qq邮件服务器的POP3的功能打开，具体可查看相关官方文档。qq邮件的host为’pop.qq.com’，port为995。</p>
<p><pre class="lang:default decode:true ">var POP3Client = require(‘poplib’);<br>//首先建立连接<br>var client = new POP3Client(port, host, {<br>      tlserrs: false, //是否忽略tls errors<br>      enabletls: true, //传输层安全协议ssl<br>      debug: true //是否在console输出命令和响应信息<br>});</pre><br>当然我们需要捕获异常来响应服务器发出的错误码，比如111就是服务器拒绝链接。以及一些程序运行过程的控制。通过这些预警措施能有效控制程序的状态。</p>
<p><pre>//network error handler<br>client.on(‘error’, function(err){<br>      if(err.errno === 111){<br>            console.log(‘Unable to connect to server.’);<br>      }else{<br>            console.log(‘Server error occurred.’);<br>      }<br>      //console错误<br>      console.log(err);<br>});<br>//state invalid handler 处理状态与命令不一致的情况<br>client.on(‘invalid-state’, function(cmd){<br>      console.log(‘Invalid state. You tried calling ‘, cmd);<br>});<br>//locked handler 处理多命令同时进行的问题<br>client.on(‘locked’, function(cmd){<br>      console.log(‘Current conmand has not finished yet. You tried calling ‘, cmd);<br>});</pre><br>按照开始所述的POP3服务流程，我们需要先建立与服务器的连接，并进行身份认证才能进行邮件的获取操作。首先获取邮件列表，再获取第一封邮件的内容。这些操作都成功后就发出QUIT命令来退出服务。</p>
<p><pre>//connect to the remote server<br>client.on(‘connect’, function(){<br>      console.log(‘CONNECT success’);<br>  //成功建立连接后进入AUTHORIZATION状态，进行身份认证<br>      client.login(username, password);<br>});<br>/**</pre></p>
<ul>
<li>Successfully login<br>*/<br>//login handler status Boolean<br>client.on(‘login’, function(status, rawdata){<br>   if(status){<pre><code>console.log(&apos;LOGIN/PASS success.&apos;);
//获取邮件列表
client.list();
</code></pre>   }else{<pre><code>console.log(&apos;ERR: LOGIN/PASS failed&apos;);
client.quit();
</code></pre>   }<br>});<br>//LIST handler<br>client.on(‘list’, function(status, msgcount, msgnumber, data, rawdata){<br>   if(status === false){<pre><code>console.log(&apos;LIST failed&apos;);
//获取失败，退出服务
client.quit();
</code></pre>   }else{<pre><code>console.log(&apos;LIST success with&apos;, msgcount, &apos; element(s).&apos;);
if(msgcount &amp;gt; 0){
</code></pre>   //获取第一封邮件<pre><code>      client.retr(1);
}
</code></pre>   }<br>});<br>//RETR handler<br>client.on(‘retr’, function(status, msgnumber, data, rawdata){<br>   if(status === true){<pre><code>console.log(&apos;RETR success&apos;, msgnumber);
</code></pre> //获得后，输出data数据<br> console.log(‘data is ‘, data);<pre><code>client.quit();
</code></pre>   }else{<pre><code>console.log(&apos;ERR: RETR failed for msgnumber&apos;, msgnumber);
</code></pre>   }<br>});<br>//QUIT handler<br>client.on(‘quit’, function(status, rawdata){<br>   if(status === true){<pre><code>console.log(&apos;QUIT success&apos;);
process.exit(0);
</code></pre>   }else{<br> console.log(‘ERR: QUIT failed.’);<pre><code>process.exit(0);
</code></pre>   }<br>});<br>这个lib的使用非常简单，但对于结果解析的支持基本没有。不能很好满足我们的需求。所以需要替换为另一个比较复杂但功能更多的邮件协议——IMAP。  </li><li>IMAPIMAP全称为Internet Message Access Protocol，和POP3一样是邮件访问的协议。现在的版本为IMAP4rev1，和POP3相比主要有以下不同。<br>  </li><li>支持在线和离线操作。IMAP客户端可以一直连接在服务器上，获得更快的响应时间。</li><br>  <li>支持多客户端。提供一种机制让客户能够感知其他当前连接到这个邮箱的用户所做的操作。</li><br>  <li>支持访问消息中的MIME部分。</li><br>  <li>支持在服务器保留消息状态信息。服务器可以跟踪消息状态提供，多个客户在不同时间访问一个邮箱可以感知其他用户所做的操作。</li><br>  <li>支持在服务器上访问多个邮箱。</li><br>  <li>支持服务器端搜索。</li><br>  <li>支持一个定义良好的扩展机制。</li>


</ul>
<p>IMAP服务包括了一系列操作：邮箱的建立、删除及重命名、检查新邮件、永久删除邮件、设置和清除标志、基于服务器和 MIME 的分析和搜索、有效并有选择的取回邮件属性、文本和部分内容。兼顾这么多功能的IMAP的命令就比POP3多多了。命令的格式也有所不同，客户端的命令带标签前缀，通过客户端定义，node-imap包的前缀为A加数字(数字通过每次操作累加)。而服务器响应用”+”作为前缀，响应的类型分为”OK”成功、”NO”失败、”BAD”错误。<br><a href="http://owo-10017157.cossh.myqcloud.com/nodejs-email/c9c3956ac4ce3d6e72da0ba0cb0c6.jpg" alt="IMAP协议的状态" target="_blank" rel="external"></a></p><br>IMAP协议的状态类型有4种，通过状态之间转化来理解IMAP的工作流程。如图，建立连接后，连接会进入认证或者未认证状态。如果是预认证的连接状态会进入认证状态，否则处于未认证的状态。认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、SELECT、EXAMINE、CREATE、DELETE、RENAME、SUBSCRIBE、UNSUBSCRIBE、LIST、LSUB、STATUS和APPEND。，未认证状态可接收的命令有CAPABILITY、NOOP、LOGOUT、STARTTLS、AUTHENTICATE、LOGIN。如果出现不适当的命令引发协议错误，则进入注销状态。进入认证状态后，可以发出SELECT命令来选择邮件，这时连接就进入了选中状态。选择状态相比认证状态也接收CHECK、CLOSE、EXPUNGE、SEARCH、FETCH、STORE、COPY及UID命令。当进行退出命令时，进入注销状态。当服务器发出LOGOUT的响应后，双方断开连接。这些命令可以参考<a href="https://blog.sina.com.cn/s/blog_604124c10100db11.html" target="_blank" rel="external">IMAP命令详解</a>。<p></p>
<p>我写的例程在node-imap的例子基础上使用mailparser包来解析邮件正文，然后存储到本地磁盘。</p>
<p>node-imap首先需要创建客户端的实例，通过将认证信息和服务器配置传递给它构造函数。这个实例需要监听ready消息，这个消息是在连接状态属于认证状态时才被触发。触发后，我们选择要打开INBOX邮件文件夹，回调中获得到的信息为这个文件夹中的相关消息，比如messages数和文件夹中可使用的flags等。我们接着在这个文件夹中进行搜索命令，当然可以直接就使用搜索命令对这个邮箱进行邮件搜索。我们搜索的条件为未阅邮件以及时间限制，这个方法返回的是匹配的邮件编号。通过邮件编号，我们能获得这个邮件的内容，获取的命令为FETCH。其imap.fetch()来执行，第一个参数是邮件编号数组，第二个参数是指定返回的邮件的部分内容，node-imap也会自动添加来一些信息字段，比如UID、FLAGS、INTERNALDATE。然后我们在等待fetch到的数据传递回来。这一阶段的代码如下。</p>
<p><pre>function openInbox(cb){<br>  imap.openBox(‘INBOX’, true, cb);<br>};<br>//等待触发ready<br>imap.once(‘ready’, function(){<br>  openInbox(function(err, box){<br>    if(err){<br>      //抛出异常 imap处理<br>      throw err;<br>    }else{<br>      console.log(‘Info: You have %d messages in your INBOX’, box.messages.total);<br>      imap.search([‘UNSEEN’, [ ‘SINCE’ , ‘2015-06-14’ ]], function(err, results){<br>        console.log(‘Debug: search results is ‘ + results);<br>        if(err){<br>          throw err;<br>        }else{<br>          var f = imap.fetch(results, { bodies: ‘’, struct: true });<br>          //接下来对得到的数据处理<br>          //…<br>        }<br>      }<br>    }<br>  }<br>});</pre><br>监听到’message’消息后，通过Mailparset包来解析邮件内容。为了节省内存消耗，通过steam的方式将数据传递给解析器。解析器再将邮件数据存储起来。</p>
<p><pre>f.on(‘message’, function(msg, seqno){<br>  var mailparser = new MailParser();<br>  console.log(‘Info: Message #%d’, seqno);<br>  var prefix = ‘(#’ + seqno + ‘)’;<br>  //正文内容的处理<br>  msg.on(‘body’, function(stream, info){<br>    console.log(‘Debug: info.which: ‘ + info.which);<br>    if(info.which === ‘TEXT’){<br>      console.log(prefix + ‘Body [%s] found, %d total bytes’, inspect(info.which), info.size);<br>    }<br>    //pipe到mailparse解析器<br>    stream.pipe(mailparser);<br>    var buffer = ‘’,<br>        count = 0;<br>    stream.on(‘data’, function(chunk){<br>      count += chunk.length;<br>      buffer += chunk.toString(‘utf8’);<br>    });<br>    //stream结束，向console发出消息<br>    stream.once(‘end’, function(){<br>      if(info.which !== ‘TEXT’){<br>        console.log(prefix + ‘Parsed header: %s’, inspect(Imap.parseHeader(buffer)));<br>      }else{<br>        console.log(prefix + ‘Body[%s] Finished’, inspect(info.which));<br>      }<br>    });<br>    //解析器将获得的数据存储到磁盘。<br>    mailparser.on(“end”, function(mail){<br>      fs.writeFile(‘msg- ‘ + seqno + ‘-body.html’, mail.html, function(err){<br>        if(err){<br>          throw err;<br>        }<br>        console.log(‘Info: #%d saved!’, seqno);<br>      });<br>      //如果有附件，则存储起来。<br>      if(mail.attachments){<br>        mail.attachments.forEach(function(attachment){<br>            console.log(attachment.fileName);<br>            fs.writeFile(‘msg-‘ + seqno + ‘-‘ + attachment.generatedFileName, attachment.content, function(err){<br>              if(err){<br>                throw err;<br>              }<br>              console.log(‘Info: #%d attachment saved!’, seqno);<br>            });<br>        });<br>      }<br>  });<br>});</pre><br>接下来还需要做的事是将邮件数据聚合，以一封完整的格式存储到MongoDB数据库中。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/nodejs-email/">
    <time datetime="2017-07-21T08:27:19.028Z" class="entry-date">
        2017-07-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-mobile-phone-system" class="post-mobile-phone-system post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/mobile-phone-system/">判断iOS或Android手机</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>通过判断浏览器的userAgent，用正则来判断手机是否是ios和android客户端。<span>代码</span>如下：</p>
<p><pre>&lt;script type=”text/javascript”&gt;<br>var u = navigator.userAgent;<br>var isAndroid = u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Adr’) &gt; -1; //android终端<br>var isiOS = !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端<br>alert(‘是否是Android：’+isAndroid);<br>alert(‘是否是iOS：’+isiOS);<br>&lt;/script&gt;</pre><br>下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端、ipad、iphone、微信、QQ等。</p>
<p><pre>&lt;script type=”text/javascript”&gt;<br>//判断访问终端<br>var browser={<br>    versions:function(){<br>        var u = navigator.userAgent, app = navigator.appVersion;<br>        return {<br>            trident: u.indexOf(‘Trident’) &gt; -1, //IE内核<br>            presto: u.indexOf(‘Presto’) &gt; -1, //opera内核<br>            webKit: u.indexOf(‘AppleWebKit’) &gt; -1, //苹果、谷歌内核<br>            gecko: u.indexOf(‘Gecko’) &gt; -1 &amp;&amp; u.indexOf(‘KHTML’) == -1,//火狐内核<br>            mobile: !!u.match(/AppleWebKit.<em>Mobile.</em>/), //是否为移动终端<br>            ios: !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端<br>            android: u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Adr’) &gt; -1, //android终端<br>            iPhone: u.indexOf(‘iPhone’) &gt; -1 , //是否为iPhone或者QQHD浏览器<br>            iPad: u.indexOf(‘iPad’) &gt; -1, //是否iPad<br>            webApp: u.indexOf(‘Safari’) == -1, //是否web应该程序，没有头部与底部<br>            weixin: u.indexOf(‘MicroMessenger’) &gt; -1, //是否微信 （2015-01-22新增）<br>            qq: u.match(/\sQQ/i) == “ qq” //是否QQ<br>        };<br>    }(),<br>    language:(navigator.browserLanguage || navigator.language).toLowerCase()<br>}<br>&lt;/script&gt;<br></pre><br><strong>使用方法：</strong></p>
<p><pre class="lang:js decode:true ">//判断是否IE内核<br>if(browser.versions.trident){ alert(“is IE”); }<br>//判断是否webKit内核<br>if(browser.versions.webKit){ alert(“is webKit”); }<br>//判断是否移动端<br>if(browser.versions.mobile||browser.versions.android||browser.versions.ios){ alert(“移动端”); }</pre><br><strong>检测浏览器语言</strong>：</p>
<p><pre class="lang:js decode:true ">currentLang = navigator.language;   //判断除IE外其他浏览器使用语言<br>if(!currentLang){//判断IE浏览器使用语言<br>    currentLang = navigator.browserLanguage;<br>}<br>alert(currentLang);</pre><br>第二种：</p>
<p><pre class="lang:default decode:true ">if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {<br>    //alert(navigator.userAgent);<br>    window.location.href =”iPhone.html”;<br>} else if (/(Android)/i.test(navigator.userAgent)) {<br>    //alert(navigator.userAgent);<br>    window.location.href =”Android.html”;<br>} else {<br>    window.location.href =”pc.html”;<br>};</pre><br>&nbsp;</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/mobile-phone-system/">
    <time datetime="2017-07-21T08:24:27.021Z" class="entry-date">
        2017-07-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-text" class="post-text post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/text/">vue子组件与父组件通讯</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>记录</p>
<p>JSON转字符串 JSON.stringify()</p>
<p>JSON字符串转换为JSON对象 JSON.parse(str)</p>
<p>判断数据类型 typeof</p>
<p>查看进程：ps -ef |grep nodejs</p>
<p>nohup后台 nohup meteor –production &amp;</p>
<p>查看运行的后台进程  jobs</p>
<p>fg %n将后台脚本调到前台执行</p>
<p>linux重启：shutdown -r now </p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/text/">
    <time datetime="2017-07-21T08:22:49.623Z" class="entry-date">
        2017-07-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-meteor" class="post-meteor post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/meteor/">Meteor</a>
    </h1>
  

        
        <div class="comments-link">
            
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>1.启动方式 <code>meteor -p 80</code></p>
<p>2.使用nohup后台运行meteor</p>
<ul>
<li>nohup meteor -p 80 &amp;</li>
<li>jobs</li>
<li>exit</li>
</ul>
<p>3.meteor数据库启动失败试试<br><code>rm -rf .meteor/local/db/mongod.lock .meteor/local/db/journal/</code></p>
<p>4.docker下MongoDB无法启动<br><a href="https://github.com/meteor/meteor/issues/4019" target="_blank" rel="external">帮助信息</a></p>
<p><code>apt-get install language-pack-en -y</code></p>
<p>5.docker下出现<code>You are attempting to run Meteor as the &#39;root&#39; superuser</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export METEOR_NO_RELEASE_CHECK=true</div><div class="line">curl https://install.meteor.com/?release=1.4.1.3 | sh</div></pre></td></tr></table></figure></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/meteor/">
    <time datetime="2017-07-21T08:20:08.513Z" class="entry-date">
        2017-07-21
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/saveFile/">js保存文件</a>
          </li>
        
          <li>
            <a href="/string/">JavaScript 字符串实用常操纪要</a>
          </li>
        
          <li>
            <a href="/nodejs_recursive_copy/">Node.JS循环递归复制文件目录</a>
          </li>
        
          <li>
            <a href="/es2017/">ES2017异步函数现已正式可用</a>
          </li>
        
          <li>
            <a href="/html5/">HTML5</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2017 PUGE
    All rights reserved.</p>
    <p>Powered by <a href="https://owo.ink/" target="_blank">PUGE</a></p>
</footer>
    <div id="bg"></div>

  </div>
</body>
</html>